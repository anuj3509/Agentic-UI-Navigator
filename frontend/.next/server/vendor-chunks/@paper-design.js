"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@paper-design";
exports.ids = ["vendor-chunks/@paper-design"];
exports.modules = {

/***/ "(ssr)/./node_modules/@paper-design/shaders-react/dist/color-props-are-equal.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@paper-design/shaders-react/dist/color-props-are-equal.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   colorPropsAreEqual: () => (/* binding */ colorPropsAreEqual)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nfunction colorPropsAreEqual(prevProps, nextProps) {\n  for (const key in prevProps) {\n    if (key === \"colors\") {\n      const prevIsArray = Array.isArray(prevProps.colors);\n      const nextIsArray = Array.isArray(nextProps.colors);\n      if (!prevIsArray || !nextIsArray) {\n        if (Object.is(prevProps.colors, nextProps.colors) === false) {\n          return false;\n        }\n        continue;\n      }\n      if (prevProps.colors?.length !== nextProps.colors?.length) {\n        return false;\n      }\n      if (!prevProps.colors?.every((color, index) => color === nextProps.colors?.[index])) {\n        return false;\n      }\n      continue;\n    }\n    if (Object.is(prevProps[key], nextProps[key]) === false) {\n      return false;\n    }\n  }\n  return true;\n}\n\n//# sourceMappingURL=color-props-are-equal.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzLXJlYWN0L2Rpc3QvY29sb3ItcHJvcHMtYXJlLWVxdWFsLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0BwYXBlci1kZXNpZ24vc2hhZGVycy1yZWFjdC9kaXN0L2NvbG9yLXByb3BzLWFyZS1lcXVhbC5qcz83NWE2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiAgICAgICAgICAgICAgICAgICAgUGFwZXIgU2hhZGVycyAgICAgICAgICAgICAgICAgICAgKlxuICogICAgICAgaHR0cHM6Ly9naXRodWIuY29tL3BhcGVyLWRlc2lnbi9zaGFkZXJzICAgICAgICpcbiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqL1xuXG5mdW5jdGlvbiBjb2xvclByb3BzQXJlRXF1YWwocHJldlByb3BzLCBuZXh0UHJvcHMpIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gcHJldlByb3BzKSB7XG4gICAgaWYgKGtleSA9PT0gXCJjb2xvcnNcIikge1xuICAgICAgY29uc3QgcHJldklzQXJyYXkgPSBBcnJheS5pc0FycmF5KHByZXZQcm9wcy5jb2xvcnMpO1xuICAgICAgY29uc3QgbmV4dElzQXJyYXkgPSBBcnJheS5pc0FycmF5KG5leHRQcm9wcy5jb2xvcnMpO1xuICAgICAgaWYgKCFwcmV2SXNBcnJheSB8fCAhbmV4dElzQXJyYXkpIHtcbiAgICAgICAgaWYgKE9iamVjdC5pcyhwcmV2UHJvcHMuY29sb3JzLCBuZXh0UHJvcHMuY29sb3JzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocHJldlByb3BzLmNvbG9ycz8ubGVuZ3RoICE9PSBuZXh0UHJvcHMuY29sb3JzPy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCFwcmV2UHJvcHMuY29sb3JzPy5ldmVyeSgoY29sb3IsIGluZGV4KSA9PiBjb2xvciA9PT0gbmV4dFByb3BzLmNvbG9ycz8uW2luZGV4XSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChPYmplY3QuaXMocHJldlByb3BzW2tleV0sIG5leHRQcm9wc1trZXldKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5leHBvcnQge1xuICBjb2xvclByb3BzQXJlRXF1YWxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2xvci1wcm9wcy1hcmUtZXF1YWwuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders-react/dist/color-props-are-equal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders-react/dist/shader-mount.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@paper-design/shaders-react/dist/shader-mount.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShaderMount: () => (/* binding */ ShaderMount)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @paper-design/shaders */ \"(ssr)/./node_modules/@paper-design/shaders/dist/get-empty-pixel.js\");\n/* harmony import */ var _paper_design_shaders__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @paper-design/shaders */ \"(ssr)/./node_modules/@paper-design/shaders/dist/shader-mount.js\");\n/* harmony import */ var _use_merge_refs_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./use-merge-refs.js */ \"(ssr)/./node_modules/@paper-design/shaders-react/dist/use-merge-refs.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */ /* __next_internal_client_entry_do_not_use__ ShaderMount auto */ \n\n\n\nasync function processUniforms(uniformsProp) {\n    const processedUniforms = {};\n    const imageLoadPromises = [];\n    const isValidUrl = (url)=>{\n        try {\n            if (url.startsWith(\"/\")) return true;\n            new URL(url);\n            return true;\n        } catch  {\n            return false;\n        }\n    };\n    const isExternalUrl = (url)=>{\n        try {\n            if (url.startsWith(\"/\")) return false;\n            const urlObject = new URL(url, window.location.origin);\n            return urlObject.origin !== window.location.origin;\n        } catch  {\n            return false;\n        }\n    };\n    Object.entries(uniformsProp).forEach(([key, value])=>{\n        if (typeof value === \"string\") {\n            if (!value) {\n                processedUniforms[key] = (0,_paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.getEmptyPixel)();\n                return;\n            }\n            if (!isValidUrl(value)) {\n                console.warn(`Uniform \"${key}\" has invalid URL \"${value}\". Skipping image loading.`);\n                return;\n            }\n            const imagePromise = new Promise((resolve, reject)=>{\n                const img = new Image();\n                if (isExternalUrl(value)) {\n                    img.crossOrigin = \"anonymous\";\n                }\n                img.onload = ()=>{\n                    processedUniforms[key] = img;\n                    resolve();\n                };\n                img.onerror = ()=>{\n                    console.error(`Could not set uniforms. Failed to load image at ${value}`);\n                    reject();\n                };\n                img.src = value;\n            });\n            imageLoadPromises.push(imagePromise);\n        } else {\n            processedUniforms[key] = value;\n        }\n    });\n    await Promise.all(imageLoadPromises);\n    return processedUniforms;\n}\nconst ShaderMount = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function ShaderMountImpl({ fragmentShader, uniforms: uniformsProp, webGlContextAttributes, speed = 0, frame = 0, width, height, minPixelRatio, maxPixelCount, mipmaps, style, ...divProps }, forwardedRef) {\n    const [isInitialized, setIsInitialized] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const divRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const shaderMountRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const webGlContextAttributesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(webGlContextAttributes);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const initShader = async ()=>{\n            const uniforms = await processUniforms(uniformsProp);\n            if (divRef.current && !shaderMountRef.current) {\n                shaderMountRef.current = new _paper_design_shaders__WEBPACK_IMPORTED_MODULE_3__.ShaderMount(divRef.current, fragmentShader, uniforms, webGlContextAttributesRef.current, speed, frame, minPixelRatio, maxPixelCount, mipmaps);\n                setIsInitialized(true);\n            }\n        };\n        initShader();\n        return ()=>{\n            shaderMountRef.current?.dispose();\n            shaderMountRef.current = null;\n        };\n    }, [\n        fragmentShader\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let isStale = false;\n        const updateUniforms = async ()=>{\n            const uniforms = await processUniforms(uniformsProp);\n            if (!isStale) {\n                shaderMountRef.current?.setUniforms(uniforms);\n            }\n        };\n        updateUniforms();\n        return ()=>{\n            isStale = true;\n        };\n    }, [\n        uniformsProp,\n        isInitialized\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        shaderMountRef.current?.setSpeed(speed);\n    }, [\n        speed,\n        isInitialized\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        shaderMountRef.current?.setMaxPixelCount(maxPixelCount);\n    }, [\n        maxPixelCount,\n        isInitialized\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        shaderMountRef.current?.setMinPixelRatio(minPixelRatio);\n    }, [\n        minPixelRatio,\n        isInitialized\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        shaderMountRef.current?.setFrame(frame);\n    }, [\n        frame,\n        isInitialized\n    ]);\n    const mergedRef = (0,_use_merge_refs_js__WEBPACK_IMPORTED_MODULE_4__.useMergeRefs)([\n        divRef,\n        forwardedRef\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n        ref: mergedRef,\n        style: width !== void 0 || height !== void 0 ? {\n            width: typeof width === \"string\" && isNaN(+width) === false ? +width : width,\n            height: typeof height === \"string\" && isNaN(+height) === false ? +height : height,\n            ...style\n        } : style,\n        ...divProps\n    });\n});\nShaderMount.displayName = \"ShaderMount\";\n //# sourceMappingURL=shader-mount.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzLXJlYWN0L2Rpc3Qvc2hhZGVyLW1vdW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OzsySEFFd0Q7QUFPakQ7QUFDc0I7QUE2TXZCO0FBcktOLGVBQWVTLGdCQUFnQkMsWUFBQTtJQUM3QixNQUFNQyxvQkFBb0IsQ0FBQztJQUMzQixNQUFNQyxvQkFBcUMsRUFBQztJQUU1QyxNQUFNQyxhQUFhLENBQUNDO1FBQ2xCLElBQUk7WUFFRixJQUFJQSxJQUFJQyxVQUFBLENBQVcsTUFBTSxPQUFPO1lBRWhDLElBQUlDLElBQUlGO1lBQ1IsT0FBTztRQUNULFNBQVE7WUFDTixPQUFPO1FBQ1Q7SUFDRjtJQUVBLE1BQU1HLGdCQUFnQixDQUFDSDtRQUNyQixJQUFJO1lBQ0YsSUFBSUEsSUFBSUMsVUFBQSxDQUFXLE1BQU0sT0FBTztZQUNoQyxNQUFNRyxZQUFZLElBQUlGLElBQUlGLEtBQUtLLE9BQU9DLFFBQUEsQ0FBU0MsTUFBTTtZQUNyRCxPQUFPSCxVQUFVRyxNQUFBLEtBQVdGLE9BQU9DLFFBQUEsQ0FBU0MsTUFBQTtRQUM5QyxTQUFRO1lBQ04sT0FBTztRQUNUO0lBQ0Y7SUFFQUMsT0FBT0MsT0FBQSxDQUFRYixjQUFjYyxPQUFBLENBQVEsQ0FBQyxDQUFDQyxLQUFLQyxNQUFLO1FBQy9DLElBQUksT0FBT0EsVUFBVSxVQUFVO1lBRTdCLElBQUksQ0FBQ0EsT0FBTztnQkFDVmYsaUJBQUEsQ0FBa0JjLElBQUcsR0FBSW5CLG9FQUFhQTtnQkFDdEM7WUFDRjtZQUdBLElBQUksQ0FBQ08sV0FBV2EsUUFBUTtnQkFDdEJDLFFBQVFDLElBQUEsQ0FBSyxZQUFZSCxJQUFHLHFCQUFzQkMsTUFBSywyQkFBNEI7Z0JBQ25GO1lBQ0Y7WUFFQSxNQUFNRyxlQUFlLElBQUlDLFFBQWMsQ0FBQ0MsU0FBU0M7Z0JBQy9DLE1BQU1DLE1BQU0sSUFBSUM7Z0JBQ2hCLElBQUlqQixjQUFjUyxRQUFRO29C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TUFBTSxDQUFDeEIsWUFBWSxRQUFRLENBQUNBLFNBQVNBO1lBQzNFLEdBQUdJLEtBQUE7UUFDTCxJQUNBQTtRQUVMLEdBQUdDLFFBQUE7SUFBQTtBQUdWO0FBR0ZsRCxZQUFZc0UsV0FBQSxHQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uLi9zcmMvc2hhZGVyLW1vdW50LnRzeD80MDUzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIGZvcndhcmRSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHtcbiAgU2hhZGVyTW91bnQgYXMgU2hhZGVyTW91bnRWYW5pbGxhLFxuICBnZXRFbXB0eVBpeGVsLFxuICB0eXBlIFBhcGVyU2hhZGVyRWxlbWVudCxcbiAgdHlwZSBTaGFkZXJNb3Rpb25QYXJhbXMsXG4gIHR5cGUgU2hhZGVyTW91bnRVbmlmb3Jtcyxcbn0gZnJvbSAnQHBhcGVyLWRlc2lnbi9zaGFkZXJzJztcbmltcG9ydCB7IHVzZU1lcmdlUmVmcyB9IGZyb20gJy4vdXNlLW1lcmdlLXJlZnMuanMnO1xuXG4vKipcbiAqIFJlYWN0IFNoYWRlciBNb3VudCBjYW4gYWxzbyBhY2NlcHQgc3RyaW5ncyBhcyB1bmlmb3JtIHZhbHVlcywgd2hpY2ggd2lsbCBhc3N1bWVkIHRvIGJlIFVSTHMgYW5kIGxvYWRlZCBhcyBpbWFnZXNcbiAqXG4gKiBXZSBhY2NlcHQgdW5kZWZpbmVkIGFzIGEgY29udmVuaWVuY2UgZm9yIHNlcnZlciByZW5kZXJpbmcsIHdoZW4gc29tZSB0aGluZ3MgbWF5IGJlIHVuZGVmaW5lZFxuICogV2UganVzdCBza2lwIHNldHRpbmcgdGhlIHVuaWZvcm0gaWYgaXQncyB1bmRlZmluZWQuIFRoaXMgYWxsb3dzIHRoZSBzaGFkZXIgbW91bnQgdG8gc3RpbGwgdGFrZSB1cCBzcGFjZSBkdXJpbmcgc2VydmVyIHJlbmRlcmluZ1xuICovXG5pbnRlcmZhY2UgU2hhZGVyTW91bnRVbmlmb3Jtc1JlYWN0IHtcbiAgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgYm9vbGVhbiB8IG51bWJlciB8IG51bWJlcltdIHwgbnVtYmVyW11bXSB8IEhUTUxJbWFnZUVsZW1lbnQgfCB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2hhZGVyTW91bnRQcm9wcyBleHRlbmRzIE9taXQ8UmVhY3QuQ29tcG9uZW50UHJvcHM8J2Rpdic+LCAnY29sb3InIHwgJ3JlZic+LCBTaGFkZXJNb3Rpb25QYXJhbXMge1xuICByZWY/OiBSZWFjdC5SZWY8UGFwZXJTaGFkZXJFbGVtZW50PjtcbiAgZnJhZ21lbnRTaGFkZXI6IHN0cmluZztcbiAgdW5pZm9ybXM6IFNoYWRlck1vdW50VW5pZm9ybXNSZWFjdDtcbiAgbWlwbWFwcz86IHN0cmluZ1tdO1xuICBtaW5QaXhlbFJhdGlvPzogbnVtYmVyO1xuICBtYXhQaXhlbENvdW50PzogbnVtYmVyO1xuICB3ZWJHbENvbnRleHRBdHRyaWJ1dGVzPzogV2ViR0xDb250ZXh0QXR0cmlidXRlcztcblxuICAvKiogSW5saW5lIENTUyB3aWR0aCBzdHlsZSAqL1xuICB3aWR0aD86IHN0cmluZyB8IG51bWJlcjtcbiAgLyoqIElubGluZSBDU1MgaGVpZ2h0IHN0eWxlICovXG4gIGhlaWdodD86IHN0cmluZyB8IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTaGFkZXJDb21wb25lbnRQcm9wcyBleHRlbmRzIE9taXQ8UmVhY3QuQ29tcG9uZW50UHJvcHM8J2Rpdic+LCAnY29sb3InIHwgJ3JlZic+IHtcbiAgcmVmPzogUmVhY3QuUmVmPFBhcGVyU2hhZGVyRWxlbWVudD47XG4gIG1pblBpeGVsUmF0aW8/OiBudW1iZXI7XG4gIG1heFBpeGVsQ291bnQ/OiBudW1iZXI7XG4gIHdlYkdsQ29udGV4dEF0dHJpYnV0ZXM/OiBXZWJHTENvbnRleHRBdHRyaWJ1dGVzO1xuXG4gIC8qKiBJbmxpbmUgQ1NTIHdpZHRoIHN0eWxlICovXG4gIHdpZHRoPzogc3RyaW5nIHwgbnVtYmVyO1xuICAvKiogSW5saW5lIENTUyBoZWlnaHQgc3R5bGUgKi9cbiAgaGVpZ2h0Pzogc3RyaW5nIHwgbnVtYmVyO1xufVxuXG4vKiogUGFyc2UgdGhlIHByb3ZpZGVkIHVuaWZvcm1zLCB0dXJuaW5nIFVSTCBzdHJpbmdzIGludG8gbG9hZGVkIGltYWdlcyAqL1xuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1VuaWZvcm1zKHVuaWZvcm1zUHJvcDogU2hhZGVyTW91bnRVbmlmb3Jtc1JlYWN0KTogUHJvbWlzZTxTaGFkZXJNb3VudFVuaWZvcm1zPiB7XG4gIGNvbnN0IHByb2Nlc3NlZFVuaWZvcm1zID0ge30gYXMgU2hhZGVyTW91bnRVbmlmb3JtcztcbiAgY29uc3QgaW1hZ2VMb2FkUHJvbWlzZXM6IFByb21pc2U8dm9pZD5bXSA9IFtdO1xuXG4gIGNvbnN0IGlzVmFsaWRVcmwgPSAodXJsOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gSGFuZGxlIGFic29sdXRlIHBhdGhzXG4gICAgICBpZiAodXJsLnN0YXJ0c1dpdGgoJy8nKSkgcmV0dXJuIHRydWU7XG4gICAgICAvLyBDaGVjayBpZiBpdCdzIGEgdmFsaWQgVVJMXG4gICAgICBuZXcgVVJMKHVybCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgaXNFeHRlcm5hbFVybCA9ICh1cmw6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAodXJsLnN0YXJ0c1dpdGgoJy8nKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgY29uc3QgdXJsT2JqZWN0ID0gbmV3IFVSTCh1cmwsIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pO1xuICAgICAgcmV0dXJuIHVybE9iamVjdC5vcmlnaW4gIT09IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW47XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIE9iamVjdC5lbnRyaWVzKHVuaWZvcm1zUHJvcCkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFVzZSBhIHRyYW5zcGFyZW50IHBpeGVsIGZvciBlbXB0eSBzdHJpbmdzXG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHByb2Nlc3NlZFVuaWZvcm1zW2tleV0gPSBnZXRFbXB0eVBpeGVsKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gTWFrZSBzdXJlIHRoZSBwcm92aWRlZCBzdHJpbmcgaXMgYSB2YWxpZCBVUkwgb3IganVzdCBza2lwIHRyeWluZyB0byBzZXQgdGhpcyB1bmlmb3JtIGVudGlyZWx5XG4gICAgICBpZiAoIWlzVmFsaWRVcmwodmFsdWUpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgVW5pZm9ybSBcIiR7a2V5fVwiIGhhcyBpbnZhbGlkIFVSTCBcIiR7dmFsdWV9XCIuIFNraXBwaW5nIGltYWdlIGxvYWRpbmcuYCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaW1hZ2VQcm9taXNlID0gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgaWYgKGlzRXh0ZXJuYWxVcmwodmFsdWUpKSB7XG4gICAgICAgICAgaW1nLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cyc7XG4gICAgICAgIH1cbiAgICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICBwcm9jZXNzZWRVbmlmb3Jtc1trZXldID0gaW1nO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaW1nLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgQ291bGQgbm90IHNldCB1bmlmb3Jtcy4gRmFpbGVkIHRvIGxvYWQgaW1hZ2UgYXQgJHt2YWx1ZX1gKTtcbiAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaW1nLnNyYyA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgICBpbWFnZUxvYWRQcm9taXNlcy5wdXNoKGltYWdlUHJvbWlzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3NlZFVuaWZvcm1zW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIGF3YWl0IFByb21pc2UuYWxsKGltYWdlTG9hZFByb21pc2VzKTtcbiAgcmV0dXJuIHByb2Nlc3NlZFVuaWZvcm1zO1xufVxuXG4vKipcbiAqIEEgUmVhY3QgY29tcG9uZW50IHRoYXQgbW91bnRzIGEgc2hhZGVyIGFuZCB1cGRhdGVzIGl0cyB1bmlmb3JtcyBhcyB0aGUgY29tcG9uZW50J3MgcHJvcHMgY2hhbmdlXG4gKiBJZiB5b3UgcGFzcyBhIHN0cmluZyBhcyBhIHVuaWZvcm0gdmFsdWUsIGl0IHdpbGwgYmUgYXNzdW1lZCB0byBiZSBhIFVSTCBhbmQgYXR0ZW1wdGVkIHRvIGJlIGxvYWRlZCBhcyBhbiBpbWFnZVxuICovXG5leHBvcnQgY29uc3QgU2hhZGVyTW91bnQ6IFJlYWN0LkZDPFNoYWRlck1vdW50UHJvcHM+ID0gZm9yd2FyZFJlZjxQYXBlclNoYWRlckVsZW1lbnQsIFNoYWRlck1vdW50UHJvcHM+KFxuICBmdW5jdGlvbiBTaGFkZXJNb3VudEltcGwoXG4gICAge1xuICAgICAgZnJhZ21lbnRTaGFkZXIsXG4gICAgICB1bmlmb3JtczogdW5pZm9ybXNQcm9wLFxuICAgICAgd2ViR2xDb250ZXh0QXR0cmlidXRlcyxcbiAgICAgIHNwZWVkID0gMCxcbiAgICAgIGZyYW1lID0gMCxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgbWluUGl4ZWxSYXRpbyxcbiAgICAgIG1heFBpeGVsQ291bnQsXG4gICAgICBtaXBtYXBzLFxuICAgICAgc3R5bGUsXG4gICAgICAuLi5kaXZQcm9wc1xuICAgIH0sXG4gICAgZm9yd2FyZGVkUmVmXG4gICkge1xuICAgIGNvbnN0IFtpc0luaXRpYWxpemVkLCBzZXRJc0luaXRpYWxpemVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBkaXZSZWYgPSB1c2VSZWY8UGFwZXJTaGFkZXJFbGVtZW50PihudWxsKTtcbiAgICBjb25zdCBzaGFkZXJNb3VudFJlZjogUmVhY3QuUmVmT2JqZWN0PFNoYWRlck1vdW50VmFuaWxsYSB8IG51bGw+ID0gdXNlUmVmPFNoYWRlck1vdW50VmFuaWxsYT4obnVsbCk7XG4gICAgY29uc3Qgd2ViR2xDb250ZXh0QXR0cmlidXRlc1JlZiA9IHVzZVJlZih3ZWJHbENvbnRleHRBdHRyaWJ1dGVzKTtcblxuICAgIC8vIEluaXRpYWxpemUgdGhlIFNoYWRlck1vdW50VmFuaWxsYVxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBjb25zdCBpbml0U2hhZGVyID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCB1bmlmb3JtcyA9IGF3YWl0IHByb2Nlc3NVbmlmb3Jtcyh1bmlmb3Jtc1Byb3ApO1xuXG4gICAgICAgIGlmIChkaXZSZWYuY3VycmVudCAmJiAhc2hhZGVyTW91bnRSZWYuY3VycmVudCkge1xuICAgICAgICAgIHNoYWRlck1vdW50UmVmLmN1cnJlbnQgPSBuZXcgU2hhZGVyTW91bnRWYW5pbGxhKFxuICAgICAgICAgICAgZGl2UmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBmcmFnbWVudFNoYWRlcixcbiAgICAgICAgICAgIHVuaWZvcm1zLFxuICAgICAgICAgICAgd2ViR2xDb250ZXh0QXR0cmlidXRlc1JlZi5jdXJyZW50LFxuICAgICAgICAgICAgc3BlZWQsXG4gICAgICAgICAgICBmcmFtZSxcbiAgICAgICAgICAgIG1pblBpeGVsUmF0aW8sXG4gICAgICAgICAgICBtYXhQaXhlbENvdW50LFxuICAgICAgICAgICAgbWlwbWFwc1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICBzZXRJc0luaXRpYWxpemVkKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpbml0U2hhZGVyKCk7XG5cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHNoYWRlck1vdW50UmVmLmN1cnJlbnQ/LmRpc3Bvc2UoKTtcbiAgICAgICAgc2hhZGVyTW91bnRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9O1xuICAgIH0sIFtmcmFnbWVudFNoYWRlcl0pO1xuXG4gICAgLy8gVW5pZm9ybXNcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgbGV0IGlzU3RhbGUgPSBmYWxzZTtcblxuICAgICAgY29uc3QgdXBkYXRlVW5pZm9ybXMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHVuaWZvcm1zID0gYXdhaXQgcHJvY2Vzc1VuaWZvcm1zKHVuaWZvcm1zUHJvcCk7XG5cbiAgICAgICAgaWYgKCFpc1N0YWxlKSB7XG4gICAgICAgICAgLy8gV2Ugb25seSB1c2UgdGhlIGZyZXNoZXN0IHVuaWZvcm1zIG90aGVyd2lzZSB3ZSBjYW4gZ2V0IGludG8gcmFjZSBjb25kaXRpb25zXG4gICAgICAgICAgLy8gaWYgc29tZSB1bmlmb3JtcyAoaW1hZ2VzISkgdGFrZSBsb25nZXIgdG8gbG9hZCBpbiBzdWJzZXF1ZW50IGVmZmVjdCBydW5zLlxuICAgICAgICAgIHNoYWRlck1vdW50UmVmLmN1cnJlbnQ/LnNldFVuaWZvcm1zKHVuaWZvcm1zKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdXBkYXRlVW5pZm9ybXMoKTtcblxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaXNTdGFsZSA9IHRydWU7XG4gICAgICB9O1xuICAgIH0sIFt1bmlmb3Jtc1Byb3AsIGlzSW5pdGlhbGl6ZWRdKTtcblxuICAgIC8vIFNwZWVkXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIHNoYWRlck1vdW50UmVmLmN1cnJlbnQ/LnNldFNwZWVkKHNwZWVkKTtcbiAgICB9LCBbc3BlZWQsIGlzSW5pdGlhbGl6ZWRdKTtcblxuICAgIC8vIE1heCBQaXhlbCBDb3VudFxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBzaGFkZXJNb3VudFJlZi5jdXJyZW50Py5zZXRNYXhQaXhlbENvdW50KG1heFBpeGVsQ291bnQpO1xuICAgIH0sIFttYXhQaXhlbENvdW50LCBpc0luaXRpYWxpemVkXSk7XG5cbiAgICAvLyBNaW4gUGl4ZWwgUmF0aW9cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgc2hhZGVyTW91bnRSZWYuY3VycmVudD8uc2V0TWluUGl4ZWxSYXRpbyhtaW5QaXhlbFJhdGlvKTtcbiAgICB9LCBbbWluUGl4ZWxSYXRpbywgaXNJbml0aWFsaXplZF0pO1xuXG4gICAgLy8gRnJhbWVcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgc2hhZGVyTW91bnRSZWYuY3VycmVudD8uc2V0RnJhbWUoZnJhbWUpO1xuICAgIH0sIFtmcmFtZSwgaXNJbml0aWFsaXplZF0pO1xuXG4gICAgY29uc3QgbWVyZ2VkUmVmID0gdXNlTWVyZ2VSZWZzKFtkaXZSZWYsIGZvcndhcmRlZFJlZl0pIGFzIHVua25vd24gYXMgUmVhY3QuUmVmT2JqZWN0PEhUTUxEaXZFbGVtZW50PjtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdlxuICAgICAgICByZWY9e21lcmdlZFJlZn1cbiAgICAgICAgc3R5bGU9e1xuICAgICAgICAgIHdpZHRoICE9PSB1bmRlZmluZWQgfHwgaGVpZ2h0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiB0eXBlb2Ygd2lkdGggPT09ICdzdHJpbmcnICYmIGlzTmFOKCt3aWR0aCkgPT09IGZhbHNlID8gK3dpZHRoIDogd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0eXBlb2YgaGVpZ2h0ID09PSAnc3RyaW5nJyAmJiBpc05hTigraGVpZ2h0KSA9PT0gZmFsc2UgPyAraGVpZ2h0IDogaGVpZ2h0LFxuICAgICAgICAgICAgICAgIC4uLnN0eWxlLFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHN0eWxlXG4gICAgICAgIH1cbiAgICAgICAgey4uLmRpdlByb3BzfVxuICAgICAgLz5cbiAgICApO1xuICB9XG4pO1xuXG5TaGFkZXJNb3VudC5kaXNwbGF5TmFtZSA9ICdTaGFkZXJNb3VudCc7XG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwiZm9yd2FyZFJlZiIsInVzZVN0YXRlIiwiU2hhZGVyTW91bnQiLCJTaGFkZXJNb3VudFZhbmlsbGEiLCJnZXRFbXB0eVBpeGVsIiwidXNlTWVyZ2VSZWZzIiwianN4IiwicHJvY2Vzc1VuaWZvcm1zIiwidW5pZm9ybXNQcm9wIiwicHJvY2Vzc2VkVW5pZm9ybXMiLCJpbWFnZUxvYWRQcm9taXNlcyIsImlzVmFsaWRVcmwiLCJ1cmwiLCJzdGFydHNXaXRoIiwiVVJMIiwiaXNFeHRlcm5hbFVybCIsInVybE9iamVjdCIsIndpbmRvdyIsImxvY2F0aW9uIiwib3JpZ2luIiwiT2JqZWN0IiwiZW50cmllcyIsImZvckVhY2giLCJrZXkiLCJ2YWx1ZSIsImNvbnNvbGUiLCJ3YXJuIiwiaW1hZ2VQcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJpbWciLCJJbWFnZSIsImNyb3NzT3JpZ2luIiwib25sb2FkIiwib25lcnJvciIsImVycm9yIiwic3JjIiwicHVzaCIsImFsbCIsIlNoYWRlck1vdW50SW1wbCIsImZyYWdtZW50U2hhZGVyIiwidW5pZm9ybXMiLCJ3ZWJHbENvbnRleHRBdHRyaWJ1dGVzIiwic3BlZWQiLCJmcmFtZSIsIndpZHRoIiwiaGVpZ2h0IiwibWluUGl4ZWxSYXRpbyIsIm1heFBpeGVsQ291bnQiLCJtaXBtYXBzIiwic3R5bGUiLCJkaXZQcm9wcyIsImZvcndhcmRlZFJlZiIsImlzSW5pdGlhbGl6ZWQiLCJzZXRJc0luaXRpYWxpemVkIiwiZGl2UmVmIiwic2hhZGVyTW91bnRSZWYiLCJ3ZWJHbENvbnRleHRBdHRyaWJ1dGVzUmVmIiwiaW5pdFNoYWRlciIsImN1cnJlbnQiLCJkaXNwb3NlIiwiaXNTdGFsZSIsInVwZGF0ZVVuaWZvcm1zIiwic2V0VW5pZm9ybXMiLCJzZXRTcGVlZCIsInNldE1heFBpeGVsQ291bnQiLCJzZXRNaW5QaXhlbFJhdGlvIiwic2V0RnJhbWUiLCJtZXJnZWRSZWYiLCJyZWYiLCJpc05hTiIsImRpc3BsYXlOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders-react/dist/shader-mount.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders-react/dist/shaders/liquid-metal.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@paper-design/shaders-react/dist/shaders/liquid-metal.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LiquidMetal: () => (/* binding */ LiquidMetal),\n/* harmony export */   defaultPreset: () => (/* binding */ defaultPreset),\n/* harmony export */   fullScreenPreset: () => (/* binding */ fullScreenPreset),\n/* harmony export */   liquidMetalPresets: () => (/* binding */ liquidMetalPresets),\n/* harmony export */   noirPreset: () => (/* binding */ noirPreset),\n/* harmony export */   stripesPreset: () => (/* binding */ stripesPreset)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _shader_mount_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../shader-mount.js */ \"(ssr)/./node_modules/@paper-design/shaders-react/dist/shader-mount.js\");\n/* harmony import */ var _paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @paper-design/shaders */ \"(ssr)/./node_modules/@paper-design/shaders/dist/shader-sizing.js\");\n/* harmony import */ var _paper_design_shaders__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @paper-design/shaders */ \"(ssr)/./node_modules/@paper-design/shaders/dist/shaders/liquid-metal.js\");\n/* harmony import */ var _paper_design_shaders__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @paper-design/shaders */ \"(ssr)/./node_modules/@paper-design/shaders/dist/get-shader-color-from-string.js\");\n/* harmony import */ var _transparent_pixel_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../transparent-pixel.js */ \"(ssr)/./node_modules/@paper-design/shaders-react/dist/transparent-pixel.js\");\n/* harmony import */ var _suspend_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../suspend.js */ \"(ssr)/./node_modules/@paper-design/shaders-react/dist/suspend.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\n\n\n\n\n\nconst defaultPreset = {\n  name: \"Default\",\n  params: {\n    ..._paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.defaultObjectSizing,\n    scale: 0.6,\n    speed: 1,\n    frame: 0,\n    colorBack: \"#AAAAAC\",\n    colorTint: \"#ffffff\",\n    distortion: 0.07,\n    repetition: 2,\n    shiftRed: 0.3,\n    shiftBlue: 0.3,\n    contour: 0.4,\n    softness: 0.1,\n    angle: 70,\n    shape: \"diamond\"\n  }\n};\nconst noirPreset = {\n  name: \"Noir\",\n  params: {\n    ..._paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.defaultObjectSizing,\n    scale: 0.6,\n    speed: 1,\n    frame: 0,\n    colorBack: \"#000000\",\n    colorTint: \"#606060\",\n    softness: 0.45,\n    repetition: 1.5,\n    shiftRed: 0,\n    shiftBlue: 0,\n    distortion: 0,\n    contour: 0,\n    angle: 90,\n    shape: \"diamond\"\n  }\n};\nconst fullScreenPreset = {\n  name: \"Backdrop\",\n  params: {\n    ..._paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.defaultObjectSizing,\n    speed: 1,\n    frame: 0,\n    scale: 1.5,\n    colorBack: \"#AAAAAC\",\n    colorTint: \"#ffffff\",\n    softness: 0.05,\n    repetition: 1.5,\n    shiftRed: 0.3,\n    shiftBlue: 0.3,\n    distortion: 0.1,\n    contour: 0.4,\n    shape: \"none\",\n    angle: 90,\n    worldWidth: 0,\n    worldHeight: 0\n  }\n};\nconst stripesPreset = {\n  name: \"Stripes\",\n  params: {\n    ..._paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.defaultObjectSizing,\n    speed: 1,\n    frame: 0,\n    scale: 0.6,\n    colorBack: \"#000000\",\n    colorTint: \"#2c5d72\",\n    softness: 0.8,\n    repetition: 6,\n    shiftRed: 1,\n    shiftBlue: -1,\n    distortion: 0.4,\n    contour: 0.4,\n    shape: \"circle\",\n    angle: 0\n  }\n};\nconst liquidMetalPresets = [defaultPreset, noirPreset, fullScreenPreset, stripesPreset];\nconst LiquidMetal = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(function LiquidMetalImpl({\n  // Own props\n  colorBack = defaultPreset.params.colorBack,\n  colorTint = defaultPreset.params.colorTint,\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  image = \"\",\n  contour = defaultPreset.params.contour,\n  distortion = defaultPreset.params.distortion,\n  softness = defaultPreset.params.softness,\n  repetition = defaultPreset.params.repetition,\n  shiftRed = defaultPreset.params.shiftRed,\n  shiftBlue = defaultPreset.params.shiftBlue,\n  angle = defaultPreset.params.angle,\n  shape = defaultPreset.params.shape,\n  suspendWhenProcessingImage = false,\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  scale = defaultPreset.params.scale,\n  rotation = defaultPreset.params.rotation,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}) {\n  const imageUrl = typeof image === \"string\" ? image : image.src;\n  const [processedStateImage, setProcessedStateImage] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(_transparent_pixel_js__WEBPACK_IMPORTED_MODULE_3__.transparentPixel);\n  let processedImage;\n  if (suspendWhenProcessingImage && typeof window !== \"undefined\" && imageUrl) {\n    processedImage = (0,_suspend_js__WEBPACK_IMPORTED_MODULE_4__.suspend)(\n      () => (0,_paper_design_shaders__WEBPACK_IMPORTED_MODULE_5__.toProcessedLiquidMetal)(imageUrl).then((result) => URL.createObjectURL(result.pngBlob)),\n      [imageUrl, \"liquid-metal\"]\n    );\n  } else {\n    processedImage = processedStateImage;\n  }\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n    if (suspendWhenProcessingImage) {\n      return;\n    }\n    if (!imageUrl) {\n      setProcessedStateImage(_transparent_pixel_js__WEBPACK_IMPORTED_MODULE_3__.transparentPixel);\n      return;\n    }\n    let url;\n    let current = true;\n    (0,_paper_design_shaders__WEBPACK_IMPORTED_MODULE_5__.toProcessedLiquidMetal)(imageUrl).then((result) => {\n      if (current) {\n        url = URL.createObjectURL(result.pngBlob);\n        setProcessedStateImage(url);\n      }\n    });\n    return () => {\n      current = false;\n    };\n  }, [imageUrl, suspendWhenProcessingImage]);\n  const uniforms = {\n    // Own uniforms\n    u_colorBack: (0,_paper_design_shaders__WEBPACK_IMPORTED_MODULE_6__.getShaderColorFromString)(colorBack),\n    u_colorTint: (0,_paper_design_shaders__WEBPACK_IMPORTED_MODULE_6__.getShaderColorFromString)(colorTint),\n    u_image: processedImage,\n    u_contour: contour,\n    u_distortion: distortion,\n    u_softness: softness,\n    u_repetition: repetition,\n    u_shiftRed: shiftRed,\n    u_shiftBlue: shiftBlue,\n    u_angle: angle,\n    u_isImage: Boolean(image),\n    u_shape: _paper_design_shaders__WEBPACK_IMPORTED_MODULE_5__.LiquidMetalShapes[shape],\n    // Sizing uniforms\n    u_fit: _paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.ShaderFitOptions[fit],\n    u_scale: scale,\n    u_rotation: rotation,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight\n  };\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    _shader_mount_js__WEBPACK_IMPORTED_MODULE_7__.ShaderMount,\n    {\n      ...props,\n      speed,\n      frame,\n      fragmentShader: _paper_design_shaders__WEBPACK_IMPORTED_MODULE_5__.liquidMetalFragmentShader,\n      mipmaps: [\"u_image\"],\n      uniforms\n    }\n  );\n});\n\n//# sourceMappingURL=liquid-metal.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzLXJlYWN0L2Rpc3Qvc2hhZGVycy9saXF1aWQtbWV0YWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFd0Q7QUFDUDtBQVFsQjtBQUM0QjtBQUNuQjtBQUNBO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLE9BQU8sc0VBQW1CO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sc0VBQW1CO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sc0VBQW1CO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLHNFQUFtQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQ0FBSTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esd0RBQXdELCtDQUFRLENBQUMsbUVBQWdCO0FBQ2pGO0FBQ0E7QUFDQSxxQkFBcUIsb0RBQU87QUFDNUIsWUFBWSw2RUFBc0I7QUFDbEM7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsRUFBRSxzREFBZTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtRUFBZ0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDZFQUFzQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGlCQUFpQiwrRUFBd0I7QUFDekMsaUJBQWlCLCtFQUF3QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9FQUFpQjtBQUM5QjtBQUNBLFdBQVcsbUVBQWdCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixzREFBRztBQUM1QixJQUFJLHlEQUFXO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNEVBQXlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQVFDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0BwYXBlci1kZXNpZ24vc2hhZGVycy1yZWFjdC9kaXN0L3NoYWRlcnMvbGlxdWlkLW1ldGFsLmpzP2ViOGQiXSwic291cmNlc0NvbnRlbnQiOlsiLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqICAgICAgICAgICAgICAgICAgICBQYXBlciBTaGFkZXJzICAgICAgICAgICAgICAgICAgICAqXG4gKiAgICAgICBodHRwczovL2dpdGh1Yi5jb20vcGFwZXItZGVzaWduL3NoYWRlcnMgICAgICAgKlxuICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICovXG5cbmltcG9ydCB7IG1lbW8sIHVzZUxheW91dEVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IFNoYWRlck1vdW50IH0gZnJvbSBcIi4uL3NoYWRlci1tb3VudC5qc1wiO1xuaW1wb3J0IHtcbiAgbGlxdWlkTWV0YWxGcmFnbWVudFNoYWRlcixcbiAgU2hhZGVyRml0T3B0aW9ucyxcbiAgZGVmYXVsdE9iamVjdFNpemluZyxcbiAgdG9Qcm9jZXNzZWRMaXF1aWRNZXRhbCxcbiAgZ2V0U2hhZGVyQ29sb3JGcm9tU3RyaW5nLFxuICBMaXF1aWRNZXRhbFNoYXBlc1xufSBmcm9tIFwiQHBhcGVyLWRlc2lnbi9zaGFkZXJzXCI7XG5pbXBvcnQgeyB0cmFuc3BhcmVudFBpeGVsIH0gZnJvbSBcIi4uL3RyYW5zcGFyZW50LXBpeGVsLmpzXCI7XG5pbXBvcnQgeyBzdXNwZW5kIH0gZnJvbSBcIi4uL3N1c3BlbmQuanNcIjtcbmltcG9ydCB7IGpzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuY29uc3QgZGVmYXVsdFByZXNldCA9IHtcbiAgbmFtZTogXCJEZWZhdWx0XCIsXG4gIHBhcmFtczoge1xuICAgIC4uLmRlZmF1bHRPYmplY3RTaXppbmcsXG4gICAgc2NhbGU6IDAuNixcbiAgICBzcGVlZDogMSxcbiAgICBmcmFtZTogMCxcbiAgICBjb2xvckJhY2s6IFwiI0FBQUFBQ1wiLFxuICAgIGNvbG9yVGludDogXCIjZmZmZmZmXCIsXG4gICAgZGlzdG9ydGlvbjogMC4wNyxcbiAgICByZXBldGl0aW9uOiAyLFxuICAgIHNoaWZ0UmVkOiAwLjMsXG4gICAgc2hpZnRCbHVlOiAwLjMsXG4gICAgY29udG91cjogMC40LFxuICAgIHNvZnRuZXNzOiAwLjEsXG4gICAgYW5nbGU6IDcwLFxuICAgIHNoYXBlOiBcImRpYW1vbmRcIlxuICB9XG59O1xuY29uc3Qgbm9pclByZXNldCA9IHtcbiAgbmFtZTogXCJOb2lyXCIsXG4gIHBhcmFtczoge1xuICAgIC4uLmRlZmF1bHRPYmplY3RTaXppbmcsXG4gICAgc2NhbGU6IDAuNixcbiAgICBzcGVlZDogMSxcbiAgICBmcmFtZTogMCxcbiAgICBjb2xvckJhY2s6IFwiIzAwMDAwMFwiLFxuICAgIGNvbG9yVGludDogXCIjNjA2MDYwXCIsXG4gICAgc29mdG5lc3M6IDAuNDUsXG4gICAgcmVwZXRpdGlvbjogMS41LFxuICAgIHNoaWZ0UmVkOiAwLFxuICAgIHNoaWZ0Qmx1ZTogMCxcbiAgICBkaXN0b3J0aW9uOiAwLFxuICAgIGNvbnRvdXI6IDAsXG4gICAgYW5nbGU6IDkwLFxuICAgIHNoYXBlOiBcImRpYW1vbmRcIlxuICB9XG59O1xuY29uc3QgZnVsbFNjcmVlblByZXNldCA9IHtcbiAgbmFtZTogXCJCYWNrZHJvcFwiLFxuICBwYXJhbXM6IHtcbiAgICAuLi5kZWZhdWx0T2JqZWN0U2l6aW5nLFxuICAgIHNwZWVkOiAxLFxuICAgIGZyYW1lOiAwLFxuICAgIHNjYWxlOiAxLjUsXG4gICAgY29sb3JCYWNrOiBcIiNBQUFBQUNcIixcbiAgICBjb2xvclRpbnQ6IFwiI2ZmZmZmZlwiLFxuICAgIHNvZnRuZXNzOiAwLjA1LFxuICAgIHJlcGV0aXRpb246IDEuNSxcbiAgICBzaGlmdFJlZDogMC4zLFxuICAgIHNoaWZ0Qmx1ZTogMC4zLFxuICAgIGRpc3RvcnRpb246IDAuMSxcbiAgICBjb250b3VyOiAwLjQsXG4gICAgc2hhcGU6IFwibm9uZVwiLFxuICAgIGFuZ2xlOiA5MCxcbiAgICB3b3JsZFdpZHRoOiAwLFxuICAgIHdvcmxkSGVpZ2h0OiAwXG4gIH1cbn07XG5jb25zdCBzdHJpcGVzUHJlc2V0ID0ge1xuICBuYW1lOiBcIlN0cmlwZXNcIixcbiAgcGFyYW1zOiB7XG4gICAgLi4uZGVmYXVsdE9iamVjdFNpemluZyxcbiAgICBzcGVlZDogMSxcbiAgICBmcmFtZTogMCxcbiAgICBzY2FsZTogMC42LFxuICAgIGNvbG9yQmFjazogXCIjMDAwMDAwXCIsXG4gICAgY29sb3JUaW50OiBcIiMyYzVkNzJcIixcbiAgICBzb2Z0bmVzczogMC44LFxuICAgIHJlcGV0aXRpb246IDYsXG4gICAgc2hpZnRSZWQ6IDEsXG4gICAgc2hpZnRCbHVlOiAtMSxcbiAgICBkaXN0b3J0aW9uOiAwLjQsXG4gICAgY29udG91cjogMC40LFxuICAgIHNoYXBlOiBcImNpcmNsZVwiLFxuICAgIGFuZ2xlOiAwXG4gIH1cbn07XG5jb25zdCBsaXF1aWRNZXRhbFByZXNldHMgPSBbZGVmYXVsdFByZXNldCwgbm9pclByZXNldCwgZnVsbFNjcmVlblByZXNldCwgc3RyaXBlc1ByZXNldF07XG5jb25zdCBMaXF1aWRNZXRhbCA9IG1lbW8oZnVuY3Rpb24gTGlxdWlkTWV0YWxJbXBsKHtcbiAgLy8gT3duIHByb3BzXG4gIGNvbG9yQmFjayA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLmNvbG9yQmFjayxcbiAgY29sb3JUaW50ID0gZGVmYXVsdFByZXNldC5wYXJhbXMuY29sb3JUaW50LFxuICBzcGVlZCA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLnNwZWVkLFxuICBmcmFtZSA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLmZyYW1lLFxuICBpbWFnZSA9IFwiXCIsXG4gIGNvbnRvdXIgPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5jb250b3VyLFxuICBkaXN0b3J0aW9uID0gZGVmYXVsdFByZXNldC5wYXJhbXMuZGlzdG9ydGlvbixcbiAgc29mdG5lc3MgPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5zb2Z0bmVzcyxcbiAgcmVwZXRpdGlvbiA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLnJlcGV0aXRpb24sXG4gIHNoaWZ0UmVkID0gZGVmYXVsdFByZXNldC5wYXJhbXMuc2hpZnRSZWQsXG4gIHNoaWZ0Qmx1ZSA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLnNoaWZ0Qmx1ZSxcbiAgYW5nbGUgPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5hbmdsZSxcbiAgc2hhcGUgPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5zaGFwZSxcbiAgc3VzcGVuZFdoZW5Qcm9jZXNzaW5nSW1hZ2UgPSBmYWxzZSxcbiAgLy8gU2l6aW5nIHByb3BzXG4gIGZpdCA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLmZpdCxcbiAgc2NhbGUgPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5zY2FsZSxcbiAgcm90YXRpb24gPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5yb3RhdGlvbixcbiAgb3JpZ2luWCA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLm9yaWdpblgsXG4gIG9yaWdpblkgPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5vcmlnaW5ZLFxuICBvZmZzZXRYID0gZGVmYXVsdFByZXNldC5wYXJhbXMub2Zmc2V0WCxcbiAgb2Zmc2V0WSA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLm9mZnNldFksXG4gIHdvcmxkV2lkdGggPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy53b3JsZFdpZHRoLFxuICB3b3JsZEhlaWdodCA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLndvcmxkSGVpZ2h0LFxuICAuLi5wcm9wc1xufSkge1xuICBjb25zdCBpbWFnZVVybCA9IHR5cGVvZiBpbWFnZSA9PT0gXCJzdHJpbmdcIiA/IGltYWdlIDogaW1hZ2Uuc3JjO1xuICBjb25zdCBbcHJvY2Vzc2VkU3RhdGVJbWFnZSwgc2V0UHJvY2Vzc2VkU3RhdGVJbWFnZV0gPSB1c2VTdGF0ZSh0cmFuc3BhcmVudFBpeGVsKTtcbiAgbGV0IHByb2Nlc3NlZEltYWdlO1xuICBpZiAoc3VzcGVuZFdoZW5Qcm9jZXNzaW5nSW1hZ2UgJiYgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpbWFnZVVybCkge1xuICAgIHByb2Nlc3NlZEltYWdlID0gc3VzcGVuZChcbiAgICAgICgpID0+IHRvUHJvY2Vzc2VkTGlxdWlkTWV0YWwoaW1hZ2VVcmwpLnRoZW4oKHJlc3VsdCkgPT4gVVJMLmNyZWF0ZU9iamVjdFVSTChyZXN1bHQucG5nQmxvYikpLFxuICAgICAgW2ltYWdlVXJsLCBcImxpcXVpZC1tZXRhbFwiXVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgcHJvY2Vzc2VkSW1hZ2UgPSBwcm9jZXNzZWRTdGF0ZUltYWdlO1xuICB9XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHN1c3BlbmRXaGVuUHJvY2Vzc2luZ0ltYWdlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghaW1hZ2VVcmwpIHtcbiAgICAgIHNldFByb2Nlc3NlZFN0YXRlSW1hZ2UodHJhbnNwYXJlbnRQaXhlbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCB1cmw7XG4gICAgbGV0IGN1cnJlbnQgPSB0cnVlO1xuICAgIHRvUHJvY2Vzc2VkTGlxdWlkTWV0YWwoaW1hZ2VVcmwpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChyZXN1bHQucG5nQmxvYik7XG4gICAgICAgIHNldFByb2Nlc3NlZFN0YXRlSW1hZ2UodXJsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY3VycmVudCA9IGZhbHNlO1xuICAgIH07XG4gIH0sIFtpbWFnZVVybCwgc3VzcGVuZFdoZW5Qcm9jZXNzaW5nSW1hZ2VdKTtcbiAgY29uc3QgdW5pZm9ybXMgPSB7XG4gICAgLy8gT3duIHVuaWZvcm1zXG4gICAgdV9jb2xvckJhY2s6IGdldFNoYWRlckNvbG9yRnJvbVN0cmluZyhjb2xvckJhY2spLFxuICAgIHVfY29sb3JUaW50OiBnZXRTaGFkZXJDb2xvckZyb21TdHJpbmcoY29sb3JUaW50KSxcbiAgICB1X2ltYWdlOiBwcm9jZXNzZWRJbWFnZSxcbiAgICB1X2NvbnRvdXI6IGNvbnRvdXIsXG4gICAgdV9kaXN0b3J0aW9uOiBkaXN0b3J0aW9uLFxuICAgIHVfc29mdG5lc3M6IHNvZnRuZXNzLFxuICAgIHVfcmVwZXRpdGlvbjogcmVwZXRpdGlvbixcbiAgICB1X3NoaWZ0UmVkOiBzaGlmdFJlZCxcbiAgICB1X3NoaWZ0Qmx1ZTogc2hpZnRCbHVlLFxuICAgIHVfYW5nbGU6IGFuZ2xlLFxuICAgIHVfaXNJbWFnZTogQm9vbGVhbihpbWFnZSksXG4gICAgdV9zaGFwZTogTGlxdWlkTWV0YWxTaGFwZXNbc2hhcGVdLFxuICAgIC8vIFNpemluZyB1bmlmb3Jtc1xuICAgIHVfZml0OiBTaGFkZXJGaXRPcHRpb25zW2ZpdF0sXG4gICAgdV9zY2FsZTogc2NhbGUsXG4gICAgdV9yb3RhdGlvbjogcm90YXRpb24sXG4gICAgdV9vZmZzZXRYOiBvZmZzZXRYLFxuICAgIHVfb2Zmc2V0WTogb2Zmc2V0WSxcbiAgICB1X29yaWdpblg6IG9yaWdpblgsXG4gICAgdV9vcmlnaW5ZOiBvcmlnaW5ZLFxuICAgIHVfd29ybGRXaWR0aDogd29ybGRXaWR0aCxcbiAgICB1X3dvcmxkSGVpZ2h0OiB3b3JsZEhlaWdodFxuICB9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChcbiAgICBTaGFkZXJNb3VudCxcbiAgICB7XG4gICAgICAuLi5wcm9wcyxcbiAgICAgIHNwZWVkLFxuICAgICAgZnJhbWUsXG4gICAgICBmcmFnbWVudFNoYWRlcjogbGlxdWlkTWV0YWxGcmFnbWVudFNoYWRlcixcbiAgICAgIG1pcG1hcHM6IFtcInVfaW1hZ2VcIl0sXG4gICAgICB1bmlmb3Jtc1xuICAgIH1cbiAgKTtcbn0pO1xuZXhwb3J0IHtcbiAgTGlxdWlkTWV0YWwsXG4gIGRlZmF1bHRQcmVzZXQsXG4gIGZ1bGxTY3JlZW5QcmVzZXQsXG4gIGxpcXVpZE1ldGFsUHJlc2V0cyxcbiAgbm9pclByZXNldCxcbiAgc3RyaXBlc1ByZXNldFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpcXVpZC1tZXRhbC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders-react/dist/shaders/liquid-metal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders-react/dist/shaders/pulsing-border.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@paper-design/shaders-react/dist/shaders/pulsing-border.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PulsingBorder: () => (/* binding */ PulsingBorder),\n/* harmony export */   circlePreset: () => (/* binding */ circlePreset),\n/* harmony export */   defaultPreset: () => (/* binding */ defaultPreset),\n/* harmony export */   northernLightsPreset: () => (/* binding */ northernLightsPreset),\n/* harmony export */   pulsingBorderPresets: () => (/* binding */ pulsingBorderPresets),\n/* harmony export */   solidLinePreset: () => (/* binding */ solidLinePreset)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _shader_mount_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../shader-mount.js */ \"(ssr)/./node_modules/@paper-design/shaders-react/dist/shader-mount.js\");\n/* harmony import */ var _color_props_are_equal_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../color-props-are-equal.js */ \"(ssr)/./node_modules/@paper-design/shaders-react/dist/color-props-are-equal.js\");\n/* harmony import */ var _paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @paper-design/shaders */ \"(ssr)/./node_modules/@paper-design/shaders/dist/shader-sizing.js\");\n/* harmony import */ var _paper_design_shaders__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @paper-design/shaders */ \"(ssr)/./node_modules/@paper-design/shaders/dist/get-shader-color-from-string.js\");\n/* harmony import */ var _paper_design_shaders__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @paper-design/shaders */ \"(ssr)/./node_modules/@paper-design/shaders/dist/get-shader-noise-texture.js\");\n/* harmony import */ var _paper_design_shaders__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @paper-design/shaders */ \"(ssr)/./node_modules/@paper-design/shaders/dist/shaders/pulsing-border.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\n\n\n\n\n\nconst defaultPreset = {\n  name: \"Default\",\n  params: {\n    ..._paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.defaultObjectSizing,\n    speed: 1,\n    frame: 0,\n    scale: 0.6,\n    colorBack: \"#000000\",\n    colors: [\"#0dc1fd\", \"#d915ef\", \"#ff3f2ecc\"],\n    roundness: 0.25,\n    thickness: 0.1,\n    margin: 0,\n    marginLeft: 0,\n    marginRight: 0,\n    marginTop: 0,\n    marginBottom: 0,\n    aspectRatio: \"auto\",\n    softness: 0.75,\n    intensity: 0.2,\n    bloom: 0.25,\n    spots: 5,\n    spotSize: 0.5,\n    pulse: 0.25,\n    smoke: 0.3,\n    smokeSize: 0.6\n  }\n};\nconst circlePreset = {\n  name: \"Circle\",\n  params: {\n    ..._paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.defaultObjectSizing,\n    aspectRatio: \"square\",\n    scale: 0.6,\n    speed: 1,\n    frame: 0,\n    colorBack: \"#000000\",\n    colors: [\"#0dc1fd\", \"#d915ef\", \"#ff3f2ecc\"],\n    roundness: 1,\n    margin: 0,\n    marginLeft: 0,\n    marginRight: 0,\n    marginTop: 0,\n    marginBottom: 0,\n    thickness: 0,\n    softness: 0.75,\n    intensity: 0.2,\n    bloom: 0.45,\n    spots: 3,\n    spotSize: 0.4,\n    pulse: 0.5,\n    smoke: 1,\n    smokeSize: 0\n  }\n};\nconst northernLightsPreset = {\n  name: \"Northern lights\",\n  params: {\n    ..._paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.defaultObjectSizing,\n    speed: 0.18,\n    scale: 1.1,\n    frame: 0,\n    colors: [\"#4c4794\", \"#774a7d\", \"#12694a\", \"#0aff78\", \"#4733cc\"],\n    colorBack: \"#0c182c\",\n    roundness: 0,\n    thickness: 1,\n    softness: 1,\n    margin: 0,\n    marginLeft: 0,\n    marginRight: 0,\n    marginTop: 0,\n    marginBottom: 0,\n    aspectRatio: \"auto\",\n    intensity: 0.1,\n    bloom: 0.2,\n    spots: 4,\n    spotSize: 0.25,\n    pulse: 0,\n    smoke: 0.32,\n    smokeSize: 0.5\n  }\n};\nconst solidLinePreset = {\n  name: \"Solid line\",\n  params: {\n    ..._paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.defaultObjectSizing,\n    speed: 1,\n    frame: 0,\n    colors: [\"#81ADEC\"],\n    colorBack: \"#00000000\",\n    roundness: 0,\n    thickness: 0.05,\n    margin: 0,\n    marginLeft: 0,\n    marginRight: 0,\n    marginTop: 0,\n    marginBottom: 0,\n    aspectRatio: \"auto\",\n    softness: 0,\n    intensity: 0,\n    bloom: 0.15,\n    spots: 4,\n    spotSize: 1,\n    pulse: 0,\n    smoke: 0,\n    smokeSize: 0\n  }\n};\nconst pulsingBorderPresets = [\n  defaultPreset,\n  circlePreset,\n  northernLightsPreset,\n  solidLinePreset\n];\nconst PulsingBorder = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(function PulsingBorderImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  colors = defaultPreset.params.colors,\n  colorBack = defaultPreset.params.colorBack,\n  roundness = defaultPreset.params.roundness,\n  thickness = defaultPreset.params.thickness,\n  aspectRatio = defaultPreset.params.aspectRatio,\n  softness = defaultPreset.params.softness,\n  bloom = defaultPreset.params.bloom,\n  intensity = defaultPreset.params.intensity,\n  spots = defaultPreset.params.spots,\n  spotSize = defaultPreset.params.spotSize,\n  pulse = defaultPreset.params.pulse,\n  smoke = defaultPreset.params.smoke,\n  smokeSize = defaultPreset.params.smokeSize,\n  margin,\n  marginLeft = margin ?? defaultPreset.params.marginLeft,\n  marginRight = margin ?? defaultPreset.params.marginRight,\n  marginTop = margin ?? defaultPreset.params.marginTop,\n  marginBottom = margin ?? defaultPreset.params.marginBottom,\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  rotation = defaultPreset.params.rotation,\n  scale = defaultPreset.params.scale,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}) {\n  const uniforms = {\n    // Own uniforms\n    u_colorBack: (0,_paper_design_shaders__WEBPACK_IMPORTED_MODULE_3__.getShaderColorFromString)(colorBack),\n    u_colors: colors.map(_paper_design_shaders__WEBPACK_IMPORTED_MODULE_3__.getShaderColorFromString),\n    u_colorsCount: colors.length,\n    u_roundness: roundness,\n    u_thickness: thickness,\n    u_marginLeft: marginLeft,\n    u_marginRight: marginRight,\n    u_marginTop: marginTop,\n    u_marginBottom: marginBottom,\n    u_aspectRatio: _paper_design_shaders__WEBPACK_IMPORTED_MODULE_4__.PulsingBorderAspectRatios[aspectRatio],\n    u_softness: softness,\n    u_intensity: intensity,\n    u_bloom: bloom,\n    u_spots: spots,\n    u_spotSize: spotSize,\n    u_pulse: pulse,\n    u_smoke: smoke,\n    u_smokeSize: smokeSize,\n    u_noiseTexture: (0,_paper_design_shaders__WEBPACK_IMPORTED_MODULE_5__.getShaderNoiseTexture)(),\n    // Sizing uniforms\n    u_fit: _paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.ShaderFitOptions[fit],\n    u_rotation: rotation,\n    u_scale: scale,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight\n  };\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    _shader_mount_js__WEBPACK_IMPORTED_MODULE_6__.ShaderMount,\n    {\n      ...props,\n      speed,\n      frame,\n      fragmentShader: _paper_design_shaders__WEBPACK_IMPORTED_MODULE_4__.pulsingBorderFragmentShader,\n      uniforms\n    }\n  );\n}, _color_props_are_equal_js__WEBPACK_IMPORTED_MODULE_7__.colorPropsAreEqual);\n\n//# sourceMappingURL=pulsing-border.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzLXJlYWN0L2Rpc3Qvc2hhZGVycy9wdWxzaW5nLWJvcmRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUU2QjtBQUNvQjtBQUNnQjtBQU9sQztBQUNtQztBQUMxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxPQUFPLHNFQUFtQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxzRUFBbUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sc0VBQW1CO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLHNFQUFtQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyQ0FBSTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxpQkFBaUIsK0VBQXdCO0FBQ3pDLHlCQUF5QiwyRUFBd0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNEVBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNEVBQXFCO0FBQ3pDO0FBQ0EsV0FBVyxtRUFBZ0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNEQUFHO0FBQzVCLElBQUkseURBQVc7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw4RUFBMkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFLHlFQUFrQjtBQVFuQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9AcGFwZXItZGVzaWduL3NoYWRlcnMtcmVhY3QvZGlzdC9zaGFkZXJzL3B1bHNpbmctYm9yZGVyLmpzPzEzNGQiXSwic291cmNlc0NvbnRlbnQiOlsiLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqICAgICAgICAgICAgICAgICAgICBQYXBlciBTaGFkZXJzICAgICAgICAgICAgICAgICAgICAqXG4gKiAgICAgICBodHRwczovL2dpdGh1Yi5jb20vcGFwZXItZGVzaWduL3NoYWRlcnMgICAgICAgKlxuICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICovXG5cbmltcG9ydCB7IG1lbW8gfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IFNoYWRlck1vdW50IH0gZnJvbSBcIi4uL3NoYWRlci1tb3VudC5qc1wiO1xuaW1wb3J0IHsgY29sb3JQcm9wc0FyZUVxdWFsIH0gZnJvbSBcIi4uL2NvbG9yLXByb3BzLWFyZS1lcXVhbC5qc1wiO1xuaW1wb3J0IHtcbiAgZGVmYXVsdE9iamVjdFNpemluZyxcbiAgZ2V0U2hhZGVyQ29sb3JGcm9tU3RyaW5nLFxuICBnZXRTaGFkZXJOb2lzZVRleHR1cmUsXG4gIHB1bHNpbmdCb3JkZXJGcmFnbWVudFNoYWRlcixcbiAgU2hhZGVyRml0T3B0aW9uc1xufSBmcm9tIFwiQHBhcGVyLWRlc2lnbi9zaGFkZXJzXCI7XG5pbXBvcnQgeyBQdWxzaW5nQm9yZGVyQXNwZWN0UmF0aW9zIH0gZnJvbSBcIkBwYXBlci1kZXNpZ24vc2hhZGVyc1wiO1xuaW1wb3J0IHsganN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5jb25zdCBkZWZhdWx0UHJlc2V0ID0ge1xuICBuYW1lOiBcIkRlZmF1bHRcIixcbiAgcGFyYW1zOiB7XG4gICAgLi4uZGVmYXVsdE9iamVjdFNpemluZyxcbiAgICBzcGVlZDogMSxcbiAgICBmcmFtZTogMCxcbiAgICBzY2FsZTogMC42LFxuICAgIGNvbG9yQmFjazogXCIjMDAwMDAwXCIsXG4gICAgY29sb3JzOiBbXCIjMGRjMWZkXCIsIFwiI2Q5MTVlZlwiLCBcIiNmZjNmMmVjY1wiXSxcbiAgICByb3VuZG5lc3M6IDAuMjUsXG4gICAgdGhpY2tuZXNzOiAwLjEsXG4gICAgbWFyZ2luOiAwLFxuICAgIG1hcmdpbkxlZnQ6IDAsXG4gICAgbWFyZ2luUmlnaHQ6IDAsXG4gICAgbWFyZ2luVG9wOiAwLFxuICAgIG1hcmdpbkJvdHRvbTogMCxcbiAgICBhc3BlY3RSYXRpbzogXCJhdXRvXCIsXG4gICAgc29mdG5lc3M6IDAuNzUsXG4gICAgaW50ZW5zaXR5OiAwLjIsXG4gICAgYmxvb206IDAuMjUsXG4gICAgc3BvdHM6IDUsXG4gICAgc3BvdFNpemU6IDAuNSxcbiAgICBwdWxzZTogMC4yNSxcbiAgICBzbW9rZTogMC4zLFxuICAgIHNtb2tlU2l6ZTogMC42XG4gIH1cbn07XG5jb25zdCBjaXJjbGVQcmVzZXQgPSB7XG4gIG5hbWU6IFwiQ2lyY2xlXCIsXG4gIHBhcmFtczoge1xuICAgIC4uLmRlZmF1bHRPYmplY3RTaXppbmcsXG4gICAgYXNwZWN0UmF0aW86IFwic3F1YXJlXCIsXG4gICAgc2NhbGU6IDAuNixcbiAgICBzcGVlZDogMSxcbiAgICBmcmFtZTogMCxcbiAgICBjb2xvckJhY2s6IFwiIzAwMDAwMFwiLFxuICAgIGNvbG9yczogW1wiIzBkYzFmZFwiLCBcIiNkOTE1ZWZcIiwgXCIjZmYzZjJlY2NcIl0sXG4gICAgcm91bmRuZXNzOiAxLFxuICAgIG1hcmdpbjogMCxcbiAgICBtYXJnaW5MZWZ0OiAwLFxuICAgIG1hcmdpblJpZ2h0OiAwLFxuICAgIG1hcmdpblRvcDogMCxcbiAgICBtYXJnaW5Cb3R0b206IDAsXG4gICAgdGhpY2tuZXNzOiAwLFxuICAgIHNvZnRuZXNzOiAwLjc1LFxuICAgIGludGVuc2l0eTogMC4yLFxuICAgIGJsb29tOiAwLjQ1LFxuICAgIHNwb3RzOiAzLFxuICAgIHNwb3RTaXplOiAwLjQsXG4gICAgcHVsc2U6IDAuNSxcbiAgICBzbW9rZTogMSxcbiAgICBzbW9rZVNpemU6IDBcbiAgfVxufTtcbmNvbnN0IG5vcnRoZXJuTGlnaHRzUHJlc2V0ID0ge1xuICBuYW1lOiBcIk5vcnRoZXJuIGxpZ2h0c1wiLFxuICBwYXJhbXM6IHtcbiAgICAuLi5kZWZhdWx0T2JqZWN0U2l6aW5nLFxuICAgIHNwZWVkOiAwLjE4LFxuICAgIHNjYWxlOiAxLjEsXG4gICAgZnJhbWU6IDAsXG4gICAgY29sb3JzOiBbXCIjNGM0Nzk0XCIsIFwiIzc3NGE3ZFwiLCBcIiMxMjY5NGFcIiwgXCIjMGFmZjc4XCIsIFwiIzQ3MzNjY1wiXSxcbiAgICBjb2xvckJhY2s6IFwiIzBjMTgyY1wiLFxuICAgIHJvdW5kbmVzczogMCxcbiAgICB0aGlja25lc3M6IDEsXG4gICAgc29mdG5lc3M6IDEsXG4gICAgbWFyZ2luOiAwLFxuICAgIG1hcmdpbkxlZnQ6IDAsXG4gICAgbWFyZ2luUmlnaHQ6IDAsXG4gICAgbWFyZ2luVG9wOiAwLFxuICAgIG1hcmdpbkJvdHRvbTogMCxcbiAgICBhc3BlY3RSYXRpbzogXCJhdXRvXCIsXG4gICAgaW50ZW5zaXR5OiAwLjEsXG4gICAgYmxvb206IDAuMixcbiAgICBzcG90czogNCxcbiAgICBzcG90U2l6ZTogMC4yNSxcbiAgICBwdWxzZTogMCxcbiAgICBzbW9rZTogMC4zMixcbiAgICBzbW9rZVNpemU6IDAuNVxuICB9XG59O1xuY29uc3Qgc29saWRMaW5lUHJlc2V0ID0ge1xuICBuYW1lOiBcIlNvbGlkIGxpbmVcIixcbiAgcGFyYW1zOiB7XG4gICAgLi4uZGVmYXVsdE9iamVjdFNpemluZyxcbiAgICBzcGVlZDogMSxcbiAgICBmcmFtZTogMCxcbiAgICBjb2xvcnM6IFtcIiM4MUFERUNcIl0sXG4gICAgY29sb3JCYWNrOiBcIiMwMDAwMDAwMFwiLFxuICAgIHJvdW5kbmVzczogMCxcbiAgICB0aGlja25lc3M6IDAuMDUsXG4gICAgbWFyZ2luOiAwLFxuICAgIG1hcmdpbkxlZnQ6IDAsXG4gICAgbWFyZ2luUmlnaHQ6IDAsXG4gICAgbWFyZ2luVG9wOiAwLFxuICAgIG1hcmdpbkJvdHRvbTogMCxcbiAgICBhc3BlY3RSYXRpbzogXCJhdXRvXCIsXG4gICAgc29mdG5lc3M6IDAsXG4gICAgaW50ZW5zaXR5OiAwLFxuICAgIGJsb29tOiAwLjE1LFxuICAgIHNwb3RzOiA0LFxuICAgIHNwb3RTaXplOiAxLFxuICAgIHB1bHNlOiAwLFxuICAgIHNtb2tlOiAwLFxuICAgIHNtb2tlU2l6ZTogMFxuICB9XG59O1xuY29uc3QgcHVsc2luZ0JvcmRlclByZXNldHMgPSBbXG4gIGRlZmF1bHRQcmVzZXQsXG4gIGNpcmNsZVByZXNldCxcbiAgbm9ydGhlcm5MaWdodHNQcmVzZXQsXG4gIHNvbGlkTGluZVByZXNldFxuXTtcbmNvbnN0IFB1bHNpbmdCb3JkZXIgPSBtZW1vKGZ1bmN0aW9uIFB1bHNpbmdCb3JkZXJJbXBsKHtcbiAgLy8gT3duIHByb3BzXG4gIHNwZWVkID0gZGVmYXVsdFByZXNldC5wYXJhbXMuc3BlZWQsXG4gIGZyYW1lID0gZGVmYXVsdFByZXNldC5wYXJhbXMuZnJhbWUsXG4gIGNvbG9ycyA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLmNvbG9ycyxcbiAgY29sb3JCYWNrID0gZGVmYXVsdFByZXNldC5wYXJhbXMuY29sb3JCYWNrLFxuICByb3VuZG5lc3MgPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5yb3VuZG5lc3MsXG4gIHRoaWNrbmVzcyA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLnRoaWNrbmVzcyxcbiAgYXNwZWN0UmF0aW8gPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5hc3BlY3RSYXRpbyxcbiAgc29mdG5lc3MgPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5zb2Z0bmVzcyxcbiAgYmxvb20gPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5ibG9vbSxcbiAgaW50ZW5zaXR5ID0gZGVmYXVsdFByZXNldC5wYXJhbXMuaW50ZW5zaXR5LFxuICBzcG90cyA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLnNwb3RzLFxuICBzcG90U2l6ZSA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLnNwb3RTaXplLFxuICBwdWxzZSA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLnB1bHNlLFxuICBzbW9rZSA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLnNtb2tlLFxuICBzbW9rZVNpemUgPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5zbW9rZVNpemUsXG4gIG1hcmdpbixcbiAgbWFyZ2luTGVmdCA9IG1hcmdpbiA/PyBkZWZhdWx0UHJlc2V0LnBhcmFtcy5tYXJnaW5MZWZ0LFxuICBtYXJnaW5SaWdodCA9IG1hcmdpbiA/PyBkZWZhdWx0UHJlc2V0LnBhcmFtcy5tYXJnaW5SaWdodCxcbiAgbWFyZ2luVG9wID0gbWFyZ2luID8/IGRlZmF1bHRQcmVzZXQucGFyYW1zLm1hcmdpblRvcCxcbiAgbWFyZ2luQm90dG9tID0gbWFyZ2luID8/IGRlZmF1bHRQcmVzZXQucGFyYW1zLm1hcmdpbkJvdHRvbSxcbiAgLy8gU2l6aW5nIHByb3BzXG4gIGZpdCA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLmZpdCxcbiAgcm90YXRpb24gPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5yb3RhdGlvbixcbiAgc2NhbGUgPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5zY2FsZSxcbiAgb3JpZ2luWCA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLm9yaWdpblgsXG4gIG9yaWdpblkgPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5vcmlnaW5ZLFxuICBvZmZzZXRYID0gZGVmYXVsdFByZXNldC5wYXJhbXMub2Zmc2V0WCxcbiAgb2Zmc2V0WSA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLm9mZnNldFksXG4gIHdvcmxkV2lkdGggPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy53b3JsZFdpZHRoLFxuICB3b3JsZEhlaWdodCA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLndvcmxkSGVpZ2h0LFxuICAuLi5wcm9wc1xufSkge1xuICBjb25zdCB1bmlmb3JtcyA9IHtcbiAgICAvLyBPd24gdW5pZm9ybXNcbiAgICB1X2NvbG9yQmFjazogZ2V0U2hhZGVyQ29sb3JGcm9tU3RyaW5nKGNvbG9yQmFjayksXG4gICAgdV9jb2xvcnM6IGNvbG9ycy5tYXAoZ2V0U2hhZGVyQ29sb3JGcm9tU3RyaW5nKSxcbiAgICB1X2NvbG9yc0NvdW50OiBjb2xvcnMubGVuZ3RoLFxuICAgIHVfcm91bmRuZXNzOiByb3VuZG5lc3MsXG4gICAgdV90aGlja25lc3M6IHRoaWNrbmVzcyxcbiAgICB1X21hcmdpbkxlZnQ6IG1hcmdpbkxlZnQsXG4gICAgdV9tYXJnaW5SaWdodDogbWFyZ2luUmlnaHQsXG4gICAgdV9tYXJnaW5Ub3A6IG1hcmdpblRvcCxcbiAgICB1X21hcmdpbkJvdHRvbTogbWFyZ2luQm90dG9tLFxuICAgIHVfYXNwZWN0UmF0aW86IFB1bHNpbmdCb3JkZXJBc3BlY3RSYXRpb3NbYXNwZWN0UmF0aW9dLFxuICAgIHVfc29mdG5lc3M6IHNvZnRuZXNzLFxuICAgIHVfaW50ZW5zaXR5OiBpbnRlbnNpdHksXG4gICAgdV9ibG9vbTogYmxvb20sXG4gICAgdV9zcG90czogc3BvdHMsXG4gICAgdV9zcG90U2l6ZTogc3BvdFNpemUsXG4gICAgdV9wdWxzZTogcHVsc2UsXG4gICAgdV9zbW9rZTogc21va2UsXG4gICAgdV9zbW9rZVNpemU6IHNtb2tlU2l6ZSxcbiAgICB1X25vaXNlVGV4dHVyZTogZ2V0U2hhZGVyTm9pc2VUZXh0dXJlKCksXG4gICAgLy8gU2l6aW5nIHVuaWZvcm1zXG4gICAgdV9maXQ6IFNoYWRlckZpdE9wdGlvbnNbZml0XSxcbiAgICB1X3JvdGF0aW9uOiByb3RhdGlvbixcbiAgICB1X3NjYWxlOiBzY2FsZSxcbiAgICB1X29mZnNldFg6IG9mZnNldFgsXG4gICAgdV9vZmZzZXRZOiBvZmZzZXRZLFxuICAgIHVfb3JpZ2luWDogb3JpZ2luWCxcbiAgICB1X29yaWdpblk6IG9yaWdpblksXG4gICAgdV93b3JsZFdpZHRoOiB3b3JsZFdpZHRoLFxuICAgIHVfd29ybGRIZWlnaHQ6IHdvcmxkSGVpZ2h0XG4gIH07XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgIFNoYWRlck1vdW50LFxuICAgIHtcbiAgICAgIC4uLnByb3BzLFxuICAgICAgc3BlZWQsXG4gICAgICBmcmFtZSxcbiAgICAgIGZyYWdtZW50U2hhZGVyOiBwdWxzaW5nQm9yZGVyRnJhZ21lbnRTaGFkZXIsXG4gICAgICB1bmlmb3Jtc1xuICAgIH1cbiAgKTtcbn0sIGNvbG9yUHJvcHNBcmVFcXVhbCk7XG5leHBvcnQge1xuICBQdWxzaW5nQm9yZGVyLFxuICBjaXJjbGVQcmVzZXQsXG4gIGRlZmF1bHRQcmVzZXQsXG4gIG5vcnRoZXJuTGlnaHRzUHJlc2V0LFxuICBwdWxzaW5nQm9yZGVyUHJlc2V0cyxcbiAgc29saWRMaW5lUHJlc2V0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHVsc2luZy1ib3JkZXIuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders-react/dist/shaders/pulsing-border.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders-react/dist/suspend.js":
/*!******************************************************************!*\
  !*** ./node_modules/@paper-design/shaders-react/dist/suspend.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   suspend: () => (/* binding */ suspend)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nconst isPromise = (promise) => typeof promise === \"object\" && typeof promise.then === \"function\";\nconst globalCache = [];\nfunction shallowEqualArrays(arrA, arrB) {\n  if (arrA === arrB) return true;\n  if (!arrA || !arrB) return false;\n  const len = arrA.length;\n  if (arrB.length !== len) return false;\n  for (let i = 0; i < len; i++) if (arrA[i] !== arrB[i]) return false;\n  return true;\n}\nfunction query(fn, keys = null) {\n  if (keys === null) keys = [fn];\n  for (const entry2 of globalCache) {\n    if (shallowEqualArrays(keys, entry2.keys)) {\n      if (Object.prototype.hasOwnProperty.call(entry2, \"error\")) throw entry2.error;\n      if (Object.prototype.hasOwnProperty.call(entry2, \"response\")) {\n        return entry2.response;\n      }\n      throw entry2.promise;\n    }\n  }\n  const entry = {\n    keys,\n    promise: (\n      // Execute the promise\n      (isPromise(fn) ? fn : fn(...keys)).then((response) => {\n        entry.response = response;\n      }).catch((error) => entry.error = error)\n    )\n  };\n  globalCache.push(entry);\n  throw entry.promise;\n}\nconst suspend = (fn, keys) => query(fn, keys);\n\n//# sourceMappingURL=suspend.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzLXJlYWN0L2Rpc3Qvc3VzcGVuZC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9AcGFwZXItZGVzaWduL3NoYWRlcnMtcmVhY3QvZGlzdC9zdXNwZW5kLmpzP2VjYjciXSwic291cmNlc0NvbnRlbnQiOlsiLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqICAgICAgICAgICAgICAgICAgICBQYXBlciBTaGFkZXJzICAgICAgICAgICAgICAgICAgICAqXG4gKiAgICAgICBodHRwczovL2dpdGh1Yi5jb20vcGFwZXItZGVzaWduL3NoYWRlcnMgICAgICAgKlxuICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICovXG5cbmNvbnN0IGlzUHJvbWlzZSA9IChwcm9taXNlKSA9PiB0eXBlb2YgcHJvbWlzZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcHJvbWlzZS50aGVuID09PSBcImZ1bmN0aW9uXCI7XG5jb25zdCBnbG9iYWxDYWNoZSA9IFtdO1xuZnVuY3Rpb24gc2hhbGxvd0VxdWFsQXJyYXlzKGFyckEsIGFyckIpIHtcbiAgaWYgKGFyckEgPT09IGFyckIpIHJldHVybiB0cnVlO1xuICBpZiAoIWFyckEgfHwgIWFyckIpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgbGVuID0gYXJyQS5sZW5ndGg7XG4gIGlmIChhcnJCLmxlbmd0aCAhPT0gbGVuKSByZXR1cm4gZmFsc2U7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIGlmIChhcnJBW2ldICE9PSBhcnJCW2ldKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gcXVlcnkoZm4sIGtleXMgPSBudWxsKSB7XG4gIGlmIChrZXlzID09PSBudWxsKSBrZXlzID0gW2ZuXTtcbiAgZm9yIChjb25zdCBlbnRyeTIgb2YgZ2xvYmFsQ2FjaGUpIHtcbiAgICBpZiAoc2hhbGxvd0VxdWFsQXJyYXlzKGtleXMsIGVudHJ5Mi5rZXlzKSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlbnRyeTIsIFwiZXJyb3JcIikpIHRocm93IGVudHJ5Mi5lcnJvcjtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZW50cnkyLCBcInJlc3BvbnNlXCIpKSB7XG4gICAgICAgIHJldHVybiBlbnRyeTIucmVzcG9uc2U7XG4gICAgICB9XG4gICAgICB0aHJvdyBlbnRyeTIucHJvbWlzZTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZW50cnkgPSB7XG4gICAga2V5cyxcbiAgICBwcm9taXNlOiAoXG4gICAgICAvLyBFeGVjdXRlIHRoZSBwcm9taXNlXG4gICAgICAoaXNQcm9taXNlKGZuKSA/IGZuIDogZm4oLi4ua2V5cykpLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGVudHJ5LnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IGVudHJ5LmVycm9yID0gZXJyb3IpXG4gICAgKVxuICB9O1xuICBnbG9iYWxDYWNoZS5wdXNoKGVudHJ5KTtcbiAgdGhyb3cgZW50cnkucHJvbWlzZTtcbn1cbmNvbnN0IHN1c3BlbmQgPSAoZm4sIGtleXMpID0+IHF1ZXJ5KGZuLCBrZXlzKTtcbmV4cG9ydCB7XG4gIHN1c3BlbmRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdXNwZW5kLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders-react/dist/suspend.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders-react/dist/transparent-pixel.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@paper-design/shaders-react/dist/transparent-pixel.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   transparentPixel: () => (/* binding */ transparentPixel)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nconst transparentPixel = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n\n//# sourceMappingURL=transparent-pixel.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzLXJlYWN0L2Rpc3QvdHJhbnNwYXJlbnQtcGl4ZWwuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QztBQUd2QztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9AcGFwZXItZGVzaWduL3NoYWRlcnMtcmVhY3QvZGlzdC90cmFuc3BhcmVudC1waXhlbC5qcz85N2VlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiAgICAgICAgICAgICAgICAgICAgUGFwZXIgU2hhZGVycyAgICAgICAgICAgICAgICAgICAgKlxuICogICAgICAgaHR0cHM6Ly9naXRodWIuY29tL3BhcGVyLWRlc2lnbi9zaGFkZXJzICAgICAgICpcbiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqL1xuXG5jb25zdCB0cmFuc3BhcmVudFBpeGVsID0gXCJkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUFBQUFDSDVCQUVLQUFFQUxBQUFBQUFCQUFFQUFBSUNUQUVBT3c9PVwiO1xuZXhwb3J0IHtcbiAgdHJhbnNwYXJlbnRQaXhlbFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zcGFyZW50LXBpeGVsLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders-react/dist/transparent-pixel.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders-react/dist/use-merge-refs.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@paper-design/shaders-react/dist/use-merge-refs.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useMergeRefs: () => (/* binding */ useMergeRefs)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\nfunction useMergeRefs(refs) {\n  const cleanupRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(void 0);\n  const refEffect = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((instance) => {\n    const cleanups = refs.map((ref) => {\n      if (ref == null) {\n        return;\n      }\n      if (typeof ref === \"function\") {\n        const refCallback = ref;\n        const refCleanup = refCallback(instance);\n        return typeof refCleanup === \"function\" ? refCleanup : () => {\n          refCallback(null);\n        };\n      }\n      ref.current = instance;\n      return () => {\n        ref.current = null;\n      };\n    });\n    return () => {\n      cleanups.forEach((refCleanup) => refCleanup?.());\n    };\n  }, refs);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (refs.every((ref) => ref == null)) {\n      return null;\n    }\n    return (value) => {\n      if (cleanupRef.current) {\n        cleanupRef.current();\n        cleanupRef.current = void 0;\n      }\n      if (value != null) {\n        cleanupRef.current = refEffect(value);\n      }\n    };\n  }, refs);\n}\n\n//# sourceMappingURL=use-merge-refs.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzLXJlYWN0L2Rpc3QvdXNlLW1lcmdlLXJlZnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0I7QUFDL0I7QUFDQSxxQkFBcUIseUNBQVk7QUFDakMsb0JBQW9CLDhDQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFNBQVMsMENBQWE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBR0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzLXJlYWN0L2Rpc3QvdXNlLW1lcmdlLXJlZnMuanM/MWNiYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuICogICAgICAgICAgICAgICAgICAgIFBhcGVyIFNoYWRlcnMgICAgICAgICAgICAgICAgICAgICpcbiAqICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXBlci1kZXNpZ24vc2hhZGVycyAgICAgICAqXG4gKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKi9cblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiB1c2VNZXJnZVJlZnMocmVmcykge1xuICBjb25zdCBjbGVhbnVwUmVmID0gUmVhY3QudXNlUmVmKHZvaWQgMCk7XG4gIGNvbnN0IHJlZkVmZmVjdCA9IFJlYWN0LnVzZUNhbGxiYWNrKChpbnN0YW5jZSkgPT4ge1xuICAgIGNvbnN0IGNsZWFudXBzID0gcmVmcy5tYXAoKHJlZikgPT4ge1xuICAgICAgaWYgKHJlZiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcmVmID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3QgcmVmQ2FsbGJhY2sgPSByZWY7XG4gICAgICAgIGNvbnN0IHJlZkNsZWFudXAgPSByZWZDYWxsYmFjayhpbnN0YW5jZSk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcmVmQ2xlYW51cCA9PT0gXCJmdW5jdGlvblwiID8gcmVmQ2xlYW51cCA6ICgpID0+IHtcbiAgICAgICAgICByZWZDYWxsYmFjayhudWxsKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJlZi5jdXJyZW50ID0gaW5zdGFuY2U7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjbGVhbnVwcy5mb3JFYWNoKChyZWZDbGVhbnVwKSA9PiByZWZDbGVhbnVwPy4oKSk7XG4gICAgfTtcbiAgfSwgcmVmcyk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAocmVmcy5ldmVyeSgocmVmKSA9PiByZWYgPT0gbnVsbCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKHZhbHVlKSA9PiB7XG4gICAgICBpZiAoY2xlYW51cFJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNsZWFudXBSZWYuY3VycmVudCgpO1xuICAgICAgICBjbGVhbnVwUmVmLmN1cnJlbnQgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBjbGVhbnVwUmVmLmN1cnJlbnQgPSByZWZFZmZlY3QodmFsdWUpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIHJlZnMpO1xufVxuZXhwb3J0IHtcbiAgdXNlTWVyZ2VSZWZzXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLW1lcmdlLXJlZnMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders-react/dist/use-merge-refs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/get-empty-pixel.js":
/*!********************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/get-empty-pixel.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getEmptyPixel: () => (/* binding */ getEmptyPixel)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nfunction getEmptyPixel() {\n  if (typeof window === \"undefined\") {\n    console.warn(\"Paper Shaders: can\\u2019t create an image on the server\");\n    return void 0;\n  }\n  const img = new Image();\n  img.src = emptyPixel;\n  return img;\n}\nconst emptyPixel = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n\n//# sourceMappingURL=get-empty-pixel.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3QvZ2V0LWVtcHR5LXBpeGVsLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFHakM7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3QvZ2V0LWVtcHR5LXBpeGVsLmpzPzc0MTgiXSwic291cmNlc0NvbnRlbnQiOlsiLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqICAgICAgICAgICAgICAgICAgICBQYXBlciBTaGFkZXJzICAgICAgICAgICAgICAgICAgICAqXG4gKiAgICAgICBodHRwczovL2dpdGh1Yi5jb20vcGFwZXItZGVzaWduL3NoYWRlcnMgICAgICAgKlxuICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICovXG5cbmZ1bmN0aW9uIGdldEVtcHR5UGl4ZWwoKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY29uc29sZS53YXJuKFwiUGFwZXIgU2hhZGVyczogY2FuXFx1MjAxOXQgY3JlYXRlIGFuIGltYWdlIG9uIHRoZSBzZXJ2ZXJcIik7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgaW1nLnNyYyA9IGVtcHR5UGl4ZWw7XG4gIHJldHVybiBpbWc7XG59XG5jb25zdCBlbXB0eVBpeGVsID0gXCJkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUFBQUFDSDVCQUVLQUFFQUxBQUFBQUFCQUFFQUFBSUNUQUVBT3c9PVwiO1xuZXhwb3J0IHtcbiAgZ2V0RW1wdHlQaXhlbFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC1lbXB0eS1waXhlbC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/get-empty-pixel.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/get-shader-color-from-string.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/get-shader-color-from-string.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   getShaderColorFromString: () => (/* binding */ getShaderColorFromString)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nfunction getShaderColorFromString(colorString) {\n  if (Array.isArray(colorString)) {\n    if (colorString.length === 4) return colorString;\n    if (colorString.length === 3) return [...colorString, 1];\n    return fallbackColor;\n  }\n  if (typeof colorString !== \"string\") {\n    return fallbackColor;\n  }\n  let r, g, b, a = 1;\n  if (colorString.startsWith(\"#\")) {\n    [r, g, b, a] = hexToRgba(colorString);\n  } else if (colorString.startsWith(\"rgb\")) {\n    [r, g, b, a] = parseRgba(colorString);\n  } else if (colorString.startsWith(\"hsl\")) {\n    [r, g, b, a] = hslaToRgba(parseHsla(colorString));\n  } else {\n    console.error(\"Unsupported color format\", colorString);\n    return fallbackColor;\n  }\n  return [clamp(r, 0, 1), clamp(g, 0, 1), clamp(b, 0, 1), clamp(a, 0, 1)];\n}\nfunction hexToRgba(hex) {\n  hex = hex.replace(/^#/, \"\");\n  if (hex.length === 3) {\n    hex = hex.split(\"\").map((char) => char + char).join(\"\");\n  }\n  if (hex.length === 6) {\n    hex = hex + \"ff\";\n  }\n  const r = parseInt(hex.slice(0, 2), 16) / 255;\n  const g = parseInt(hex.slice(2, 4), 16) / 255;\n  const b = parseInt(hex.slice(4, 6), 16) / 255;\n  const a = parseInt(hex.slice(6, 8), 16) / 255;\n  return [r, g, b, a];\n}\nfunction parseRgba(rgba) {\n  const match = rgba.match(/^rgba?\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*([0-9.]+))?\\s*\\)$/i);\n  if (!match) return [0, 0, 0, 1];\n  return [\n    parseInt(match[1] ?? \"0\") / 255,\n    parseInt(match[2] ?? \"0\") / 255,\n    parseInt(match[3] ?? \"0\") / 255,\n    match[4] === void 0 ? 1 : parseFloat(match[4])\n  ];\n}\nfunction parseHsla(hsla) {\n  const match = hsla.match(/^hsla?\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*(?:,\\s*([0-9.]+))?\\s*\\)$/i);\n  if (!match) return [0, 0, 0, 1];\n  return [\n    parseInt(match[1] ?? \"0\"),\n    parseInt(match[2] ?? \"0\"),\n    parseInt(match[3] ?? \"0\"),\n    match[4] === void 0 ? 1 : parseFloat(match[4])\n  ];\n}\nfunction hslaToRgba(hsla) {\n  const [h, s, l, a] = hsla;\n  const hDecimal = h / 360;\n  const sDecimal = s / 100;\n  const lDecimal = l / 100;\n  let r, g, b;\n  if (s === 0) {\n    r = g = b = lDecimal;\n  } else {\n    const hue2rgb = (p2, q2, t) => {\n      if (t < 0) t += 1;\n      if (t > 1) t -= 1;\n      if (t < 1 / 6) return p2 + (q2 - p2) * 6 * t;\n      if (t < 1 / 2) return q2;\n      if (t < 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t) * 6;\n      return p2;\n    };\n    const q = lDecimal < 0.5 ? lDecimal * (1 + sDecimal) : lDecimal + sDecimal - lDecimal * sDecimal;\n    const p = 2 * lDecimal - q;\n    r = hue2rgb(p, q, hDecimal + 1 / 3);\n    g = hue2rgb(p, q, hDecimal);\n    b = hue2rgb(p, q, hDecimal - 1 / 3);\n  }\n  return [r, g, b, a];\n}\nconst clamp = (n, min, max) => Math.min(Math.max(n, min), max);\nconst fallbackColor = [0, 0, 0, 1];\n\n//# sourceMappingURL=get-shader-color-from-string.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3QvZ2V0LXNoYWRlci1jb2xvci1mcm9tLXN0cmluZy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0BwYXBlci1kZXNpZ24vc2hhZGVycy9kaXN0L2dldC1zaGFkZXItY29sb3ItZnJvbS1zdHJpbmcuanM/OTE2MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuICogICAgICAgICAgICAgICAgICAgIFBhcGVyIFNoYWRlcnMgICAgICAgICAgICAgICAgICAgICpcbiAqICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXBlci1kZXNpZ24vc2hhZGVycyAgICAgICAqXG4gKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKi9cblxuZnVuY3Rpb24gZ2V0U2hhZGVyQ29sb3JGcm9tU3RyaW5nKGNvbG9yU3RyaW5nKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNvbG9yU3RyaW5nKSkge1xuICAgIGlmIChjb2xvclN0cmluZy5sZW5ndGggPT09IDQpIHJldHVybiBjb2xvclN0cmluZztcbiAgICBpZiAoY29sb3JTdHJpbmcubGVuZ3RoID09PSAzKSByZXR1cm4gWy4uLmNvbG9yU3RyaW5nLCAxXTtcbiAgICByZXR1cm4gZmFsbGJhY2tDb2xvcjtcbiAgfVxuICBpZiAodHlwZW9mIGNvbG9yU3RyaW5nICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGZhbGxiYWNrQ29sb3I7XG4gIH1cbiAgbGV0IHIsIGcsIGIsIGEgPSAxO1xuICBpZiAoY29sb3JTdHJpbmcuc3RhcnRzV2l0aChcIiNcIikpIHtcbiAgICBbciwgZywgYiwgYV0gPSBoZXhUb1JnYmEoY29sb3JTdHJpbmcpO1xuICB9IGVsc2UgaWYgKGNvbG9yU3RyaW5nLnN0YXJ0c1dpdGgoXCJyZ2JcIikpIHtcbiAgICBbciwgZywgYiwgYV0gPSBwYXJzZVJnYmEoY29sb3JTdHJpbmcpO1xuICB9IGVsc2UgaWYgKGNvbG9yU3RyaW5nLnN0YXJ0c1dpdGgoXCJoc2xcIikpIHtcbiAgICBbciwgZywgYiwgYV0gPSBoc2xhVG9SZ2JhKHBhcnNlSHNsYShjb2xvclN0cmluZykpO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJVbnN1cHBvcnRlZCBjb2xvciBmb3JtYXRcIiwgY29sb3JTdHJpbmcpO1xuICAgIHJldHVybiBmYWxsYmFja0NvbG9yO1xuICB9XG4gIHJldHVybiBbY2xhbXAociwgMCwgMSksIGNsYW1wKGcsIDAsIDEpLCBjbGFtcChiLCAwLCAxKSwgY2xhbXAoYSwgMCwgMSldO1xufVxuZnVuY3Rpb24gaGV4VG9SZ2JhKGhleCkge1xuICBoZXggPSBoZXgucmVwbGFjZSgvXiMvLCBcIlwiKTtcbiAgaWYgKGhleC5sZW5ndGggPT09IDMpIHtcbiAgICBoZXggPSBoZXguc3BsaXQoXCJcIikubWFwKChjaGFyKSA9PiBjaGFyICsgY2hhcikuam9pbihcIlwiKTtcbiAgfVxuICBpZiAoaGV4Lmxlbmd0aCA9PT0gNikge1xuICAgIGhleCA9IGhleCArIFwiZmZcIjtcbiAgfVxuICBjb25zdCByID0gcGFyc2VJbnQoaGV4LnNsaWNlKDAsIDIpLCAxNikgLyAyNTU7XG4gIGNvbnN0IGcgPSBwYXJzZUludChoZXguc2xpY2UoMiwgNCksIDE2KSAvIDI1NTtcbiAgY29uc3QgYiA9IHBhcnNlSW50KGhleC5zbGljZSg0LCA2KSwgMTYpIC8gMjU1O1xuICBjb25zdCBhID0gcGFyc2VJbnQoaGV4LnNsaWNlKDYsIDgpLCAxNikgLyAyNTU7XG4gIHJldHVybiBbciwgZywgYiwgYV07XG59XG5mdW5jdGlvbiBwYXJzZVJnYmEocmdiYSkge1xuICBjb25zdCBtYXRjaCA9IHJnYmEubWF0Y2goL15yZ2JhP1xccypcXChcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKig/OixcXHMqKFswLTkuXSspKT9cXHMqXFwpJC9pKTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuIFswLCAwLCAwLCAxXTtcbiAgcmV0dXJuIFtcbiAgICBwYXJzZUludChtYXRjaFsxXSA/PyBcIjBcIikgLyAyNTUsXG4gICAgcGFyc2VJbnQobWF0Y2hbMl0gPz8gXCIwXCIpIC8gMjU1LFxuICAgIHBhcnNlSW50KG1hdGNoWzNdID8/IFwiMFwiKSAvIDI1NSxcbiAgICBtYXRjaFs0XSA9PT0gdm9pZCAwID8gMSA6IHBhcnNlRmxvYXQobWF0Y2hbNF0pXG4gIF07XG59XG5mdW5jdGlvbiBwYXJzZUhzbGEoaHNsYSkge1xuICBjb25zdCBtYXRjaCA9IGhzbGEubWF0Y2goL15oc2xhP1xccypcXChcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspJVxccyosXFxzKihcXGQrKSVcXHMqKD86LFxccyooWzAtOS5dKykpP1xccypcXCkkL2kpO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gWzAsIDAsIDAsIDFdO1xuICByZXR1cm4gW1xuICAgIHBhcnNlSW50KG1hdGNoWzFdID8/IFwiMFwiKSxcbiAgICBwYXJzZUludChtYXRjaFsyXSA/PyBcIjBcIiksXG4gICAgcGFyc2VJbnQobWF0Y2hbM10gPz8gXCIwXCIpLFxuICAgIG1hdGNoWzRdID09PSB2b2lkIDAgPyAxIDogcGFyc2VGbG9hdChtYXRjaFs0XSlcbiAgXTtcbn1cbmZ1bmN0aW9uIGhzbGFUb1JnYmEoaHNsYSkge1xuICBjb25zdCBbaCwgcywgbCwgYV0gPSBoc2xhO1xuICBjb25zdCBoRGVjaW1hbCA9IGggLyAzNjA7XG4gIGNvbnN0IHNEZWNpbWFsID0gcyAvIDEwMDtcbiAgY29uc3QgbERlY2ltYWwgPSBsIC8gMTAwO1xuICBsZXQgciwgZywgYjtcbiAgaWYgKHMgPT09IDApIHtcbiAgICByID0gZyA9IGIgPSBsRGVjaW1hbDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBodWUycmdiID0gKHAyLCBxMiwgdCkgPT4ge1xuICAgICAgaWYgKHQgPCAwKSB0ICs9IDE7XG4gICAgICBpZiAodCA+IDEpIHQgLT0gMTtcbiAgICAgIGlmICh0IDwgMSAvIDYpIHJldHVybiBwMiArIChxMiAtIHAyKSAqIDYgKiB0O1xuICAgICAgaWYgKHQgPCAxIC8gMikgcmV0dXJuIHEyO1xuICAgICAgaWYgKHQgPCAyIC8gMykgcmV0dXJuIHAyICsgKHEyIC0gcDIpICogKDIgLyAzIC0gdCkgKiA2O1xuICAgICAgcmV0dXJuIHAyO1xuICAgIH07XG4gICAgY29uc3QgcSA9IGxEZWNpbWFsIDwgMC41ID8gbERlY2ltYWwgKiAoMSArIHNEZWNpbWFsKSA6IGxEZWNpbWFsICsgc0RlY2ltYWwgLSBsRGVjaW1hbCAqIHNEZWNpbWFsO1xuICAgIGNvbnN0IHAgPSAyICogbERlY2ltYWwgLSBxO1xuICAgIHIgPSBodWUycmdiKHAsIHEsIGhEZWNpbWFsICsgMSAvIDMpO1xuICAgIGcgPSBodWUycmdiKHAsIHEsIGhEZWNpbWFsKTtcbiAgICBiID0gaHVlMnJnYihwLCBxLCBoRGVjaW1hbCAtIDEgLyAzKTtcbiAgfVxuICByZXR1cm4gW3IsIGcsIGIsIGFdO1xufVxuY29uc3QgY2xhbXAgPSAobiwgbWluLCBtYXgpID0+IE1hdGgubWluKE1hdGgubWF4KG4sIG1pbiksIG1heCk7XG5jb25zdCBmYWxsYmFja0NvbG9yID0gWzAsIDAsIDAsIDFdO1xuZXhwb3J0IHtcbiAgY2xhbXAsXG4gIGdldFNoYWRlckNvbG9yRnJvbVN0cmluZ1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC1zaGFkZXItY29sb3ItZnJvbS1zdHJpbmcuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/get-shader-color-from-string.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/get-shader-noise-texture.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/get-shader-noise-texture.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getShaderNoiseTexture: () => (/* binding */ getShaderNoiseTexture)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nfunction getShaderNoiseTexture() {\n  if (typeof window === \"undefined\") {\n    return void 0;\n  }\n  const img = new Image();\n  img.src = noiseSrc;\n  return img;\n}\nconst noiseSrc = \"data:image/png;base64,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\";\n\n//# sourceMappingURL=get-shader-noise-texture.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3QvZ2V0LXNoYWRlci1ub2lzZS10ZXh0dXJlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBRy9CO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0BwYXBlci1kZXNpZ24vc2hhZGVycy9kaXN0L2dldC1zaGFkZXItbm9pc2UtdGV4dHVyZS5qcz82N2Q0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiAgICAgICAgICAgICAgICAgICAgUGFwZXIgU2hhZGVycyAgICAgICAgICAgICAgICAgICAgKlxuICogICAgICAgaHR0cHM6Ly9naXRodWIuY29tL3BhcGVyLWRlc2lnbi9zaGFkZXJzICAgICAgICpcbiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqL1xuXG5mdW5jdGlvbiBnZXRTaGFkZXJOb2lzZVRleHR1cmUoKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgaW1nLnNyYyA9IG5vaXNlU3JjO1xuICByZXR1cm4gaW1nO1xufVxuY29uc3Qgbm9pc2VTcmMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBSUFBQUFDQUNBTUFBQUQwNEpINUFBQURBRkJNVkVVQ0FRTUJBZjcvQWdNRC93SUQvLzcrL3dUK0EvNEZBbVlJQXFJS253NysvLzRFQWlzRUFVZ0dCSVlJZXdrRlZoRUpqQW9GQXVFRkE4R1dBdjZUL2d6K0F6RVIvMjV6L3d1MS93MW5BZ2dMLzA0OUJRVUMveTM5QnJja0FRUXAvd3IrQVpZTk92eDlBUWtOL3BFTFV2TUZhQVpUQkFnSVJnc08vN2NKTlFUK1lna0x3UkVMSWY1Ty93bFAvdjc5L3E0SUdBWUxLNCtrQVExdEF2NElkTXBjLzR4Tk1CRjIvbFFOMnZURkF3czlCTGY5LzNrSkpnc01SRjMrSHdrTHhmdjlCVkw4QkhFTi85Z01zZzdjQS8xMy92djlPQXFXQTBzT29mUDlUQXNJZS80RlFxb0Y0US9hQWdzUXduS1FBd2E1QlAwSlcyMU5xZ21ZL2YzWi93a0k3d2hHakFyN29Ba0xyR0dmL0pIOGpnNHpBajRSMFFyK3hROFZadjFZLzhPNi8vd2ZBLzViQVQ3OS9sUTFBR244ZWdrS2RvbTBCZ1lPc2ZqdEJBVkRCb3o5L3pHMEEyMzhQL3RzYlEvK0E5cklpZy9IQ0V0dklnck0vMWx3QldnSWxtcjYyUTVxQTVGbmRuRUlYYStQdGhVTXJxaVJmdzZTQW9kRS8wY1FtNlVPaXJQNXN3dU1DckVPanZvL2RCVlNBLzc5S3ZDZ1NCTDlNMUUvVHdqVWFnL2UvLzJXZFBaMlRROVpNdmZQeFJEN2FQcG1PRnFYU1B1M3B3dzVCL3dSMDB3VGdWZjN5NmRYVzEzN2ZmdjNjN0dOai9pY0pHKzR4dllRNjErK0NaT1ZsbDhwLy91WHpneVRLZzZtLzFMNDd3M2NBWThFSTFUN3h2Z0tia3I3VXNHQkpQTnNCN3hMMnd1dmQ1ejNzdm1EbWdpcGNHVDhqZXo4b1AwUjZiTll1VnBVeFJuOUxaVmtxSWlqWXhLN0svZFpCdGpILzcxWlQvMW15Zno1MmZWbTJXQmZrMHZ4VUZqK1ZmdjkvOXBsYmZ6M3lsNlZVbCtmbGJOaWpycGZwZno1VFpTR1JLQUkxNVgxNHBTdDR2d1FLTUhPVFFsS2lmejFzS1c2QTl1MkE3UjY1d2FwcmZmR2NmZVkvOGl5VXNGaDNybjRsR0VSTVVISm9sdmVBcytQQmRiNWlaRnVYOFM4U0g3RWtmZThMd3kwdDVjTHdzRDNzMlR6YkhYYS80NzhuTHROUTZOdHN0VzE1UXZhS2dyMjVGSm00dnlYd0ZsUEluSVBJZDc5ZFVyNzdmbXIxOEJHZExISVMvbUd4NmRLdzY0TDd2NmszMlhNSnJXbDhFTEEzQzcwQUFBZ0FFbEVRVlI0MmdUQkNUeVVlUU1BNFA5N3pJeDNaakR2SEdhTVlReGpoaG0zM0JHVFk4aDk1c29ka2FOa1hWR2hLR2RVcmkrU0l4UTZuRzM2VlVoUzByblo2dHNWZlIyaWJLbHRhNy9kNXdIN2tNYVR4bE9Wb3pFb0hnVTI5L2F5TkM5WWxyWmR5VlQrTGYvZEFzRERjL3hmelgrTUxCYTJMSzIzZ29LMGFYaEN4WjhxSUFkWFlqK2M4enZpRE90UmtoRXRSeE5hakhXTHVDdGRjZlFxVjJtZ1JscERENndKcEtwQnJHT04yN3FhNG5OZVFPVThWaVUwcFoyZUNNTjVtV083YmZSMTdROUl0cHNxZ1pKTkpjSlNxNmNTV2lWNHExeklETW1rcXpBZHBxVDhnSTVHM3FtM1lFeWxpUFBHOWtpd0Y3UDk5Z2hObjd6THM5RVhGdkZkTG1sT2RLQkFwMlp5R1RjSTRKdUJQWXJXeUdDWXdnRndPaFRtSGVZQzB6RURTcDFpWDNXNzFjcW9XMzMyTSsrT0FZSlVyRXlTVlgwYzVsem1EZ0xjQVExeUZWVk9nUTVsK2oxazZURUJpZFRVZWs3T0Y0VDJrRFlvMmVWR3dPcmdsS3lHQlhZeUJyeEZ2OXB0UjE2QitCSjBJRkNzcnlKdmUwWkV1ek5qTGVFY3cvMGFLL2t5a3U2SlcwQmlpY25DQkZwdEtBUVJSTlJydG1VVi9ZT242R05NSFhkZHNGZjFZWkNITW5GV2djeXAyZ25MT1dUVEJjVlFWdk0vRlRnSkFIbDBOV0hIekwwZXF6dVJYVERDRU8wM0RvVGhWM2tlemhydHBOcUtXMEJiM01TU0FKTW1tVm5MRXBleFM4SnJtWU9yNEtYejFjVW1CeXR5M04vc2JFekJTUDh0ZkdTQ0ozY2FZRGh5bXNQZEdid080SEFsLytQWURDWk5mK0g2a29ma05rNE40Wm42Tk00eTFsSkQ3VHQyZ3lrbG5yUjQ4ZGdiZkhYZ2Q5dXpIdnBhbW0zd0toY2FMY2F3WFd4TDVUOTdkTDdNZVczYVo3TkRXa3NWWnladjhWUXlqbTk0Q0RVN1VqdGJlZHFPQ3ZCMkRkRSt3RkM2YTVKY0VJZ2tLUko4Y2ZUR21XLzJqTVM1TEVXV0tpR1kwQkZhRE5RKysyK3NPaWZQTVE3Q2NIZUZ4K1BQcGNielJveTRJS21Wd0hnLzE4NDJCd29HYzJxbFJWb05qQ0Y1OW9Yc3JjQmdWRVA0dTFHSVg3anNoSU1xcVBkYkdUUkp6TVhjeXl5aU5HNWZyNXFGclVWbnRya3R0NFFkSnVna3Ixa3pOSkNLMXJvV3BUcmFpeDlKVk1wWmNzeEdZc0psR2lTeUVnT0Zaekh5NllWbGlsbmljbXhVVmtkWC9QZXR6TUJrOTJQTkpOa0lhTGhtQTMwWFBDck11bmNXeE9aSzlrcExucXBZT09zTEZGbWFmMk1rOE9IK0Jid1BIN0hCWDJLR0kwTnM4MGdsZUgrWTZrMFlaY0Ywc1dncG9KQTMwQkJiRzU5WGFLeUJIb3hGdGMycDlzRnZ5WHFvMnYyYVJLTisxSExQc2hDaWJmWkVTQUVTWXNMWG16M3RUNHdOTXAwV2FsaStWUE45M0pJSmFRMEFjWEdyTk1uU1MwWUFTUGNhTmgzMk5oTzBzV0hLUGhyTlZwQ0J6eWs0RVdSL1BubUtFKzNzMmNETytZRjZPZGRQTng3RzRBSXJaQlBsZHc2dGNzczRicXpiNmhCeTZjY2YzWWFCU05SQkZFTHVlUkZwN0RYV05NRlZBVDlKMUxOVG50RXlFSTJnSlM2NG95S01LdlNScmJwUFFHRTByRUVtSHlxQ2wyb1FyYXZxNTFGd0pYRzBtL3BQZFJBNlhwM3NTTGR3R3dOeXRhTGczZzNWRUUyZUZFU3kvR2lqUVB3bVlQandKVCtiSC9heDBkTlQwTlpBRlF4eUlxS3pFVDAwdlVEdUorVDI1UUdDY2xhR1ppSkJ4c2p0ejNZTVowUFBzcTc1MWgwbGR3YlpzdE1nSGZuYXVrLzduMWVaeEVtWUlQZjV3UHQwS0p2ZzJWOWJjWVdHZ3VhL0x2bi94RzVxOTh0UExjR3pIYWFjMitDYnMzbml5UHRHZ2ZZZ0JUMk9IZ3h2aEd4ekFwb1B4UG9DT3RVTkNYWCtvalcwdWc3RE91eXJPT0c1R2tXaGFBeng2WnlHRThxYkNQUzFveHpQamNXU3JHL0lDTmFOTUtzcmE4YklsUVZ2bVJRL0ZZNFdpSGhuclZ6L1ZmZE9pT3U2dTY2Z0czTktvZ0ovMHJHZGJDK2lQTjFwYlo0SFFBWk9EUyttQzJ6OWROQnFTemQ2bVRRV0txK0VJM2ZYZ0pRZHFmcXo2alk2RmJzNHNXVC9Ra2FMVU9Cbk1oV1JtU2RycFR5NzY5QmNDcWwxVU9tYXF0RmJEQTlkN3FFb3g4THBhK1RQWFgreG00MGpyQjdFQksxbHd1NklNdWQ5eGg3TkJaQ2JxNlBOTi9RZFR1MEJWYTJuZUYrczhiMWRHbnM1dE1HeFFJUC8rZmlZNjBqWk5wOW41RDlNTG00TkxXTzJnWFZHNHh3RFhIZUhYTUZFQUlUT1ZVR0pSb0JVd09WM21paVRFUFB6THJ3RG03NHpGc1c5emtmQ0FTUXZQaTJSYUY5cUoySEhXTUpOeENIekR5bTZ0TmZYaUVlMjhabmptSFZHd2xTdmZnQm80YWZxY29UaDROTnE3UVExS3JQSlcrMXVIRUsxVnZUZ2hHYTBEQWVQbzhENkQxTkNZZ0VQWTIzOUQvUlFTVU14V0pzQUlpNUtFcC8zLzlMSDF3U1R3bDgvbWZla3dXeUloQXdNUEVyeld4VlNMN3NGbkZUMU5xSitaYjhoWDRjcXd5dWNYZFVWa2FxTmVWTDdhYk50SlYrK2FBU24vZCtGdzlxbFZ3cGx6NFNxcFZ3NUNCSzducTQ4M254Ylo4cC84VHRGd3I4b0Q1dWhxK2x4Zm92ZDB4NCtNSG8xV3YxNFNKenFCbzlVbjFLQ1o4TldmYkE3akxlb01qbkNjUzhianRLdXhpaTArMFJQWmxMUzZOZGhOS0hlTjJOU2RDc3dhK0srYUdGVVREOU1MVzlSN21oUFQ1aTg4VFp2VjVyV3R1ZWswN1cvdkJldjllSnpuUEdrTThGckNaNTNBQjgrSWc3dkttczk5eVJiNWZweW9Rc3NpalR3ejBpMjJPK0h2anNqeUdYcHFzZWI0dDRqNllXODZQZkpGMmNuam15OEVLVkY4c0lvbUdVZFZHQnF1T0lESWxIc3JnUGtKRXp3N0tvdnFIQi9rUytOUGdzOW5HOUZrRzFNSmlBMEdOd1R5ajVkUlMwdWlXVGZTTGY3anBMMGlvTEV4YWpML09KUGtVYkE2Q0lkS2pwVTZYclNZLzZtRTVaMUlEQm9IWDd0R3g5ZkZrSlpRUHJQSVc0OXBqOW9VRXlra2lvbHphZWluOG1CaC9DLzBlQXpZb0ZYSFdKeFlaV3J2L2F5UG1jV3NqZld5RHk4bmRubVBUbGRjSjA1TWF4T29JSFdQY05EMlNPYW40NFdjMU94eWs1OUtIYmlYd2JyeEIzcXZBRUErUGQzemMzTWtERm14akczSzRaeGpISGZGWEtOSTY5MWt5UkxqbVJDVW1UUVduUW82WFM4Sk5GQnNUa3FpUlFwaWphbHJhVGUxVlBicGExMzk0LzRQTStuYVVJbDVqYjlPUXc0dFhIc0Z5QW9EL3g4dm1sWUp1MjNoZm93Y1RuSk9YU01VZEt1bTRJcUtVZDRISmd1UmlwcmQvRXR3OUsvTkorVUtFK1QydjM5bXMySlJHaHRORHhTaHc2a21aRWRzcjZmd1ZTelpVQ2dqL3hLOENhRDQ2TU1xanRWbUVFMERUUFM3eW83c280MDJsa0FBcjVBOVRBOFliYXBZTys0dExISyt1QkFxQ3Nkcm1rTkIvdFNOUXhnclpSaUJqaFZTdDkwNFRRYkJtRURXMzZVaFpFd1pOOVRiV2gxdnRyTFZZZGtRS2F5Skhnak81YVZmdHlhT2hidElWRmpxMGdJbVdjRkpiWHFQcCthR1RhT3pIelBwdHZXYmxpL3RFejVCSHMyV2RVNHkwMXNPV0lkRytDUFdieFNEblEvS2JZZ2RkRzFnZ3RQUFVGdlhlTGROSDJFb3NsQXZlSmw4R1VWYUxzNldXc29vM0cyUThLbnZTa3JOVjEzckptNGZGMmpHMk5LRTNGTWdqV1B5Q3lWVlpYRHhrMFdLUXl6SWNkR3Zob3ZmWHd2UzIzN1daTjNQdlg5RGg1MFYxQ011ZW1jNUFrUFdCSnp6bGc4Z2lxei9NM21JQ0Jhak5zTzNQU3VCeXczelY1MWdDVHliSGxmdS9SK3pYd1Zla2h6TjFDMGdaQ2dxYzN4OEVVUjVNdDhMbmRQUnYzQWJMbmYyWk1MSjJUWkJhcHRoWThoU3NJRVQ1L3ZwSDFUNy9sMUlLWmw0cFRwMmVNVkZUOEorMUp5RWxuaXpNMzJHbUJRVGFUREpPd3V2UENWM1FEb25ELzZ4andnUjZTQTkyTUYrditYbG8vQkR5T1pKcGtNN1FGaDczdUt4elg5aGxEb2wveDVIVkVTeVBNL0hOeUY2TXdDZzg2NlVXWG05SmQyeHNqclh5RUtnamwxMUs0MW5Fd3pGemp5UDBWOVQ4N2RTdEF1c3RCL01rT3dCYVFvT0NORzArNmRmU3cyWUlMMmQrYUFGYnRld29QSUFUV0pDKzZpbDJuREZEeDhWbHhnMmEyMm9aRzRNeTQ4Z25yUUVjRHhPdUU3MXd6NTFta2Z2QzNCOGdqRjA0YmFOUnBnNlNHb0hJQWMrekIyUXFxbjl5RXpDWGZwbXBkTjJreGRraU1RL1cvWDdpVC9SemtwQkd2bEdyeDJCczRwbDNzOEFrbDNtUlRzdWJrM3grQ1FINDdyMVpOZ0VDemY3SVAwblY4bFJVajFYcXNXOSt3TkkwK29BeC9sT0dWc0hjbWFscWRBcVQvUmIrcnAzd3RoRVB4alhJNmlyeGhUWmM5VTIwT0hTYllBSkNYNk1LSFlXL1A4WFJseWFtN0tIZms1VlR1OFRtZWJkODg5Tm1RN2hpdVBiNmJRdThpbk0vRk9Ya083aUVXZDloZ3lCVkVFclIrOFArT20ybEZjWEdwOERHZTczNExIZlMyUGs3L3B6U3dQdmRya2Q3L05nVm8wVjhzNWlyNE5ZTUUwQ3pHYk9Wb2l5Z1FLaCt2ZXhCTjVQa1VCYTFiWUluS2hGcUJpN2YzRlA5eGR5NXdtSDVCeUVMNlltbHNONEgrbHZRSkJHOFRTdndCbWhjR1VhZlY5dVBsSVlsa3g3UzgxWXVHK3J6ZkMzRWIwN1BHTFNudktPMXVqbGtpR01vbGlXa1lKNlhZcEh6aFA0ejVvZGVJbVpxS3haVDFoRk4rYXJQejVEdzJlMDBPRFhzQkNHcmY0akIrNDVaVDdVck43VkJSVVlnclVKeDBXa3hOeU1DU3hSQ0lZd2d5cXhQOFp2OVZDKzZhaVVnQjBlSXQwOFlJMGZoMlpGUnFTaWxVdVJSdm10NWplamRvU0NqZmFSRlNjYTZSWGg5a1ZBalgvT2VDOEZiZ2RvK0ZmeDlLMHpGOHA0c0xFazI3a0cydldOVGhMODJNL2gxQlNjSTJLcjhmT0trWWRoK1dYeEFZVlBoc0QxMXN4NVNESUV5eDVDR3dFMWNRM29zZFlkbEVQMy9BWlB3dkg4b2MxV2RxWFUvT002ZmRQRUx0WTlKUlNOSEVlcG1DM1pXZ3NMWnNzMkgycXdxMDB4eEE4MVNBZXhWZHdiTDFla3RRbEplVk1aQUdPYklNWExLNWxrYjk1ZGhqTXprYy9McTE3aWlBUGExdUFvdmZJWlpMZS9rYU56UkNVQ3IzOWdqTjVZVzE4RHdCRUtkUWtWcmlhSmM1QktFSGk1czNERU11a1FJZTliU3RYREh5Y2lKMFh2ODRGU2diNk9XNld1aEZxdHlqZGpXVHcvanQ4N01ucHF6QzlMVFA1ZDZ2cWhNbzNZNHU2ZHdmTkF6TCsrNmFoMEc4YWhsdGxjV2laUGVHdGNHMTA0VUo2N2Y0UU13T3FxL2pNSUZ3OGxlUTlWc2JPaHVPdGpZcXg5Y1hJYWlCY25nM2Z1ZUFRUEl6N2hsK05KMmx0V0FFQ1FJeWw4MUxBYVJ3bGJFQ1V5dXV4dEgvaS9uYjI1a0ZpbElzZG05cTBxeklWeGJPMi9keUJQd3NPZHdJL0ExTkloWGN0SWdERGZLQ01PTEloRUhYRTBUWWlEUkRFTWt6V3RROWFCYk8zV1JJaFRkSThNR3BQaCt4RTNTRXZaTTNUc2FTa1N3bzhhSXA3dmNCUFNwTklVV2M5ZHgyaWhHSVVmY0NNQTZoNkgwc2d6bFlvMkx6d3pzU0JHL3ZQTFVLQlJBSURDbE5vMmh5bEpNUE5IVUY2L0Z5Q2k3dnNQcFVCVTVmMVpyeWNvLzlkeXFlSUVZemR6Ukw0ZmhScXlEVFcxbHYwamxRanVCdGZhVWFLQlBJN0hyL0c3UmNhd0tXZDh4eXRDQ0hxMHRHckFCRmxMZit0Rm5YdmNGUlVTOVNkc2FVK0RPSTY3eXk0N0tpUzg2eVZIbmtidmJuaHc3UjUrUU1YNmVmUTB1ZU9WZFZrS1o1byswR3pSWVBjNzJXWG5aMjIwL0VFUHZRMm1Kczl1bWNjdmFKOUpRRGxXdWprV2RIK2JDdU9sNk9CcmlQd3R0LzZENTdhb2ZJSHkwSlZicmFXUlpEbzd4aVVlVGhGNEpMK0FQanVyNGZ0ckJET29EYk1tSkdHUnZubDBpdjcxWVBnY1BnTVNhOFBUMVp2RmtSZ3gzelBNNkJGZmYwZFRKYlJOSUhOZDkyaGxRVFR1WU5WZDJXNlB1N015eCtOZ1ZPaUZQZWloN2FISGMvRG4ydFZ0UElRWlRMV2hyMUJTVkp6TnBabzcydXpvRFFXMUQ2S0c3YUNQeisxOTNGZE14RnRaL2hZRThpZEpxZnNxN2pIbzZVU25UZXA1dHA4RDRMV3RTUHFJSlM5K1U0Y2M4WW04bEo5NHd1djh1ajVEbElzZmxodEl0SlVvZU5oQW5rZEVtVU1Jc0xiR3Q2dGhqYXc1c3VMR0l3WGc5NmFJSTh0dHJpZ3BjS3BjZG1xbU9lZ0xyYWo1aDhBQVFqKzkwekYzWWhxc2NFTFRBRmFXWnVVQVFNVGhZaVViL0ZOSEFsRFV0dGRiUUF5UDBpQ213dkJsWGozYnd3R2tFWnhoN1k4ZlkxVEIrVVVkVmZqRFhLQWFvTFlhV0dXQ21Wenp4UXhVUUs3d1NGcTdidE55amNtS3gydlhnS05Tb2NESTNXMHEzZ2FjQUJvU1QxWWZPME5DME9aM1ZKMlBVQXdYSWNzT2o3Zko2R0dHdzNoa1QwR0FNT0lBU1V1SEdCMU5JMkJOQUF1aFF0RmoydlQ0RldPQndBOEFaUUNKUXc4ditmUFlxOTdHOHRGTm5nLzdJZWcreThLSEFjSTV3QUNrUU9VTUJHOWJnVXNpWU5HelBIcWdwV29uUnc4Rnp3N2FERm9ydzRvR1VrU3ZRUTRIMThldjJzSGhFVmMrYU1DQXlrRkZoOExtR0tRVkpLaElsT2RBTG1rQUtJREJrZjV0eG9DeHdLZFVBejBUb1dPSmFVR0FlbmVBM3BPandGeVp3QXBPN1YzYWtwd2prbDhveU9Gb1FxRWpZZlVDMGNCSFZDb0F6dU1NSDQyRWdnQktTSnF4aHNRV3dCRXUxZG9CcVFLQWt0bmJ6TXp3VFNjazh3NHlQWndHalllS2lBakR4U0hJejBIRTNFakhBVU9BazVSTFhRSHFJc09yeXNxVUFITThCbUdaUlZOdzZNaTFRT2VBUVJhTExBQkFCSWtRQU0weUFCVGJZQ3hZQUMrSFdCSjAweGROMHIzWVpVN3ViYmpBaTBDcmpGSHhMTXphTkVqRkx6KzRTY1N0Q2c0cjM1OGE1a2JBdGlmYmFIY1RZMThxVnJNSWRFRUlTZGFuSGdXRmRrQm5NOC9TRWtUS2ZvSGFTMWFOVG1adk53QWZsc3FxZ1pMQWpCWHlBTUZ5cklwYkFWR1Y2b0FLckNjUHFBcjQ1S1lTL3NmaTltT2JHaVNsQjBEK3dBTGNrT09DR09yaURLODN5d05meFVmVHc1dEh6d0RHaUphSjRTVTlob2xGNWZ4M1g2cVpoc1JBUWVOalQ4RS9rdkhJS3ZVWTFzQVVaQWVhNE9ubGo5c0U2OEVvRVVCNDU4SExDRG1BQjhNSXc2SlNpUUFONzNTUExFT2ZHVTMxS01ZRVlyVG91c21peVJ0QlRRN0NsYVQzQU5QNnVGWUtMODRhaHNJUDZzc29nQUFLMmtzK0FZRVNnQjZWM1VZQXlwR1dnS1ZxbmdDbHd3SjRNTWltOWZxQ0FISldoMFU1RFE3T1ZBZFNrOGR0ZE9NRENyTmtnU0JvL2MwcXlJdUJERUZia2gwU1VIeEUrNDdHUUVvMHNnYTRZRDZ6ZXNEa2dBWHdqS3pMQXJWU2hpeUZGV1NZWGtTM2lTbE5Rc0JVYjRrQVFLVUVTTnY0YkZMQ01vQnRmeEpBQUFBQ3NtRXBXNFBqSU0wRERLMlpicFptQkN6NkZvWkJnWHNidG5MS2FiOUVBeGdBVm1TZVVpbUJnaWhwOEl2TVNmV0F3VHl6MkFFMEloRUp4VnptbXJ3TlQwUG5jb0NHUVhRdFh3dWE1MHhrM3VQREkxRGZxS0hka2xUQlZZQWlvR2NJbnUvQ0dJWDFHY3JrRTFjVEFIUUh4QkFwclkySWIvQXhUNFdCeFp2ZVFBZDVDd0JRc2FNUGdrZG1nWWJWUXBxQ1c2SkFQMjlCbUZRRFcrYURBTXVYQ012ZlQ5V3JHWG4wMGNtYWFhWFp2Z0RPVi80bndYUUtnZlRpRW1pc0M2ZWVtQkNNcnBmaUVscG5IUmVmM2F1QmlWRUEwcUxXZUZMRUFVQkJhNUJDYmxxbVFWL0NnQVoxVUVGUzJFZ0N2cHl1QU1wR3ljOUJWb29ac0NCQURtSW9BQ1hrYm9EQUV3R05ObW5BQmV2QVFjR05oY2VJVkZEdXgzdVdJSUVQUUFzanI1bDFnOENsUXBNQXdKc09Wc09GaTBVdnE0Y0RsOFBFVmwwQUFkYUM2bUZhVlFpRE5lZUE5RUN2NDdocFRaN1FrMVZSUndiZFJheDh2RlhyeVRpWW9sQUl3cHJCbFowcGErS0tsNXdCVTFsUVJNQ2pGSXcwbDBZZFhZREM2aTlNZ0RVQzZrcDMrQTQ4ZkxIODZoQkRRSUxMUUJoWko1aFd3SW5tM1FJSGdZWkVXdmJWNzB4V3FvRkxBUEVSRExLNEhNNS9jV1ZLYlg4YkFNRUU3by9BbTJhdWU1WkY2T2NMcXF2VnU4RUM2ZjhhSmJZQlpPV1hXNXhLeUJBTkVxakE2QXNreUlvQWY1TUJRR25LQnBvUFRBQlIrMC9vRlVIQVUxVkFLc09xVjVOWWdCQkh3WlpoMXJVbmN3RENwN3NTV3dEUVRZS0JRZHBDem1Jck1nTk41UURFYkV2VzJRRmdtbWtLRk9uczBXRFFhbVdMUEhETlZHVG5pSWZSUTVIcWZLc2c4VXVlL0VSOHBaSGQrZWJVU09tN0tnRjYzV2lUSWhyV2c2b0pZZ0VNWWMwTGhXRUxUdm5jWGRjZ1NjQzNTK0JucmpMWVlzWksxUFhRNEdKWnVnQ3VRQUNsR25jakdjTUNKd0dNSHg4YzdtUndvVkNRQU1KUFFPL01RQmJjczY4WnoybERRZ3MvUjg1UFZ2UEF6Ukp3R2tDN01ZSUYvVURCUm9IZDFHaHdZdUFFb1hETzZzRnFJSVVyM3dPSEdtWkZLMXpIMTFCaDhpR0ZXYzhIZ0VvUXdYdlFSeEhKREVVQlRGL0FwbEVmV1VtV1NNSnBpRVV2QWNnaGxGR0VRdEVUd0EvQnhRQWVEQkJ0MUlZS2E0Y0FEbzZXcFV1QUFNZzB3NERCcm9CMWhnVGlBSi9STjlSRVgwcWNJTTNGYjdiMkFFRW0rbU9hd0lFWGdGZzFuZThCeUU2ZnZNS1ZwSTNJamRzQVFFVEJpV1VtalpHRFFoalFURjhGZ2xkQWdOUk5pQUNNMTZrQ0JYaGtXb1VwKzRTUCtoRUVnaEw5azl3WmpsbWM2c2NUNmNVcUFBU2o1VTVhVEFiQXdPRWwzSUNDRzI1SlI0ZmZzRUtZZlVOS0lrb1kyVU1jQWtYRHFFaHJHUTJiMlJycWFYakF4ODFDQVVXZVhWckFJNG1HRG02Ylh0b0F3WVZNaTRHU2s1UFVWdGNsc2NIOGdJaHZYUTlVaVVBMXVuUUgzZ0hCd2t3cS81U1JBYVVEMEdZYkUwUUwyTUFpUWJ6bGFzdUd4Y1lBd0UwdmhtdmZnQWUzQ1cvOUJRZkFpWjhUbnh4NUNPTTNCUnRmNlUrSy90cFlBK2xKUU8rTFFQdGVXNFdtQ0hSWXlDUUFMY3BXQUlYOHcwUzVDUVBJMXNlTUJtQ2NFQWVnY3pDYi84RkpwQ3piQVdEM0g1Tm9yTWFNRU5YYmN5TStTcW56TWExS0FBOUtSRVNVUUIrQzVtYmhxRmU1bFZZaFJ0Q0dBSy9hN0F4Y1JJZ3UyTzBQd0R1TGl4alVWaWFFZ3ozRkEwenFEY2kydEJSQ1NBUlBnUkJNL05rR1JsWmVDRm5IbEVpeWFRcmdJZ1F5bDY2UkVjWE5Kc2xWendpbWx5QU5DT0tmcmhDbEV5S09kRkw3aGlpYk1sRkJRUWcxamFMUEFBRENQejNCRlhiUnNiRTErb2lUVGtLQ2w4WG52Uk1RYlViUlVncVIrSUNTdy9sSm5BQ3gza0lBaGFJZkI4Vy9CbmtBR280TW9QQVlFRUE3UlRuQjVTZzNSaW5WblFSQlFZUzh3UitDYVl6WFQwN0JkWU1EczhHdTQ0QUJ0VUxJeUpIRGw5d2VqSUVBR282amcwVm9DcEVPSTAvWWV3ekNnSXpjRW1HWURZOCtyaHRSZkV5WlFibFN3VWVEU0kvWDdzRmhQTThGUWJjNG5DcUtlMEJ0RUlrZVZxSmNzY3lhanhZT1VmcHlrMkFORFlmQU9tWkQ2ekpUUlNCRHBnTC9ONXduVXF5Q2xLY1lCMDVNSTFVQm9vQUxDdlVodUFjeWY5c0ppdjhHeUpSelgvSVFRQ3lDM1pCU3p3Y085c1hCNEFJbFJFMnZoMEhCcGNGNWdyc0FRUG5xQUE3b2JjQUxpbGRpWjkyVE0yMjRiZE1tQXdQUUlOV3JQZCtSQ2dISnhnRGZ3TXYwWUtSbEVCSEpucHhrSnl0RFhYcEFOVXRJRWRXV21VU0JBY0pDU1BrWlowR0V5OE1ES29mNzJjZGgrb1RRanFhTEgwTWNTbURhM2NRbko2bFEwTi8rYWl0TEdhYkl3Z3JFekN2bW1wL280OXA1VjBHTmxSTFBSYnUyVWVoSTMxb2E4cmdDUWhFQjZtWXVacFUwS01DQTJVUkJXNDdMNEVGQ0VFZ0Z6OElDOHhsUUJOM3QwaVJKWStveEZLc0lNRVBBTUJ4YlFaNUNoWWpGMjR6ZktWQkE1VUdjSG1BQXNRM1pnd245bU11ZVE1M0w5L3JhaGtjQjJQSkVwbDVBSWFzWWhQL1VCc1NFVFlwMDB4Z2F3QXJBSVFEQkVnUGVnSUNBWTd4UDM1M2VFdVQvVHk5ZkNXbktNUkZOUVFBQ01sTEE2NjFNSU5Nc00yamxTN2JKcjhHeUZvMGJtYXNhbllHQ0Rxc2dJT05LUXFrQUdlQllBa0hvd0RZemhoRU01OWxDQUZRTE9IOVNDendRQWw5QVFaSThBZFVQRnNvRlhKYkFBRW9GcDF2dnlMNkNROG5Ec2R5bVlRTlgwQitGTTBFQmkrSUJtSVg1UjBpNWVkK1MwL2VSQkIyRVFCbUdCVURXTFRMTnlFSEpLSk9QaUphVG1rU0Rwd1FOZ1lDR1FxQTFMVUhxdEF3T1lNaS9vZjBDTUlIVEJpcEFJWUVPMk1La2tDMUJRUERGRDRBeDhubWxsOWJOa1o3Ym13djF3SUg2cWtRUW5kRUhRWVBlWHhVckxVbkUyOGNWc2N0VVdvWkdqWVZLV2U5VkFJN1JGSFpubXNvQldWbVlENHhUV050R1o5d0Zhd3Ird0FBU2RBSWY2c0FqQWJmdWNXdVJBeDRqTmxpUUhEU0FJSTMwUVlVWXFaNHhTR1RjdDIrV1QxYkNudytBSmNiTlhLS1NFOFpGUitmUEFUV0xGa2VIUWNWSDRDeFQ5c0R0QTFjQUZBREJrOFpCQmFSUnBKb3Z5RkhCQUVvTXdQYVhZdnZPaDhiZlF4RHZ4U2h0SEtlNEtRZWVnL0FYaGNJSktCa2p4d2dYZ0IrUENBdFBpZmRUd3VzSkdkWEppYnFHUXpDUHl5U2tCWkpwejlFbjdpR1lpQ1g4M3dEZVFidDFUZGtWNklBQUd4aEwwd0VSVG1CQnpFU0JSVWRGUk1jdG5tVmJsUUxhemdCQXNKWHRIaGNIQ2NsWFJvZXl3Z3BEeW5oVnF5RldBWkJZVFdDRXZpSVh6YUh3TXhkTjA1eERUNUZBd0RrQkMwVGJCWUZvMnNzS0NOT1RRa29kQUVHMHVZTVhpeDVzTXZTQlp4ZlEzRWdjNWsrQWp3dkpRT0VOOXJGcHVZWHY0b0ZQQ1VMV1JyNUFLcHJPWVd1Q0FUdEFBbEtCcmNHa0lJQ0FkNmNud3hxdGwwbGZ6LzUraFVSNnEvbUhkYkZBNjhRejhzeU84R2licDhMZXRIRk5GOHRSQVYwYkVZT1JrSmhUUlFGeEFNZFB3VUpNaWNtWGxRS0JtTXNad0tvQU1BMURHQUFFUUVuTWhjQnRRWmdOZ2dMeGNIaUFvQ0ZGWUVNQWQ5MUU3Sys0dkhLWEJiT2ZKck9BRzFFMVlFa3F4R3NOd1VyMHcwcFIyTWl0SVE1QmxxWEFBMWF0d01DU2dCWW5UdVV0QXh4TmcwQXBDNGZncmhMN0Q1c1FRTStwTGNHZzJSbUh3SVpOWlBHQy9jSSszRGJiOFdsQlNDSi91TzJ0eG1qQ0JVTEx5SGdxZVJqRUJMbkFDeFlBa0J2QlFFMm93TnNNWHkwa3pXcUFEbTZPaDdIYlNLMmtRNTNBSW9LQUZXd04wMklBdWhpQklRZ1AzME9CVFVDY3BRcjVUMmZKakIrYlVkLzJnNUdvOXNNdjVDcm5GbHBmQVdzaSttYW1DTHRJejVWRnNCcmJiNEFNNDJyR25hNGN5b1EyZU1PM3o4Tk44QmVOS0NLQlFwM2pGck9MK3pxUDlXV0NRdWtRR0JqbVBzVEFDaHlidjR6Z25WY3RhUSt5blFsYUZRSnRUUFN4RUFzUkx3UkFLMHBTdGdzMk0wRUJRdElCbUtvbU5XSEtIVTF1RElzQWcya0VIdmxVYzUvQWdJQ0ozNFZjcHNrRlpIU2dHRnlkTGhGQ282bkNYRmZXWGdJR2dZNlI5Q0tJa0Zkc3dLNmV1SzFTUmtZQXhkWFYxWis5VVdwUVFPeklxbG9aeTBGSW9BWmZ4WDdGQUVhc0VLSEMwNHBBQWJuR1A0Q2tGRmtFWm5pV0MzeEJEMTNBRE5BckFGamtXOG5JQ1FLQU92bXpCSTh5K1F3TUJVZ2NyWTBXSmR0U3hsMGhGaWlwdGdQM2hEVGxtcGRWd0RUQ3daMEJEclpTMGVUUXQ1R0FMUUxRUUpjUHNRTk9rZ3VaWndDSU1URWVhZFRBeVIraWpvejRRbzRWelpaQUFBbGtTVnM2VlVjWkplcFVxMFN2engxNEJOSWJXTHBNQzdYRkpHdmZWcG9XcitjQUk0dHdtV2kySTl3cWd3QWFpd0RQdEI5RTd6MlNsWVNBNGh2YUtRMW5BWi9Nbloya1JaNVA2MEZJcTE2bENZRFZ3VnNLQXgxQnFQUmd6c09adktUUElvQm45a0NLVER1RHRNRnF0cDJuUllXTlJ3NlpCYzBNdloyRFl1MENMaGlXQmVDSzlqU1p3QlEyQ3lTQWFmblZ3S28zcmRKWEdXR1VRdjVnSGxXc1FRVUFGVW1XWGk0QVFOWC9vcXZFbmtFVUtHNnRsWjlRa3pEVDFqTHBtUjlmV0NnNHdCeUFpMEFXZU5DQmdZSjEySXR2bU1DTndyVlprWXpjVTVHQnM4YVQwWGNxWjA0SU42RlRnUXVMOWRaRGJJYTFXMEVSNjRkVWIwN29CMGVFODBmWjgvZG84NHhCRkdCY3dHYnBwa0pxNTMwVFc5R3VHTXNqTEpMTkFXckJVMEtBS1llZFVvREgzUUIwaUdUQUU3T094dU9WTDhCSUFNUFV4S0xBN0hVQmpIQkhFUXZGRDg3SFlFNDBacUFBWEVGMytFSS9GUUFBQ0FBU1VSQlZBQTVWQWNZU3F3bFRSNFRGWThBRkh3dEhRWFFoWU1BQndqNDkweGpicnhDUVJZMUZBME1CbVFkZnk4S0s1SlFLNWpJaGlOYjBBZ2pPQVA3ekIwVHFjc2loUVV3UlhTZFZFNENEMFJoV1F4NkVFWUxoaFlBZW9FM1AwNWlFd2JnSWlURUhFVWlxMVNPSmNtR0ZsN1h2MGRsYXZDZ0FsaXc1UURpZW1PVUF1YXVjZjVsaFRYR2hjNUFvaXFvWkZ1MFdaRHIrb1FZQW9KeTNZQUIyRnNORVRpV3VDWExvYzF0SVFhc2ZXWUFNZ1FVVGdZQVJGc2xId3BpUkRVczFoQlJvQjBiUTcrczBOS1RSZDFFL1JDZUhpQ2VVSzlKTjVFQWRKZnpuQUVxOGh0SGI1QUR1VVFDZjh0WS9VZ1FLYVJDRFNZcmhBaUE3VWF0ZVM5V1Brc0syY1lUZlVyVnBDVG1BMFNVckZCa1hoMEFtL3ZlVGY3UDdMYjREVThhS2JLWHowemR3VzNYY2h6UmltQXdreDU5aEhhS08yR25NYllhRlcwWUJZa054V3AxU0VYaU5OQ201ZzNETklNZ3R3K1NoWk5wT3BZcS9ROEFzd21rSWlPRUhYOTlOK0pNTUFDK0pLWUk3eXJYdkpXaFpnY05idHoyd1FBK2JrN0FQQUhUTXhuT2pTV2NyY2J6WCtPWldhaElUSkVhU2xWcTZYMFFHczJrRDdqc0RsVThpeGQzS1FPS0FnSGRBVk1BTm1OTU9JdU1qRXVzU2pkN0F3NEhIQlVtbG1KZ0NreFdZazRWZXE1alZROUNGRGl1ZGRvVmpIRjRkRFlBUkR3dFRrRWhrU1JPRmRXU2REc1dhQ2o0QkV4dWFBOE9UaUN4Qk5KSU9SeUFBb01PVGsxaVQ1d0RMaVpKQnJzN1ZWNHVBS0tRQ3hFU0VLQWZ5bVBHaHpPUDBwVmhCR0E4b2w1aUN4cHlPb1paRkNKSlJSWEZUbThzQTdQZkVudUFFZ0Z4MGtCc2t3TlFaaHl6TUxhZXNCNFNkZ0J1UUFLbWhNZXRSaFlBSUNRQVA3RUw5UzlKOHJrN3hEQVlnSXhNSWxEV0JHMERBVzhCWUFkR2theUhHd3dyQWk0Yi9yNXNBMHJDZXpnZFhqdG5pamFGUjVlU0JBei9hVlErbWdnQ0R4bVllbTZoRFF0TjM2OXBxanVVRWdBWUQwQlNVQ1QyQ2FBMEJra1NTaURNNmpPRVFET0ZqVERpSVFBVlgxVFBJN2JNd0s2aEYxc0ZUMTZiQm9GVG5WQUFGY2duZFRZT0R6Yy81MnhwSFJaeU54RERrUUJQaEdNTmhrbEdBYllESkxzM05GR0duQzhsQ3BidUFsMDZaV2JSTTBRUUpnZm5CQVZWQ3lxUjZMOVNMSUhRREFWTkdwWWlBSWMxQUprOEFJQUEwVGZET3pOQXJMcmhmN2hFdFZNbk1BRUJDVDgxVkNtQUw3d0orQUtGcFFTMFh4MHRiUURjUWdFSlp6Y2RCVzRBT1FCMnlBQUZFZUdXd2hXQWF0SUhBQkJic0NmQ1BsUUFpa1lCanhkWUVIZ2pOQVVOTDhPV2RHa0FYZ01mT1FESjA1Z0RaeVRJdFQ0cElpYktGNyt4WFNwNFNoZmt4eTlWeWxzcmE4UDRoNTB1S0hBR3cwS1pKYmtIMkdaczF4dk1QSTNkZHpnMXNOeGNzV0hkQTZJc0NOMEdlUkp0VkRDdURVV3dhUUFsUWowQWQyQ2E2d01KQTgrY2ZFb0tPd1AwRW9YR0hnNkVkUVVaYWVkN2NVdmVPVk1lc3dNZkd5KytHRHdGc1NzYjZTOWVoU0lxVlpGNzFKYlpoNkxCRkxJUkRpQUFDVXJRR2gzeU4xc0lJWUlrVU9lVEtsMU1UZVFZQ2lNQkZBVFFnaCt5blRzQ1NBT2F2OUF4TlVGL0FDbEUwZ1k3QklzVUppVk5BQkJGSlJUMkZ3Z0FzbGtGNG10TTlsTURJNkFHSHJzREJFTWhjUFFCQW53bWRnOG83WWtJenhKWWtKNzdBMzV2UTJNOEFPZmVHaXZ2Nk4xQ3VtUWorUlVHUFFPWExlRUFxZ0lwMUlnNm8zbkdkUmw4UFRVSnlRRkRFQUovS05kcjNna0lCeXdjTkhEb2lBZk5XMENIQ2x5dytBYmJzVStydU93YkJBbmNtcFUwV2VQbUZndEpkNFVBSEQrekxnQlNRUUF1Z2lyVUtXQThFUnd5QWpmRFBMY2hEaDNFZEpSUWdiSEFOV1M0YkRYMlFXekoybUpaaDE4WUZUQnhWZ0pzQmU5Z0ZTb0U3VlpYS0xsekJvNUc2cTdsMWhMeG1RTU1BNk1MV0g5UEpVYjNRZ0daQzRTQkF4MEJJTnJlRmo4MjJRQmpOd01nazAwRUsva0F0UFV2Y3d4aGM4Y1BSUUJTc0xnQWJSd1NHaU1CTGE1Z0ROME9la05XQ25jMWFWOXNxZVJldWl6bkNDK1BMTWpKQWg0eGhxOWlBd2dPSTNJdnZ5QmcyVGliYUM1SWxwTTBMa3A4QmRjR0w5L0xCM0Q5dTNvSlZ3QlpEU2trUFFJSVRzalZTNU50cXp1a0JvU1VJdExhTFVlR1FsUnBoOWJ4bVJ3QU9DSzh1cEdzVGQvYVA5QWhGa3dqQm5FckRRWUFBVDI4ays1TEc4SWFQVExjdkNjaUVISWJEVzhQUzNGN1pBQnVDVjJ4amdRKzlNSGs1amt0SXZ3YlRDZGRDcFdPR1ZCRDRRSU9mYStNVVJrZFg3MEZLb1JOQUEwOHR0QXBVS2ZUcTd0SG02WVpBSllOUnRFV0h4Z240QUtXSXpRcktpcEFnU0s4dGs5YU9RcGt5MjREVWtRR1puVlFvUlVCUDBORFJJL1V3Z0lBTWZBb0VCU0xaREVnTFJPMUJyNlNWMzhFRjdyWEl4L0pBUThFM0VBTEJRY1NnTjBBRkZEWE1NK0xjdzRFRnBXRGIya25SVy9tUllZZGZBVWRmUUx3V2hrVUNKUXltczFrc2dUTXBIaGJBSGlsK2dFQlM3YW5IRFR3aVJwQ3JtVUxIbGdrYVdsMlZMMUdEc3JnMWFweXNnZUxRY0t5dGlHcFpVT2NETXF6N3pBQVF3SWl1QWMrTWpqdUJLK0ptb2FuSzk1TmNYRDRKeVpkMk5oNWRtVThJUkxMRFFkZUNUWUx2dEJuNmcrUDZkdzlKVFllVnBvR2k0b2d1MU4vSzFIWWtRQy9ZQnBaQXRyRVpBQmVJZlkxcUlQUHpGTEZxUTREREFOUnd4TE5PUUZqRGNhMldmaVdzWWgvcERlUE56OEg4QXdkdWlKc1NGa1RXUVJvZW44V0d3NEFoaDgxbnlRQlA1QUdoUjBFMjZad1E2REhjcndIVHJKaEE4eW9nVGdMSDlQaUFGc2dGR1VKWmdCMlNMc3lXek45QVNhNUNCMHlYd0VKQ2FtMldLRVBOVDU0WWxNQm4rME9ad0FkRHdnRUE5U25xeE5ERm9FRFFUME5HYU9GRUhSQURGbThGMjNKV1VRUUdoTUNBcld2TGhOQ2ZIQ2hCQmNOQzZRTks0MGJvUUVBTytsUkhBMkNVeExoWnlTdHBKN3BrRGMvQ2o1UzlWTVlIZ0MxUGtSL0t5Vlptd0VkS3FKQUNERWNqU1liZHhxK0FLSFZKVWh4VU1MUGRIVWRiQUFDQ1AzM0g5VUFBOEFFTGtZeVNHczFOWkZ2b0Fzbkx1ODZDQlRHTUR0cnBTM3hPSUhWSE9WVlN3VWp4QTNYRlMzZGlETVBMYk96QjlrN1djOVF3Vko1cmhzQjZFOFMxQUFHTFhvbTJCSUdNaGJscmwxYkZYSVlqUVNtUmlVdEJWRUtSYk5zeDRHS1MwTmlKQytIUHBpOUxRNzZtanlmNk9Wd3FCY0dVbVlFWGdNVGQyQTZIV3F6djdlR0VReEJqa2NCVS9OVkxDZXNoS3BETEhKbHEydEtHWGVTU3dGQ0pTMHlBd0VkMFFFUVlVTGlXVzVvMXVNZ0N2MlViVlFWSW5vRktDdjdGellFRWdCKzMxdDRIalVzNm1oZUNjR3RSd3hrTXNNbEJCSGYxYjBBRGg4ZFpMdFhPSk0ya0RVU2pneGJXWm1wQWpJU1ZnUmJDNHNDSnVnRWpkUjMxZ0FwN2hNQW5rZ1RNNVlYU1FPWlBHc0hPQUt3ZWZrd2tud1BFQk1xZm4wTmhKVUkxNUlDYk0wVFdtbXNlQVd1WWVCUWlhb1dDUkFBMUFLYnhBbzkyd1BYRVVRdzd3RGZuU0lybkc0Q0dWM1lYYUJuUGF2d1c0T1hBcFFCZlp4RHdRMWlDNk1FTkNFSkFPS1pxREZVQVJnNDhpRkRURExoTndXanFINFdIQUU3UEFMSkZRVjdFd01CbVlsNE14NFdEcXNDQVZnQTNBUUMvTmNwMkxNQTJhb3RCbnhlTkFwUERLZTlFVlNpR1M5Sk1FdEt3SlVJbHdNVURhYzVvSUVQUm5hcEVpa0xNd0FoelFVZ0ozUWlBL0NpT2dxV2UyM2hZQTBaQWdsS0RTUVpPQUVPQzcyS0JKb2F2amZPUEYzSVdSY2lhRVl0RXpoTEt3QzJia2xrTlpncFJ3STZXQnRQQXcrbnBzRHNENndVMFRKMThKQ2JCeTRhTklIUENzdEZBaFJiRnprRE9pWVNseVVMV29XSnVVbUhNYU1QUWhlNUIza2JYa1ZMNWJaZlcwY09NemIrV0FBQWtHTGZEd0JrWkFBVnBHSTR1bXJwc09jaFNJR0tBemNCSWpTWG9CTm9rQWxETEFGeEZwc0NiUFRRVHc1eHN3Z3RpeVI5UVZVR0JEeldUQWFWRHFFQWJDc0FUaU85emExSVVlemtVMk5mY1cvTEhGYUowWjhBQ1NwSlZBVjlBbkw1N2hPakJzK2pCRmFQVnl2bmU4ZHFMVWZiRjhHT0VLVkNEVnNCTGd4ZEpnQm9DbGtBcVVNbVpTOWNaclVVQ2drby9EVFNIaFlHUEM3NURtMUNJaG56R1Y0NFRnSjU3RG5jRU1UT0VCV01BSUV6RkNBU3FpOEJNUUR0ejJXd0FDaHdWRkVGWUY1cUVWSlU4MzdVeXg3ZlVHeEUxWUJHZ3UxTjBuRXNHaVlCQVJDSkdpdjdudzRDQ2N0bWZ5b0dybnJ1aHd6ZHdKVXlIUU1DV3lwcThUNmNhQUFFMjB1VkhaQWx5bWJ2T2dTRUF3RHRoRUljZkFWakVRQnZCUmtYa2h4ckFtMmlrSThSTnQ0NUZOdU9vRm9rUlJkZWdhYVFPdGV4S0pLMUhpVUFKV0VESmdaejIySUlOanFGYVJlV0cvUUV6ZnNDUkJQR3lEZFlSZ2NDcnpJa3NFOVpSU1hpQWRLdEgyVllBdXp1cWdNYTNyQURpNVFHVUg5dkR6TGVPUUlFV3dBSlY0dWJYVlBEaDVFa0V6SVZCakJrZE1jeG1BZFZ4UWNEanh6a1pyN0hlVFV6QVEzcDlBYUxhWkdOSFdiMDA3RUtrdk96Yys5TmZ6Z3BJbGxMNW15TEZiUUx5Z000WGdZRjFKMlR2azB1RndJT0V0bGtTbUZGQS95TEo4ME5Bb01BWGNiZUhneHdsMWpjb3V4Yml4Q2gybFBIVEZ4M3F0YUcyZnAyMHdyd09nQUw1eU1yQ2dSSnZRUXRnMzh2WHdmNmRvSVcyODRQWkJwSHBzQkpQemVkdzVBSENBRU1TN1lhYlJRemJrVzZMN25kQURQcU5Da2hBWmlMZEFNWWZpWklQT1lqR0F3R0Q5WTZ2R3VpSXRxekxTaFBQSjZuVDFWN1pvcWVweU93TC9kdkZWeGlmQndBaUhhTUFSWVRRVXhnQWdBQ0t4UnZCaDRrams0QUF3VXEzZ0FBRWVaQzh5QU13NWkyMkMwK0dEdGdCRHdCWGc5OEF3a1JPVUE4UzhZQ0JGOTAzbGVWaVpqVWE5MGNkVEVPQnJ3RFhIdzFCZzhTSUFEOUVzU2dJUXdGREVjYXNHZkJjbC8zQUdodE1ENllqTFZhTzdnTFNsMEJBMzJ3VThvNUFlY3FLWU90Ymg0QmRRTklqbzBnZWtuV2dYV1M3d0d6SHhaMEEzTnFIUUVCY3dDdE5xbHl0K2MwQU9rQVNuZ0dBQXBCU1lOU3NHQVJ3eG9xejBOQS9nZ0xoMkFta1hFQWxrYXV5U1VEdTNRYkJOcFFVemtkWW0rdVlva2JBalVtVFprQ2pIaDVaZzR1QVExT1kyWjNtVWw5dkN3Tm9LWW5GalNsYm1pUDRSbVBVS0s3ZVowRFBnbm4wWnFEbUpEdUE5OHlBUSthTDFQQ1NtOU5CamN5RTNCTW13Q21FT3l2Qk9pbEQ4ejAzZ1pKUzA0ZEVLNXl4d0JLVW5MVUxnQTc5NXh5MCsxTVhXRVBlME1TVFdkT1NsbG5INEpmSG9meFZpSm1nTVZBbmJJTVlTWSt3QVVNR1NjUTFnOEFZcUFSbndFQkF3Qkk1cE1GZUZPajg0TUhCTk1ldXdlSWp2a0RFeFBLaDlvbXNsR0NTVmdBaU43WUVCNDRRcHAyTGlCalBkYXJFQURPQklRZGFPZE1lQTFYTUo4VHB2d1EydEdNZTYxa2lBY2RFQW9DcnRCTkoyL1JoczVXZklMQ0JpTS9sSUc2NEI1RVZINU1mdVFTOHgwM1phMkFDdTdjRXc3Tk1ROGZJZ0E5RWhZekpZbWpWNHN2d2hkcURJK2d1UlRUV3ZCQVhCMVVkcERHMVFJNERJWTNOTWpxNDhjSEFnL1BiQWVRRUZsWThyRTVDbElBQ3dCeDVSeFNKcDBqUXhGaEdFTlZTalVRQlF3MmlNT0tUSHhrR2pXUzlTbmJBckVMY3JZMHJ3eU1aVDhTaHlrUVYrRndVSk11VWdhSVdTZXlSQlpkYlJBQ1JDQ2lpU0FtbDJBRUdHSW1EVWg3SEd3c0hHNUtheGFHS3NBRFExOHFDNktKc2FZdERVc0FBVE1QbkRGZk5hOEVBSDA5WUgySHNONUd5a2hGV0F4Tmt3QUdDU2gwVmgvbk1TT2xobVVZN1JWTUJBRFFtRGM2UVBwWE9WUW9CYkFNT3lFQ3V1blV5eFBnc1EwRVRuQndSWFFCQUQ0WjlJWVgzdFJNcGJVQkJiRU90eWRpQ0FJWXVlKzlzc0pqSGdSLzJBZVZJSUdiQW1sTFlVeW1ReVJ3WlFUWEJsQ1dtZ05sNDhoVk03UVNJTDBDZEpOU3UybEZuazhmaVpVWlBSRk9EUUNFSDBFeGp4SktTSEpIVFdsaFN2Sm1JWlpxY3pJK0FEQmZSUTZENFE3OFV0a0FBd3NCdzJJNE1Xc1pseGhETHdEL0J3RDRXQVVHQ25lNHNoaUdHeWVyb25TVUFRWFA1VWtBT1orQmZ3SVJSQU5RUzJleU5TRURjUDY3Y1BRQUFBNWRQd1RsNUVnNUZIU0ZHaVFaRjZCWkJ4dHR2MkdveUVRRkIweFNOQlVXL0Vzc0cxYVJBQlgwTDBvWFRrOXc5UC9ubStaVk1taEJRaGNJR3hoWU9ISG9Id056SmxkeEZRQjBLSGFwWWdCRGtZK1dLSVFCQlMzY0pRWU92bVlBUjBxS0FFOEdBcHVoVlFEVEthd3JFMG1QQlFHMGd0MjhHb1UwWUhCRHdmcUhIaGpia0Rwb1NXVldBNmtFczBlMWpBSXZta3llZ3BNNkcxSUJYVXpFTHdVT00ya0FJU3dtQURSc1EwTXdZeGVZTC9BNlJRQUJ6bGl3S0JnU0s0TUl4Z29nRFR6R0E4NmRETWErWFVNQ0xrYXpPdVZER0FwdmJDZmc0Q1FhYzJpSlU4U3ZrUU1vTXJEK1BRSUNWK29pbkVFZEJtMGlKVDRNeUFoVFpnRllFbmtXbkc5eG4weTc0aWx2WGUyNUpibGk0VUlKUUFKRERqWGlBNFFERFNpVmRpTWkvclhJYmg3VkFQQVB4QTRVVS9iRmo5a0RRd1FLa1p0SEFsbVJHd0F0MW40YzV1S21nNGtPUmdkNVdCcS9WMTdiTmlGdUF1NEFYSWF1Vm13eWIxdEozZ0xNa2xqTXZZSnBDR0VNNzlSQmtob2ZBWDA2bzFnYUx3THdURGFNRFFFRnV6dzZVbEU5QVNWYzRWaHlpamx3TUJDOHE1VFhCd1krTXNnSGUwVkpvQUpqbGdBVXZoOHpBQWN5TmdVWWwwZTd1MkpkR1I1R2JFT1BCUVJaQklRQlpuclpBdkpHellLVlFnOG5Ud3NrWGdScDFodmdCUndFaXp6MFYzNWZNcXRvc0JBRE53SjVFc0dKQkFyaUVTOHJBRFYrMW9oZ0J3Y0JMM1lCRkFpSVNnSUFBYWlhSHRwZERnaDJPajFEZzhHMWd6ZHhkR2tZUXdXN0NRQ1RORFcxR0d0VDVxSnB0cWZoQUFNMmJocVAvWXdaQ1d2RFU4d1ZabXQ5cVEyeU1vNitLSExaL2RzbEFnV3k1QmFuQUljQm5iNWhjakk3V0JaNkFxVHVBU1A5TEhaUmlIaDBXUTFkSnpncU1YR05xU1dGN2R1U29oWEVxdDNFQWNrNFp3VVZWWDQ1Q2haRUlCWWVGbnBPQzV3UEl3QS9HdDBjSWNLc29xVEpQWjFVVFJNQldBOU9NcVdjSzgvWUFJdmZuekJoRXdYaWZ3Z3RoZ1lnRWVjWEJBc1FaU1ZmVlEwRVIzdzRUZ0U4aUU2WkVJd29GVFl6VXdHd3QyRWwwM1dwNFEySUFMc09KblZZQkdaZEtDVUJ3UUFxQUZxbFFFWkpSYnRyd3FjZ1hsSUlVeDJOY0VTaHV2SUJiZ3EwWFZDTkJBS2hVVDRKUUIvT0JncUlmM0Z6WTZWN095S0FPQW9CQVNnMkdVOUdBQTRBZlNNS29qRzBtNWd5cUFlM01YV1RVZ0RBQWd4RnRCY2J4M2dDbUFZQlJDRUlhV2RCbVhZRGdRZFBoUU1TZVZranQrSUZUdUM2SWo4TjgrY0lPaE14RnZOMERKVTdyZjZlQ1RwSjlRTlIxTG9RUVFNZ0VZMjZmQXB4VkM1SE9HcjlzS1U5R09ScGRTUmpBVzRyVUVzM0dnUkZvOUlKdlltS0l4bjNFdUF3QURNTWpjK2RDcXllUFNHcFFia2hFWG9WSHdiOVNKNWVNUjN6YlhaNEpXMkJxWlZ3Mmw3cElYUnJBaFNBRUFWUlM4NHlLNHJOTzJsMndOVmNDRlc3RlF3YkFEcG9oRGhIK0FMVjVBZ0Q0clFwR1JlTVE5dGttTEl6YnhQUEhTdGxJZFhDYlMxaENFajR5a3RjSDhjTzlRc3B1U0ZGYzJzZkZNamh3OFdCZndINEFMMDBTd1VET3RoU1FCNTR4RXNHMGkwQUNFN1d1ZGRhSHRMSlp4Y0NTVUVZckRSRjd4UmNlRkUzQUMyeDBrOEhuU2hqKzhtbjFBSUNEUXZIaDd5ck5MTHBkU01CT0Y3WEcwTUlLVHBnM1hlUFpTZ3hqNEVVRFFXNkVSY3pBbWtIQUNNcVJ6cDdqd0xCSEUxSis5cmdHRTBqTUtSOWVBQzNpVWVPTmFrQkpBdk1BTEo1anlWbkhEcG80SGNxSVFRcUpES0ZOQmhvR1FwQUFiNm0zNHRwTUN3QTBwMmV0MXB2OXdJa3IyeU9rU2dweFFMS2MxSXFERHNXSmdRV2lGbklDT2RHNUIycFExRlFFcUJrMmswRlNROG9Ma0ZHZTM4dENFNjFsREFBQnQwQU1hQUNFUzdtNXVETVdrT1FKcDAvSGc0MWRwNW1oUk55dit4cllqa1JFeHBYQUFDWEI3VG9VWUlPVkJjUkdwbHRWYmU4T1lnZlhGc0J5WTRoR2hrcGt5b0I3aGNGNkswdXZFcWZaM2dyaVV3QkExYy9sRDY2Q1FGUGN1SzhVd1J4UUhyamV5WkVhNHcxdlJRcVlUZ3h6eGdRRWhwZEdSVVVIUk5uZjR2cVI0T2JZR0NXbHJ0RE13aFdJMFpoRXhvaFBEWWNmYllEb3dydVlyY3VrUlUrajBJR0FCWk9UYXRPV0E2RGJ3UkhXbk9ERlJjNFBJbVZhMjRrN0FUR2Iwa2JRcGNTc0w0WUZia2dBUldoQkhsNnZGcEJQUlN5Vm1PZFRtSVhlZlBRQ0xnTFVXVXBOVitNQXdkVzNwMTBwMGV1NUJ4QzUwNEJWSVh5OWM0SldGZUpBMkJqQnhQWkFuSUJWUUFaaFFVMUFESDREam5NR2VOSExPaHpHWTBMNnlRdGJZb1hBSnliNnUxUEY3VVo1eUF0NEp3R1lsZFlCZDBWZW1iWUxRQm5WVHB2aFNBL2NrSUQ1S3dxRENIS0JwMFlBaVIwb09jZlhGRDVHUVkrb1VKSDVKcUhBUjhVQkI5UXFJY1RQd1FERS9jdWtKc2FPVkliQXVVQmF4RVZLdmQzaTIrUThCQWZWOG5HT3dLWS9EdE1BZ2tMTU9ub0hwQ1RBUmNHWGdJVWhQeVlEblZyQUV4RFFTSjFnR0lNR2d0WUF5dG01bUF1VXh0b0I1OFRYVHR2NndVQWEwTmRSU21ia01VRWMxNVFQekVtV1JRQ1NpdzVjQTFWb1JRZld0eGMrVDBGMDNrcjFUOWI3UWlycmJ3QVhpdzlUcElRTHdNUnoxQlBJbExWejJDOUtMUWV6MFVTOWpNR25Va3dDRFdXS0tXa2pRbG1YRFpqUUZ4TDduc29leTVWUXdvbkFBUlRIVis3VDJvMkZsSWpBZ2hLYzRwTFZGV2xQNVlCSCtpV0JyY2NNVXBXdnhmTGdGMlVjM0dscHhCZ0tTQTFDMjZERDZsRUNPdVBCWjF2Qmh6eGFvSmtPZk9HQlhFZkg0U3BxTG1jcVFnSExxcEEyRkp2b0xHRkJUVHRFVndQZ0lBV0Q1Y3pnRjFZS3diS0swb21oaWQ5cG5zRzNzZEJGZ01DbldFd3JBdC9BQXhzRGNsM1BXWXVCWFladC9WQUVIWkZSeXU5RVJNbFpBN2FHZGNDQmdBSkNQYjNEMkF0QXhLckhDY1JRRWgzUE14eFNnWnpocEtrQUJUWW5nUlNhYlJQTHdBRXdPZElaN3E0Q1hVRFNRQlc0eTBOQXMzR0FKRXpBcEkrQTNjaDhMNXdKeERIbDMxdXRId3RvbXNmdU9rWUZIY3pRRlE5WXBFa3NwSTkwWFFhUVJFR1FEWUFyZllVVFQxbitXbkVWUmxrTUswWUZFZWhld05GWEI5UWY3Tm5QUFJKb3pUQjhnZ0ZXaG9rQUNFZXFzVlRGRDRORk90ZlFTbEdrWXV0RTFCbmRBNXpCak0xekNBc0tXZkRZQllDS3NaYW5xcVU4bWdGM0FOckVBSS9IT3NIRGpnaThveWNVWW1sYWhiREV5bStFMlJab0o3Q3VaUXZGSVorSm8rQ05zaytkdmdBWFNzQ292Z0NSUzB0eUgrYUZZYUEyVjhBcFFMSUZBVzJaZmdpQWxJRXV3SU80QXAySTF4bkw5d0FkaWczVWdJR2Y2WUU2RGJCQkhzQmR4VVlQSGpTQUhOV2tJUlY0eVRvVEpvOWZIS2VJYTMyWDBsdUtTMEtNeFAzS28xZVJCSkNXa0lNeENUMFFtR0ZWYXU0SkNFOGZ5ak1CcnRHWFJGUUQwZXkzeWx2UmdnQUZRTWRzMGpyQVJNOVNzbkdQQlB3RVM2TnhtMDB5UUJ5d2xsVEFCYXFDZHdQTVVvTzVRZDg1U2txZGRxK09ndnduQjBjQVhWTzkyRVdIQTRJZGJSa05qSEt0Z3oxUDlpZ1JWS1dKVGNqd1pyUjh3TGZCRzBIQ09GT29IcThieGRUUWtBeEtnOG5FMURHSHRBM2tRZ3JvMHNZOVBVWXdqblpxZ041RlFlSGlFTUFGUmtFbE5JRUxHVllwQ3pzN3BzdWFnY2VPeDZWbkZNTlB5L01EUWU5QndFcVBWVU5CQWhjMHRwWEFGZXdBeForQUtzR1NyaXNzKzUySklzSU9qNkpWSHVOdGlRbmJsRnBhVjhFRDhMSHZ3NEVtQmdITDFVUDVnTnJCUTBTUWR6K0F4VUJxbk1ETnVCdG1nYkNNd2VvR3hJcTlBYk9RSXl2T2QwRFZFVU9YelFBY0pDdUZGNTJqNUp6NWFIUlE1WXdNbnk4UVFKY0ZZZ0FGMXNHa1JNUUJURER6RGRmSzRTS3l0YW9yQ200NGdTT3N3QTFsYzFJVldxRnVoKzZ4M0xuQlNVQUUyUUlXaWdGSGIzWUMxQlZEd1dkYjRlSUZ6ck5SaW1qcVNLcHd6bHRJSVdFZEk0OU1oMDZYUVlLQnc0MW9XalVBSHdnRW9LWEVLSXRLUUVEQUFzQU5XaHhBTjhLMlFSMmcxVWpBdHMzbURraDJqQS9MSEs3Qk01T0VRNm9CcUxMSGowYUEzVTNNWDJLYjF3RUJOSUhOdWwvb2dBbk9HRUVSUVdWVnh2WkEwMWRzaHRpQkE5c1VKcWpKRXMwQVB6cnhBNVRMaGxkK0ltYk9JSUJTQUo1Q3NXUTlud0RFNEVBbXdZQUZzb0YyOHA2RDF1Rk1ZTUZmZ1l0RTZxa053QUFUaXdxdkU5UUFEb0FBUUJxRjR3RzNRQXVtQmVlTjBrbHBGTUNKR21GQTlRckJBaVlVaUFzQUZ2Tm5tL0hDWE9CSEtJWlh5RmxRaWtEQzM0eGVUNElxUUVTK2toOE5BTVlBVUVBdmdCMEhpVm9DaU1JYkk0REdTWU5RbmRpT3ltVzAxTVJIRHdXenMvRmttTkJvc0JiWmxNSmowTFNBUUpVaWd1dlBRQUhTeGNBVGdBRWJrY2VLbEFtQTk2NlBRR0d2WWF1bDJOY1pHNjRjT1M1NXN0SWp4SVZBWnl1WWx3QkFWb0pMclY2Y1NRZU93THBEUVFiM2dNRkJVT01PS0NBSGdUQUpkLzBmc1pHUkNaejllb0JoUVo5THgrQm1RZ2pVTldnTlpFYmt6SXpKejdLbjIyWE1IVjVwNDlVaWhxWGs2RUFlcVM2a0RxelFjQWNqRWxoQXdzQUl3NGJralh1QlhIbWt3SkZBVDhOTGdDUVNBOWZBbW9XQUlJOHlCaW5LSUZNNXFORkRWSVRDQlkzcTFQMkJLTm5JUElKb0Exd1NHdE9Wa01WTDB3dVczcUdtUkl0RkVKZEl3TU5Sd0k0VmxaeUZBNW50cVl1M2JrOEZ1enZYNzNtKzBlOE1pU09icmtmWElTM1Bxd2dXMzBjc2dLYitzTldOQXFrQVVBSEhCY0FIaXNQRjhLeU5Wd2RqaWI0Q1FFRXFCOEJCazNSbXhvT2NBWXFFZG5CUW5pa0hrK0dDemF6U1RtdVNRWElqVjFJUFZXV0JKRXo2MXdTRUEwQVFBODlyK0RWSVdleEhmRXRXendheFdoWGtBeGg0akZvbHFzRVZzTVJPRWs5aWpmQUFSNWpUbWo2ZXhzQnRZUnlJaU1vWi80dFZoUGxQTVRLV0JmTE1RSXhVd0VBbVF4SkdDTUZTd1BqSndqMkdVeFlGaGNXZzV1MG50RUFTQjlkQ3dObmhsY3A3d0FEVm8ydDlaRXFHOHdKV3czYlc0SUJwb1d4RGlHV2NQeFRqZ1lhTjc4SkdHVzBvQTRCRnNGcHFUQUtBQVE4MFJFdWVnOERsY1BGbngxalhUQUs1Tm54d2dFYjYwY05tVWIxZ0RvNElEVUd5UWdDQVc4dUJFOEFDbGcra1FFQUNpSnlWVDV1VzhSQkc4N0FGQXBGbE93SEFpY21ob0lZSjVZS0FRelZaQ2ZDZXV1U25FVVNlWmNrRWlvcmREZ0pVWDNMbFBhektuZk5qaUllcU14VlpBWlpBRFRFRWtaOEVYR0wrZ0ZHd3JqYVRIeUNFYi8vSDZBWTdOUUtKZ3NXTEFFWlBGdUxablpHUm5RdHAxRXVKUlZ1SlRHZGNhMnBId0N0aEI1MStaZ0F1WHArbFJNeUoyU0FncllCNm0wUSsvNFlETTZhS0dpL2ZTdVZDUVZ1V3RNQkt6dGJxV0VvYTg1UFZkbzd6aWhtc0Z4aVhqbmFZUUFVbjViYktPaDZzMDhSQmhqZGFVODJRRDhodGdVYWxWOE9HbUlIQUZUZ1VKeWlNZ1RneGc4Zk9ONFpBYUJJZ254SmVhcWQxZ1J2QkJNSVRBZEdKV1JLV3gwbEFWSFIwajRBZHZZQWRRTmFRSlVEUkhsSG1sNWNTTE1qYVl4QXFIbWJBYVRaQVpjWjVzNkpMSkdpcDdzQ1hhdzJMQ1JuSzFZTU80c0ZSQWdWV2dmWE1mYyt6dDAzOEplSTZsa0NEUVU1eUNHZVpSQk9BOWFNRzNlMEFaN2NtUW1LamdlQ1d2bUpubjd5QXdZOHVvRUVMMXdMQkFEaXpwczFWRkl6bTVVWXRCSEZUNVF5NDZVQXNRVEJaQ3dQZ2xqTlBla05HRXdkaWMwRlIxSm1QNUFBaFNoVGw0TUNXd3EyQnkxTktsVXF6UVFHQWlka3l3RG9TZ1lHdFE4SlJkZWZKTHFQanc1WXNEODVHaUJXbFJzRFoyR3pWRGtDdlJTeVV6SXExNllVWEVCTGQya0duK3JMSXdBQUFLMUpSRUZVZjU0REQzQzBXd21HUGk5T1NqcENBMEE3ZkZ3VVpUbTBrdERaTGw1VlhtYkZERFFBQ2w3K1FTcnk1UUNNMmJmTkMrV0FGajFMQXpMc2l3RUJhUUNXLzFFR2NNTi90RzhPVmlRdHlsdWxCVXhSQURZbTVTRUJSQWNBQVJrZU1DNWlSTmdaaE9veG56NG9IQXBhNmdEM0FTZGJtRjE4OHd4cERaVktVTDRSVWhUU1NSdnJRQVpMRGNnYXVJbWFiZ0p6a1hJYUFMZVBBWG90MWo2QmR3ZTNBWG9RQW5YTUZWdUNBcEdXYmp1UnZUdTdBQUFBQUVsRlRrU3VRbUNDXCI7XG5leHBvcnQge1xuICBnZXRTaGFkZXJOb2lzZVRleHR1cmVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtc2hhZGVyLW5vaXNlLXRleHR1cmUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/get-shader-noise-texture.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/shader-mount.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/shader-mount.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShaderMount: () => (/* binding */ ShaderMount),\n/* harmony export */   isPaperShaderElement: () => (/* binding */ isPaperShaderElement)\n/* harmony export */ });\n/* harmony import */ var _vertex_shader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vertex-shader.js */ \"(ssr)/./node_modules/@paper-design/shaders/dist/vertex-shader.js\");\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\nconst DEFAULT_MAX_PIXEL_COUNT = 1920 * 1080 * 4;\nclass ShaderMount {\n  parentElement;\n  canvasElement;\n  gl;\n  program = null;\n  uniformLocations = {};\n  /** The fragment shader that we are using */\n  fragmentShader;\n  /** Stores the RAF for the render loop */\n  rafId = null;\n  /** Time of the last rendered frame */\n  lastRenderTime = 0;\n  /** Total time that we have played any animation, passed as a uniform to the shader for time-based VFX */\n  currentFrame = 0;\n  /** The speed that we progress through animation time (multiplies by delta time every update). Allows negatives to play in reverse. If set to 0, rAF will stop entirely so static shaders have no recurring performance costs */\n  speed = 0;\n  /** Actual speed used that accounts for document visibility (we pause the shader if the tab is hidden) */\n  currentSpeed = 0;\n  /** Uniforms that are provided by the user for the specific shader being mounted (not including uniforms that this Mount adds, like time and resolution) */\n  providedUniforms;\n  /** Names of the uniforms that should have mipmaps generated for them */\n  mipmaps = [];\n  /** Just a sanity check to make sure frames don't run after we're disposed */\n  hasBeenDisposed = false;\n  /** If the resolution of the canvas has changed since the last render */\n  resolutionChanged = true;\n  /** Store textures that are provided by the user */\n  textures = /* @__PURE__ */ new Map();\n  minPixelRatio;\n  maxPixelCount;\n  isSafari = isSafari();\n  uniformCache = {};\n  textureUnitMap = /* @__PURE__ */ new Map();\n  constructor(parentElement, fragmentShader, uniforms, webGlContextAttributes, speed = 0, frame = 0, minPixelRatio = 2, maxPixelCount = DEFAULT_MAX_PIXEL_COUNT, mipmaps = []) {\n    if (parentElement instanceof HTMLElement) {\n      this.parentElement = parentElement;\n    } else {\n      throw new Error(\"Paper Shaders: parent element must be an HTMLElement\");\n    }\n    if (!document.querySelector(\"style[data-paper-shader]\")) {\n      const styleElement = document.createElement(\"style\");\n      styleElement.innerHTML = defaultStyle;\n      styleElement.setAttribute(\"data-paper-shader\", \"\");\n      document.head.prepend(styleElement);\n    }\n    const canvasElement = document.createElement(\"canvas\");\n    this.canvasElement = canvasElement;\n    this.parentElement.prepend(canvasElement);\n    this.fragmentShader = fragmentShader;\n    this.providedUniforms = uniforms;\n    this.mipmaps = mipmaps;\n    this.currentFrame = frame;\n    this.minPixelRatio = minPixelRatio;\n    this.maxPixelCount = maxPixelCount;\n    const gl = canvasElement.getContext(\"webgl2\", webGlContextAttributes);\n    if (!gl) {\n      throw new Error(\"Paper Shaders: WebGL is not supported in this browser\");\n    }\n    this.gl = gl;\n    this.initProgram();\n    this.setupPositionAttribute();\n    this.setupUniforms();\n    this.setUniformValues(this.providedUniforms);\n    this.setupResizeObserver();\n    visualViewport?.addEventListener(\"resize\", this.handleVisualViewportChange);\n    this.setSpeed(speed);\n    this.parentElement.setAttribute(\"data-paper-shader\", \"\");\n    this.parentElement.paperShaderMount = this;\n    document.addEventListener(\"visibilitychange\", this.handleDocumentVisibilityChange);\n  }\n  initProgram = () => {\n    const program = createProgram(this.gl, _vertex_shader_js__WEBPACK_IMPORTED_MODULE_0__.vertexShaderSource, this.fragmentShader);\n    if (!program) return;\n    this.program = program;\n  };\n  setupPositionAttribute = () => {\n    const positionAttributeLocation = this.gl.getAttribLocation(this.program, \"a_position\");\n    const positionBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, positionBuffer);\n    const positions = [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1];\n    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(positions), this.gl.STATIC_DRAW);\n    this.gl.enableVertexAttribArray(positionAttributeLocation);\n    this.gl.vertexAttribPointer(positionAttributeLocation, 2, this.gl.FLOAT, false, 0, 0);\n  };\n  setupUniforms = () => {\n    const uniformLocations = {\n      u_time: this.gl.getUniformLocation(this.program, \"u_time\"),\n      u_pixelRatio: this.gl.getUniformLocation(this.program, \"u_pixelRatio\"),\n      u_resolution: this.gl.getUniformLocation(this.program, \"u_resolution\")\n    };\n    Object.entries(this.providedUniforms).forEach(([key, value]) => {\n      uniformLocations[key] = this.gl.getUniformLocation(this.program, key);\n      if (value instanceof HTMLImageElement) {\n        const aspectRatioUniformName = `${key}AspectRatio`;\n        uniformLocations[aspectRatioUniformName] = this.gl.getUniformLocation(this.program, aspectRatioUniformName);\n      }\n    });\n    this.uniformLocations = uniformLocations;\n  };\n  /**\n   * The scale that we should render at.\n   * - Used to target 2x rendering even on 1x screens for better antialiasing\n   * - Prevents the virtual resolution from going beyond the maximum resolution\n   * - Accounts for the page zoom level so we render in physical device pixels rather than CSS pixels\n   */\n  renderScale = 1;\n  parentWidth = 0;\n  parentHeight = 0;\n  parentDevicePixelWidth = 0;\n  parentDevicePixelHeight = 0;\n  devicePixelsSupported = false;\n  resizeObserver = null;\n  setupResizeObserver = () => {\n    this.resizeObserver = new ResizeObserver(([entry]) => {\n      if (entry?.borderBoxSize[0]) {\n        const physicalPixelSize = entry.devicePixelContentBoxSize?.[0];\n        if (physicalPixelSize !== void 0) {\n          this.devicePixelsSupported = true;\n          this.parentDevicePixelWidth = physicalPixelSize.inlineSize;\n          this.parentDevicePixelHeight = physicalPixelSize.blockSize;\n        }\n        this.parentWidth = entry.borderBoxSize[0].inlineSize;\n        this.parentHeight = entry.borderBoxSize[0].blockSize;\n      }\n      this.handleResize();\n    });\n    this.resizeObserver.observe(this.parentElement);\n  };\n  // Visual viewport resize handler, mainly used to react to browser zoom changes.\n  // Resize observer by itself does not react to pinch zoom, and although it usually\n  // reacts to classic browser zoom, it's not guaranteed in edge cases.\n  // Since timing between visual viewport changes and resize observer is complex\n  // and because we'd like to know the device pixel sizes of elements, we just restart\n  // the observer to get a guaranteed fresh callback regardless if it would have triggered or not.\n  handleVisualViewportChange = () => {\n    this.resizeObserver?.disconnect();\n    this.setupResizeObserver();\n  };\n  /** Resize handler for when the container div changes size or the max pixel count changes and we want to resize our canvas to match */\n  handleResize = () => {\n    let targetPixelWidth = 0;\n    let targetPixelHeight = 0;\n    const dpr = Math.max(1, window.devicePixelRatio);\n    const pinchZoom = visualViewport?.scale ?? 1;\n    if (this.devicePixelsSupported) {\n      const scaleToMeetMinPixelRatio = Math.max(1, this.minPixelRatio / dpr);\n      targetPixelWidth = this.parentDevicePixelWidth * scaleToMeetMinPixelRatio * pinchZoom;\n      targetPixelHeight = this.parentDevicePixelHeight * scaleToMeetMinPixelRatio * pinchZoom;\n    } else {\n      let targetRenderScale = Math.max(dpr, this.minPixelRatio) * pinchZoom;\n      if (this.isSafari) {\n        const zoomLevel = bestGuessBrowserZoom();\n        targetRenderScale *= Math.max(1, zoomLevel);\n      }\n      targetPixelWidth = Math.round(this.parentWidth) * targetRenderScale;\n      targetPixelHeight = Math.round(this.parentHeight) * targetRenderScale;\n    }\n    const maxPixelCountHeadroom = Math.sqrt(this.maxPixelCount) / Math.sqrt(targetPixelWidth * targetPixelHeight);\n    const scaleToMeetMaxPixelCount = Math.min(1, maxPixelCountHeadroom);\n    const newWidth = Math.round(targetPixelWidth * scaleToMeetMaxPixelCount);\n    const newHeight = Math.round(targetPixelHeight * scaleToMeetMaxPixelCount);\n    const newRenderScale = newWidth / Math.round(this.parentWidth);\n    if (this.canvasElement.width !== newWidth || this.canvasElement.height !== newHeight || this.renderScale !== newRenderScale) {\n      this.renderScale = newRenderScale;\n      this.canvasElement.width = newWidth;\n      this.canvasElement.height = newHeight;\n      this.resolutionChanged = true;\n      this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);\n      this.render(performance.now());\n    }\n  };\n  render = (currentTime) => {\n    if (this.hasBeenDisposed) return;\n    if (this.program === null) {\n      console.warn(\"Tried to render before program or gl was initialized\");\n      return;\n    }\n    const dt = currentTime - this.lastRenderTime;\n    this.lastRenderTime = currentTime;\n    if (this.currentSpeed !== 0) {\n      this.currentFrame += dt * this.currentSpeed;\n    }\n    this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n    this.gl.useProgram(this.program);\n    this.gl.uniform1f(this.uniformLocations.u_time, this.currentFrame * 1e-3);\n    if (this.resolutionChanged) {\n      this.gl.uniform2f(this.uniformLocations.u_resolution, this.gl.canvas.width, this.gl.canvas.height);\n      this.gl.uniform1f(this.uniformLocations.u_pixelRatio, this.renderScale);\n      this.resolutionChanged = false;\n    }\n    this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);\n    if (this.currentSpeed !== 0) {\n      this.requestRender();\n    } else {\n      this.rafId = null;\n    }\n  };\n  requestRender = () => {\n    if (this.rafId !== null) {\n      cancelAnimationFrame(this.rafId);\n    }\n    this.rafId = requestAnimationFrame(this.render);\n  };\n  /** Creates a texture from an image and sets it into a uniform value */\n  setTextureUniform = (uniformName, image) => {\n    if (!image.complete || image.naturalWidth === 0) {\n      throw new Error(`Paper Shaders: image for uniform ${uniformName} must be fully loaded`);\n    }\n    const existingTexture = this.textures.get(uniformName);\n    if (existingTexture) {\n      this.gl.deleteTexture(existingTexture);\n    }\n    if (!this.textureUnitMap.has(uniformName)) {\n      this.textureUnitMap.set(uniformName, this.textureUnitMap.size);\n    }\n    const textureUnit = this.textureUnitMap.get(uniformName);\n    this.gl.activeTexture(this.gl.TEXTURE0 + textureUnit);\n    const texture = this.gl.createTexture();\n    this.gl.bindTexture(this.gl.TEXTURE_2D, texture);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);\n    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, image);\n    if (this.mipmaps.includes(uniformName)) {\n      this.gl.generateMipmap(this.gl.TEXTURE_2D);\n      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR_MIPMAP_LINEAR);\n    }\n    const error = this.gl.getError();\n    if (error !== this.gl.NO_ERROR || texture === null) {\n      console.error(\"Paper Shaders: WebGL error when uploading texture:\", error);\n      return;\n    }\n    this.textures.set(uniformName, texture);\n    const location = this.uniformLocations[uniformName];\n    if (location) {\n      this.gl.uniform1i(location, textureUnit);\n      const aspectRatioUniformName = `${uniformName}AspectRatio`;\n      const aspectRatioLocation = this.uniformLocations[aspectRatioUniformName];\n      if (aspectRatioLocation) {\n        const aspectRatio = image.naturalWidth / image.naturalHeight;\n        this.gl.uniform1f(aspectRatioLocation, aspectRatio);\n      }\n    }\n  };\n  /** Utility: recursive equality test for all the uniforms */\n  areUniformValuesEqual = (a, b) => {\n    if (a === b) return true;\n    if (Array.isArray(a) && Array.isArray(b) && a.length === b.length) {\n      return a.every((val, i) => this.areUniformValuesEqual(val, b[i]));\n    }\n    return false;\n  };\n  /** Sets the provided uniform values into the WebGL program, can be a partial list of uniforms that have changed */\n  setUniformValues = (updatedUniforms) => {\n    this.gl.useProgram(this.program);\n    Object.entries(updatedUniforms).forEach(([key, value]) => {\n      let cacheValue = value;\n      if (value instanceof HTMLImageElement) {\n        cacheValue = `${value.src.slice(0, 200)}|${value.naturalWidth}x${value.naturalHeight}`;\n      }\n      if (this.areUniformValuesEqual(this.uniformCache[key], cacheValue)) return;\n      this.uniformCache[key] = cacheValue;\n      const location = this.uniformLocations[key];\n      if (!location) {\n        console.warn(`Uniform location for ${key} not found`);\n        return;\n      }\n      if (value instanceof HTMLImageElement) {\n        this.setTextureUniform(key, value);\n      } else if (Array.isArray(value)) {\n        let flatArray = null;\n        let valueLength = null;\n        if (value[0] !== void 0 && Array.isArray(value[0])) {\n          const firstChildLength = value[0].length;\n          if (value.every((arr) => arr.length === firstChildLength)) {\n            flatArray = value.flat();\n            valueLength = firstChildLength;\n          } else {\n            console.warn(`All child arrays must be the same length for ${key}`);\n            return;\n          }\n        } else {\n          flatArray = value;\n          valueLength = flatArray.length;\n        }\n        switch (valueLength) {\n          case 2:\n            this.gl.uniform2fv(location, flatArray);\n            break;\n          case 3:\n            this.gl.uniform3fv(location, flatArray);\n            break;\n          case 4:\n            this.gl.uniform4fv(location, flatArray);\n            break;\n          case 9:\n            this.gl.uniformMatrix3fv(location, false, flatArray);\n            break;\n          case 16:\n            this.gl.uniformMatrix4fv(location, false, flatArray);\n            break;\n          default:\n            console.warn(`Unsupported uniform array length: ${valueLength}`);\n        }\n      } else if (typeof value === \"number\") {\n        this.gl.uniform1f(location, value);\n      } else if (typeof value === \"boolean\") {\n        this.gl.uniform1i(location, value ? 1 : 0);\n      } else {\n        console.warn(`Unsupported uniform type for ${key}: ${typeof value}`);\n      }\n    });\n  };\n  /** Gets the current total animation time from 0ms */\n  getCurrentFrame = () => {\n    return this.currentFrame;\n  };\n  /** Set a frame to get a deterministic result, frames are literally just milliseconds from zero since the animation started */\n  setFrame = (newFrame) => {\n    this.currentFrame = newFrame;\n    this.lastRenderTime = performance.now();\n    this.render(performance.now());\n  };\n  /** Set an animation speed (or 0 to stop animation) */\n  setSpeed = (newSpeed = 1) => {\n    this.speed = newSpeed;\n    this.setCurrentSpeed(document.hidden ? 0 : newSpeed);\n  };\n  setCurrentSpeed = (newSpeed) => {\n    this.currentSpeed = newSpeed;\n    if (this.rafId === null && newSpeed !== 0) {\n      this.lastRenderTime = performance.now();\n      this.rafId = requestAnimationFrame(this.render);\n    }\n    if (this.rafId !== null && newSpeed === 0) {\n      cancelAnimationFrame(this.rafId);\n      this.rafId = null;\n    }\n  };\n  /** Set the maximum pixel count for the shader, this will limit the number of pixels that will be rendered */\n  setMaxPixelCount = (newMaxPixelCount = DEFAULT_MAX_PIXEL_COUNT) => {\n    this.maxPixelCount = newMaxPixelCount;\n    this.handleResize();\n  };\n  /** Set the minimum pixel ratio for the shader */\n  setMinPixelRatio = (newMinPixelRatio = 2) => {\n    this.minPixelRatio = newMinPixelRatio;\n    this.handleResize();\n  };\n  /** Update the uniforms that are provided by the outside shader, can be a partial set with only the uniforms that have changed */\n  setUniforms = (newUniforms) => {\n    this.setUniformValues(newUniforms);\n    this.providedUniforms = { ...this.providedUniforms, ...newUniforms };\n    this.render(performance.now());\n  };\n  handleDocumentVisibilityChange = () => {\n    this.setCurrentSpeed(document.hidden ? 0 : this.speed);\n  };\n  /** Dispose of the shader mount, cleaning up all of the WebGL resources */\n  dispose = () => {\n    this.hasBeenDisposed = true;\n    if (this.rafId !== null) {\n      cancelAnimationFrame(this.rafId);\n      this.rafId = null;\n    }\n    if (this.gl && this.program) {\n      this.textures.forEach((texture) => {\n        this.gl.deleteTexture(texture);\n      });\n      this.textures.clear();\n      this.gl.deleteProgram(this.program);\n      this.program = null;\n      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\n      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\n      this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, null);\n      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);\n      this.gl.getError();\n    }\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n      this.resizeObserver = null;\n    }\n    visualViewport?.removeEventListener(\"resize\", this.handleVisualViewportChange);\n    document.removeEventListener(\"visibilitychange\", this.handleDocumentVisibilityChange);\n    this.uniformLocations = {};\n    this.canvasElement.remove();\n    delete this.parentElement.paperShaderMount;\n  };\n}\nfunction createShader(gl, type, source) {\n  const shader = gl.createShader(type);\n  if (!shader) return null;\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    console.error(\"An error occurred compiling the shaders: \" + gl.getShaderInfoLog(shader));\n    gl.deleteShader(shader);\n    return null;\n  }\n  return shader;\n}\nfunction createProgram(gl, vertexShaderSource2, fragmentShaderSource) {\n  const format = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT);\n  const precision = format ? format.precision : null;\n  if (precision && precision < 23) {\n    vertexShaderSource2 = vertexShaderSource2.replace(/precision\\s+(lowp|mediump)\\s+float;/g, \"precision highp float;\");\n    fragmentShaderSource = fragmentShaderSource.replace(/precision\\s+(lowp|mediump)\\s+float/g, \"precision highp float\").replace(/\\b(uniform|varying|attribute)\\s+(lowp|mediump)\\s+(\\w+)/g, \"$1 highp $3\");\n  }\n  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource2);\n  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n  if (!vertexShader || !fragmentShader) return null;\n  const program = gl.createProgram();\n  if (!program) return null;\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    console.error(\"Unable to initialize the shader program: \" + gl.getProgramInfoLog(program));\n    gl.deleteProgram(program);\n    gl.deleteShader(vertexShader);\n    gl.deleteShader(fragmentShader);\n    return null;\n  }\n  gl.detachShader(program, vertexShader);\n  gl.detachShader(program, fragmentShader);\n  gl.deleteShader(vertexShader);\n  gl.deleteShader(fragmentShader);\n  return program;\n}\nconst defaultStyle = `@layer paper-shaders {\n  :where([data-paper-shader]) {\n    isolation: isolate;\n    position: relative;\n\n    & canvas {\n      contain: strict;\n      display: block;\n      position: absolute;\n      inset: 0;\n      z-index: -1;\n      width: 100%;\n      height: 100%;\n      border-radius: inherit;\n      corner-shape: inherit;\n    }\n  }\n}`;\nfunction isPaperShaderElement(element) {\n  return \"paperShaderMount\" in element;\n}\nfunction isSafari() {\n  const ua = navigator.userAgent.toLowerCase();\n  return ua.includes(\"safari\") && !ua.includes(\"chrome\") && !ua.includes(\"android\");\n}\nfunction bestGuessBrowserZoom() {\n  const viewportScale = visualViewport?.scale ?? 1;\n  const viewportWidth = visualViewport?.width ?? window.innerWidth;\n  const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;\n  const innerWidth = viewportScale * viewportWidth + scrollbarWidth;\n  const ratio = outerWidth / innerWidth;\n  const zoomPercentageRounded = Math.round(100 * ratio);\n  if (zoomPercentageRounded % 5 === 0) {\n    return zoomPercentageRounded / 100;\n  }\n  if (zoomPercentageRounded === 33) {\n    return 1 / 3;\n  }\n  if (zoomPercentageRounded === 67) {\n    return 2 / 3;\n  }\n  if (zoomPercentageRounded === 133) {\n    return 4 / 3;\n  }\n  return ratio;\n}\n\n//# sourceMappingURL=shader-mount.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVyLW1vdW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUV3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxpRUFBa0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLElBQUk7QUFDOUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxhQUFhO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxZQUFZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0IsR0FBRyxtQkFBbUIsR0FBRyxvQkFBb0I7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxLQUFLO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLHlFQUF5RSxJQUFJO0FBQzdFO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxZQUFZO0FBQzFFO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSLHFEQUFxRCxJQUFJLElBQUksYUFBYTtBQUMxRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLDJCQUEyQjtBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVyLW1vdW50LmpzPzg0MTciXSwic291cmNlc0NvbnRlbnQiOlsiLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqICAgICAgICAgICAgICAgICAgICBQYXBlciBTaGFkZXJzICAgICAgICAgICAgICAgICAgICAqXG4gKiAgICAgICBodHRwczovL2dpdGh1Yi5jb20vcGFwZXItZGVzaWduL3NoYWRlcnMgICAgICAgKlxuICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICovXG5cbmltcG9ydCB7IHZlcnRleFNoYWRlclNvdXJjZSB9IGZyb20gXCIuL3ZlcnRleC1zaGFkZXIuanNcIjtcbmNvbnN0IERFRkFVTFRfTUFYX1BJWEVMX0NPVU5UID0gMTkyMCAqIDEwODAgKiA0O1xuY2xhc3MgU2hhZGVyTW91bnQge1xuICBwYXJlbnRFbGVtZW50O1xuICBjYW52YXNFbGVtZW50O1xuICBnbDtcbiAgcHJvZ3JhbSA9IG51bGw7XG4gIHVuaWZvcm1Mb2NhdGlvbnMgPSB7fTtcbiAgLyoqIFRoZSBmcmFnbWVudCBzaGFkZXIgdGhhdCB3ZSBhcmUgdXNpbmcgKi9cbiAgZnJhZ21lbnRTaGFkZXI7XG4gIC8qKiBTdG9yZXMgdGhlIFJBRiBmb3IgdGhlIHJlbmRlciBsb29wICovXG4gIHJhZklkID0gbnVsbDtcbiAgLyoqIFRpbWUgb2YgdGhlIGxhc3QgcmVuZGVyZWQgZnJhbWUgKi9cbiAgbGFzdFJlbmRlclRpbWUgPSAwO1xuICAvKiogVG90YWwgdGltZSB0aGF0IHdlIGhhdmUgcGxheWVkIGFueSBhbmltYXRpb24sIHBhc3NlZCBhcyBhIHVuaWZvcm0gdG8gdGhlIHNoYWRlciBmb3IgdGltZS1iYXNlZCBWRlggKi9cbiAgY3VycmVudEZyYW1lID0gMDtcbiAgLyoqIFRoZSBzcGVlZCB0aGF0IHdlIHByb2dyZXNzIHRocm91Z2ggYW5pbWF0aW9uIHRpbWUgKG11bHRpcGxpZXMgYnkgZGVsdGEgdGltZSBldmVyeSB1cGRhdGUpLiBBbGxvd3MgbmVnYXRpdmVzIHRvIHBsYXkgaW4gcmV2ZXJzZS4gSWYgc2V0IHRvIDAsIHJBRiB3aWxsIHN0b3AgZW50aXJlbHkgc28gc3RhdGljIHNoYWRlcnMgaGF2ZSBubyByZWN1cnJpbmcgcGVyZm9ybWFuY2UgY29zdHMgKi9cbiAgc3BlZWQgPSAwO1xuICAvKiogQWN0dWFsIHNwZWVkIHVzZWQgdGhhdCBhY2NvdW50cyBmb3IgZG9jdW1lbnQgdmlzaWJpbGl0eSAod2UgcGF1c2UgdGhlIHNoYWRlciBpZiB0aGUgdGFiIGlzIGhpZGRlbikgKi9cbiAgY3VycmVudFNwZWVkID0gMDtcbiAgLyoqIFVuaWZvcm1zIHRoYXQgYXJlIHByb3ZpZGVkIGJ5IHRoZSB1c2VyIGZvciB0aGUgc3BlY2lmaWMgc2hhZGVyIGJlaW5nIG1vdW50ZWQgKG5vdCBpbmNsdWRpbmcgdW5pZm9ybXMgdGhhdCB0aGlzIE1vdW50IGFkZHMsIGxpa2UgdGltZSBhbmQgcmVzb2x1dGlvbikgKi9cbiAgcHJvdmlkZWRVbmlmb3JtcztcbiAgLyoqIE5hbWVzIG9mIHRoZSB1bmlmb3JtcyB0aGF0IHNob3VsZCBoYXZlIG1pcG1hcHMgZ2VuZXJhdGVkIGZvciB0aGVtICovXG4gIG1pcG1hcHMgPSBbXTtcbiAgLyoqIEp1c3QgYSBzYW5pdHkgY2hlY2sgdG8gbWFrZSBzdXJlIGZyYW1lcyBkb24ndCBydW4gYWZ0ZXIgd2UncmUgZGlzcG9zZWQgKi9cbiAgaGFzQmVlbkRpc3Bvc2VkID0gZmFsc2U7XG4gIC8qKiBJZiB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgY2FudmFzIGhhcyBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IHJlbmRlciAqL1xuICByZXNvbHV0aW9uQ2hhbmdlZCA9IHRydWU7XG4gIC8qKiBTdG9yZSB0ZXh0dXJlcyB0aGF0IGFyZSBwcm92aWRlZCBieSB0aGUgdXNlciAqL1xuICB0ZXh0dXJlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIG1pblBpeGVsUmF0aW87XG4gIG1heFBpeGVsQ291bnQ7XG4gIGlzU2FmYXJpID0gaXNTYWZhcmkoKTtcbiAgdW5pZm9ybUNhY2hlID0ge307XG4gIHRleHR1cmVVbml0TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3RydWN0b3IocGFyZW50RWxlbWVudCwgZnJhZ21lbnRTaGFkZXIsIHVuaWZvcm1zLCB3ZWJHbENvbnRleHRBdHRyaWJ1dGVzLCBzcGVlZCA9IDAsIGZyYW1lID0gMCwgbWluUGl4ZWxSYXRpbyA9IDIsIG1heFBpeGVsQ291bnQgPSBERUZBVUxUX01BWF9QSVhFTF9DT1VOVCwgbWlwbWFwcyA9IFtdKSB7XG4gICAgaWYgKHBhcmVudEVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgdGhpcy5wYXJlbnRFbGVtZW50ID0gcGFyZW50RWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFwZXIgU2hhZGVyczogcGFyZW50IGVsZW1lbnQgbXVzdCBiZSBhbiBIVE1MRWxlbWVudFwiKTtcbiAgICB9XG4gICAgaWYgKCFkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwic3R5bGVbZGF0YS1wYXBlci1zaGFkZXJdXCIpKSB7XG4gICAgICBjb25zdCBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICBzdHlsZUVsZW1lbnQuaW5uZXJIVE1MID0gZGVmYXVsdFN0eWxlO1xuICAgICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtcGFwZXItc2hhZGVyXCIsIFwiXCIpO1xuICAgICAgZG9jdW1lbnQuaGVhZC5wcmVwZW5kKHN0eWxlRWxlbWVudCk7XG4gICAgfVxuICAgIGNvbnN0IGNhbnZhc0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIHRoaXMuY2FudmFzRWxlbWVudCA9IGNhbnZhc0VsZW1lbnQ7XG4gICAgdGhpcy5wYXJlbnRFbGVtZW50LnByZXBlbmQoY2FudmFzRWxlbWVudCk7XG4gICAgdGhpcy5mcmFnbWVudFNoYWRlciA9IGZyYWdtZW50U2hhZGVyO1xuICAgIHRoaXMucHJvdmlkZWRVbmlmb3JtcyA9IHVuaWZvcm1zO1xuICAgIHRoaXMubWlwbWFwcyA9IG1pcG1hcHM7XG4gICAgdGhpcy5jdXJyZW50RnJhbWUgPSBmcmFtZTtcbiAgICB0aGlzLm1pblBpeGVsUmF0aW8gPSBtaW5QaXhlbFJhdGlvO1xuICAgIHRoaXMubWF4UGl4ZWxDb3VudCA9IG1heFBpeGVsQ291bnQ7XG4gICAgY29uc3QgZ2wgPSBjYW52YXNFbGVtZW50LmdldENvbnRleHQoXCJ3ZWJnbDJcIiwgd2ViR2xDb250ZXh0QXR0cmlidXRlcyk7XG4gICAgaWYgKCFnbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFwZXIgU2hhZGVyczogV2ViR0wgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXJcIik7XG4gICAgfVxuICAgIHRoaXMuZ2wgPSBnbDtcbiAgICB0aGlzLmluaXRQcm9ncmFtKCk7XG4gICAgdGhpcy5zZXR1cFBvc2l0aW9uQXR0cmlidXRlKCk7XG4gICAgdGhpcy5zZXR1cFVuaWZvcm1zKCk7XG4gICAgdGhpcy5zZXRVbmlmb3JtVmFsdWVzKHRoaXMucHJvdmlkZWRVbmlmb3Jtcyk7XG4gICAgdGhpcy5zZXR1cFJlc2l6ZU9ic2VydmVyKCk7XG4gICAgdmlzdWFsVmlld3BvcnQ/LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5oYW5kbGVWaXN1YWxWaWV3cG9ydENoYW5nZSk7XG4gICAgdGhpcy5zZXRTcGVlZChzcGVlZCk7XG4gICAgdGhpcy5wYXJlbnRFbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtcGFwZXItc2hhZGVyXCIsIFwiXCIpO1xuICAgIHRoaXMucGFyZW50RWxlbWVudC5wYXBlclNoYWRlck1vdW50ID0gdGhpcztcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCB0aGlzLmhhbmRsZURvY3VtZW50VmlzaWJpbGl0eUNoYW5nZSk7XG4gIH1cbiAgaW5pdFByb2dyYW0gPSAoKSA9PiB7XG4gICAgY29uc3QgcHJvZ3JhbSA9IGNyZWF0ZVByb2dyYW0odGhpcy5nbCwgdmVydGV4U2hhZGVyU291cmNlLCB0aGlzLmZyYWdtZW50U2hhZGVyKTtcbiAgICBpZiAoIXByb2dyYW0pIHJldHVybjtcbiAgICB0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xuICB9O1xuICBzZXR1cFBvc2l0aW9uQXR0cmlidXRlID0gKCkgPT4ge1xuICAgIGNvbnN0IHBvc2l0aW9uQXR0cmlidXRlTG9jYXRpb24gPSB0aGlzLmdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgXCJhX3Bvc2l0aW9uXCIpO1xuICAgIGNvbnN0IHBvc2l0aW9uQnVmZmVyID0gdGhpcy5nbC5jcmVhdGVCdWZmZXIoKTtcbiAgICB0aGlzLmdsLmJpbmRCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsIHBvc2l0aW9uQnVmZmVyKTtcbiAgICBjb25zdCBwb3NpdGlvbnMgPSBbLTEsIC0xLCAxLCAtMSwgLTEsIDEsIC0xLCAxLCAxLCAtMSwgMSwgMV07XG4gICAgdGhpcy5nbC5idWZmZXJEYXRhKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KHBvc2l0aW9ucyksIHRoaXMuZ2wuU1RBVElDX0RSQVcpO1xuICAgIHRoaXMuZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb25BdHRyaWJ1dGVMb2NhdGlvbik7XG4gICAgdGhpcy5nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBvc2l0aW9uQXR0cmlidXRlTG9jYXRpb24sIDIsIHRoaXMuZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgfTtcbiAgc2V0dXBVbmlmb3JtcyA9ICgpID0+IHtcbiAgICBjb25zdCB1bmlmb3JtTG9jYXRpb25zID0ge1xuICAgICAgdV90aW1lOiB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIFwidV90aW1lXCIpLFxuICAgICAgdV9waXhlbFJhdGlvOiB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIFwidV9waXhlbFJhdGlvXCIpLFxuICAgICAgdV9yZXNvbHV0aW9uOiB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIFwidV9yZXNvbHV0aW9uXCIpXG4gICAgfTtcbiAgICBPYmplY3QuZW50cmllcyh0aGlzLnByb3ZpZGVkVW5pZm9ybXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgdW5pZm9ybUxvY2F0aW9uc1trZXldID0gdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBrZXkpO1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkge1xuICAgICAgICBjb25zdCBhc3BlY3RSYXRpb1VuaWZvcm1OYW1lID0gYCR7a2V5fUFzcGVjdFJhdGlvYDtcbiAgICAgICAgdW5pZm9ybUxvY2F0aW9uc1thc3BlY3RSYXRpb1VuaWZvcm1OYW1lXSA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgYXNwZWN0UmF0aW9Vbmlmb3JtTmFtZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy51bmlmb3JtTG9jYXRpb25zID0gdW5pZm9ybUxvY2F0aW9ucztcbiAgfTtcbiAgLyoqXG4gICAqIFRoZSBzY2FsZSB0aGF0IHdlIHNob3VsZCByZW5kZXIgYXQuXG4gICAqIC0gVXNlZCB0byB0YXJnZXQgMnggcmVuZGVyaW5nIGV2ZW4gb24gMXggc2NyZWVucyBmb3IgYmV0dGVyIGFudGlhbGlhc2luZ1xuICAgKiAtIFByZXZlbnRzIHRoZSB2aXJ0dWFsIHJlc29sdXRpb24gZnJvbSBnb2luZyBiZXlvbmQgdGhlIG1heGltdW0gcmVzb2x1dGlvblxuICAgKiAtIEFjY291bnRzIGZvciB0aGUgcGFnZSB6b29tIGxldmVsIHNvIHdlIHJlbmRlciBpbiBwaHlzaWNhbCBkZXZpY2UgcGl4ZWxzIHJhdGhlciB0aGFuIENTUyBwaXhlbHNcbiAgICovXG4gIHJlbmRlclNjYWxlID0gMTtcbiAgcGFyZW50V2lkdGggPSAwO1xuICBwYXJlbnRIZWlnaHQgPSAwO1xuICBwYXJlbnREZXZpY2VQaXhlbFdpZHRoID0gMDtcbiAgcGFyZW50RGV2aWNlUGl4ZWxIZWlnaHQgPSAwO1xuICBkZXZpY2VQaXhlbHNTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgcmVzaXplT2JzZXJ2ZXIgPSBudWxsO1xuICBzZXR1cFJlc2l6ZU9ic2VydmVyID0gKCkgPT4ge1xuICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKFtlbnRyeV0pID0+IHtcbiAgICAgIGlmIChlbnRyeT8uYm9yZGVyQm94U2l6ZVswXSkge1xuICAgICAgICBjb25zdCBwaHlzaWNhbFBpeGVsU2l6ZSA9IGVudHJ5LmRldmljZVBpeGVsQ29udGVudEJveFNpemU/LlswXTtcbiAgICAgICAgaWYgKHBoeXNpY2FsUGl4ZWxTaXplICE9PSB2b2lkIDApIHtcbiAgICAgICAgICB0aGlzLmRldmljZVBpeGVsc1N1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5wYXJlbnREZXZpY2VQaXhlbFdpZHRoID0gcGh5c2ljYWxQaXhlbFNpemUuaW5saW5lU2l6ZTtcbiAgICAgICAgICB0aGlzLnBhcmVudERldmljZVBpeGVsSGVpZ2h0ID0gcGh5c2ljYWxQaXhlbFNpemUuYmxvY2tTaXplO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFyZW50V2lkdGggPSBlbnRyeS5ib3JkZXJCb3hTaXplWzBdLmlubGluZVNpemU7XG4gICAgICAgIHRoaXMucGFyZW50SGVpZ2h0ID0gZW50cnkuYm9yZGVyQm94U2l6ZVswXS5ibG9ja1NpemU7XG4gICAgICB9XG4gICAgICB0aGlzLmhhbmRsZVJlc2l6ZSgpO1xuICAgIH0pO1xuICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLnBhcmVudEVsZW1lbnQpO1xuICB9O1xuICAvLyBWaXN1YWwgdmlld3BvcnQgcmVzaXplIGhhbmRsZXIsIG1haW5seSB1c2VkIHRvIHJlYWN0IHRvIGJyb3dzZXIgem9vbSBjaGFuZ2VzLlxuICAvLyBSZXNpemUgb2JzZXJ2ZXIgYnkgaXRzZWxmIGRvZXMgbm90IHJlYWN0IHRvIHBpbmNoIHpvb20sIGFuZCBhbHRob3VnaCBpdCB1c3VhbGx5XG4gIC8vIHJlYWN0cyB0byBjbGFzc2ljIGJyb3dzZXIgem9vbSwgaXQncyBub3QgZ3VhcmFudGVlZCBpbiBlZGdlIGNhc2VzLlxuICAvLyBTaW5jZSB0aW1pbmcgYmV0d2VlbiB2aXN1YWwgdmlld3BvcnQgY2hhbmdlcyBhbmQgcmVzaXplIG9ic2VydmVyIGlzIGNvbXBsZXhcbiAgLy8gYW5kIGJlY2F1c2Ugd2UnZCBsaWtlIHRvIGtub3cgdGhlIGRldmljZSBwaXhlbCBzaXplcyBvZiBlbGVtZW50cywgd2UganVzdCByZXN0YXJ0XG4gIC8vIHRoZSBvYnNlcnZlciB0byBnZXQgYSBndWFyYW50ZWVkIGZyZXNoIGNhbGxiYWNrIHJlZ2FyZGxlc3MgaWYgaXQgd291bGQgaGF2ZSB0cmlnZ2VyZWQgb3Igbm90LlxuICBoYW5kbGVWaXN1YWxWaWV3cG9ydENoYW5nZSA9ICgpID0+IHtcbiAgICB0aGlzLnJlc2l6ZU9ic2VydmVyPy5kaXNjb25uZWN0KCk7XG4gICAgdGhpcy5zZXR1cFJlc2l6ZU9ic2VydmVyKCk7XG4gIH07XG4gIC8qKiBSZXNpemUgaGFuZGxlciBmb3Igd2hlbiB0aGUgY29udGFpbmVyIGRpdiBjaGFuZ2VzIHNpemUgb3IgdGhlIG1heCBwaXhlbCBjb3VudCBjaGFuZ2VzIGFuZCB3ZSB3YW50IHRvIHJlc2l6ZSBvdXIgY2FudmFzIHRvIG1hdGNoICovXG4gIGhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcbiAgICBsZXQgdGFyZ2V0UGl4ZWxXaWR0aCA9IDA7XG4gICAgbGV0IHRhcmdldFBpeGVsSGVpZ2h0ID0gMDtcbiAgICBjb25zdCBkcHIgPSBNYXRoLm1heCgxLCB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgY29uc3QgcGluY2hab29tID0gdmlzdWFsVmlld3BvcnQ/LnNjYWxlID8/IDE7XG4gICAgaWYgKHRoaXMuZGV2aWNlUGl4ZWxzU3VwcG9ydGVkKSB7XG4gICAgICBjb25zdCBzY2FsZVRvTWVldE1pblBpeGVsUmF0aW8gPSBNYXRoLm1heCgxLCB0aGlzLm1pblBpeGVsUmF0aW8gLyBkcHIpO1xuICAgICAgdGFyZ2V0UGl4ZWxXaWR0aCA9IHRoaXMucGFyZW50RGV2aWNlUGl4ZWxXaWR0aCAqIHNjYWxlVG9NZWV0TWluUGl4ZWxSYXRpbyAqIHBpbmNoWm9vbTtcbiAgICAgIHRhcmdldFBpeGVsSGVpZ2h0ID0gdGhpcy5wYXJlbnREZXZpY2VQaXhlbEhlaWdodCAqIHNjYWxlVG9NZWV0TWluUGl4ZWxSYXRpbyAqIHBpbmNoWm9vbTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHRhcmdldFJlbmRlclNjYWxlID0gTWF0aC5tYXgoZHByLCB0aGlzLm1pblBpeGVsUmF0aW8pICogcGluY2hab29tO1xuICAgICAgaWYgKHRoaXMuaXNTYWZhcmkpIHtcbiAgICAgICAgY29uc3Qgem9vbUxldmVsID0gYmVzdEd1ZXNzQnJvd3Nlclpvb20oKTtcbiAgICAgICAgdGFyZ2V0UmVuZGVyU2NhbGUgKj0gTWF0aC5tYXgoMSwgem9vbUxldmVsKTtcbiAgICAgIH1cbiAgICAgIHRhcmdldFBpeGVsV2lkdGggPSBNYXRoLnJvdW5kKHRoaXMucGFyZW50V2lkdGgpICogdGFyZ2V0UmVuZGVyU2NhbGU7XG4gICAgICB0YXJnZXRQaXhlbEhlaWdodCA9IE1hdGgucm91bmQodGhpcy5wYXJlbnRIZWlnaHQpICogdGFyZ2V0UmVuZGVyU2NhbGU7XG4gICAgfVxuICAgIGNvbnN0IG1heFBpeGVsQ291bnRIZWFkcm9vbSA9IE1hdGguc3FydCh0aGlzLm1heFBpeGVsQ291bnQpIC8gTWF0aC5zcXJ0KHRhcmdldFBpeGVsV2lkdGggKiB0YXJnZXRQaXhlbEhlaWdodCk7XG4gICAgY29uc3Qgc2NhbGVUb01lZXRNYXhQaXhlbENvdW50ID0gTWF0aC5taW4oMSwgbWF4UGl4ZWxDb3VudEhlYWRyb29tKTtcbiAgICBjb25zdCBuZXdXaWR0aCA9IE1hdGgucm91bmQodGFyZ2V0UGl4ZWxXaWR0aCAqIHNjYWxlVG9NZWV0TWF4UGl4ZWxDb3VudCk7XG4gICAgY29uc3QgbmV3SGVpZ2h0ID0gTWF0aC5yb3VuZCh0YXJnZXRQaXhlbEhlaWdodCAqIHNjYWxlVG9NZWV0TWF4UGl4ZWxDb3VudCk7XG4gICAgY29uc3QgbmV3UmVuZGVyU2NhbGUgPSBuZXdXaWR0aCAvIE1hdGgucm91bmQodGhpcy5wYXJlbnRXaWR0aCk7XG4gICAgaWYgKHRoaXMuY2FudmFzRWxlbWVudC53aWR0aCAhPT0gbmV3V2lkdGggfHwgdGhpcy5jYW52YXNFbGVtZW50LmhlaWdodCAhPT0gbmV3SGVpZ2h0IHx8IHRoaXMucmVuZGVyU2NhbGUgIT09IG5ld1JlbmRlclNjYWxlKSB7XG4gICAgICB0aGlzLnJlbmRlclNjYWxlID0gbmV3UmVuZGVyU2NhbGU7XG4gICAgICB0aGlzLmNhbnZhc0VsZW1lbnQud2lkdGggPSBuZXdXaWR0aDtcbiAgICAgIHRoaXMuY2FudmFzRWxlbWVudC5oZWlnaHQgPSBuZXdIZWlnaHQ7XG4gICAgICB0aGlzLnJlc29sdXRpb25DaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMuZ2wudmlld3BvcnQoMCwgMCwgdGhpcy5nbC5jYW52YXMud2lkdGgsIHRoaXMuZ2wuY2FudmFzLmhlaWdodCk7XG4gICAgICB0aGlzLnJlbmRlcihwZXJmb3JtYW5jZS5ub3coKSk7XG4gICAgfVxuICB9O1xuICByZW5kZXIgPSAoY3VycmVudFRpbWUpID0+IHtcbiAgICBpZiAodGhpcy5oYXNCZWVuRGlzcG9zZWQpIHJldHVybjtcbiAgICBpZiAodGhpcy5wcm9ncmFtID09PSBudWxsKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJUcmllZCB0byByZW5kZXIgYmVmb3JlIHByb2dyYW0gb3IgZ2wgd2FzIGluaXRpYWxpemVkXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkdCA9IGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0UmVuZGVyVGltZTtcbiAgICB0aGlzLmxhc3RSZW5kZXJUaW1lID0gY3VycmVudFRpbWU7XG4gICAgaWYgKHRoaXMuY3VycmVudFNwZWVkICE9PSAwKSB7XG4gICAgICB0aGlzLmN1cnJlbnRGcmFtZSArPSBkdCAqIHRoaXMuY3VycmVudFNwZWVkO1xuICAgIH1cbiAgICB0aGlzLmdsLmNsZWFyKHRoaXMuZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgdGhpcy5nbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XG4gICAgdGhpcy5nbC51bmlmb3JtMWYodGhpcy51bmlmb3JtTG9jYXRpb25zLnVfdGltZSwgdGhpcy5jdXJyZW50RnJhbWUgKiAxZS0zKTtcbiAgICBpZiAodGhpcy5yZXNvbHV0aW9uQ2hhbmdlZCkge1xuICAgICAgdGhpcy5nbC51bmlmb3JtMmYodGhpcy51bmlmb3JtTG9jYXRpb25zLnVfcmVzb2x1dGlvbiwgdGhpcy5nbC5jYW52YXMud2lkdGgsIHRoaXMuZ2wuY2FudmFzLmhlaWdodCk7XG4gICAgICB0aGlzLmdsLnVuaWZvcm0xZih0aGlzLnVuaWZvcm1Mb2NhdGlvbnMudV9waXhlbFJhdGlvLCB0aGlzLnJlbmRlclNjYWxlKTtcbiAgICAgIHRoaXMucmVzb2x1dGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5nbC5kcmF3QXJyYXlzKHRoaXMuZ2wuVFJJQU5HTEVTLCAwLCA2KTtcbiAgICBpZiAodGhpcy5jdXJyZW50U3BlZWQgIT09IDApIHtcbiAgICAgIHRoaXMucmVxdWVzdFJlbmRlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJhZklkID0gbnVsbDtcbiAgICB9XG4gIH07XG4gIHJlcXVlc3RSZW5kZXIgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMucmFmSWQgIT09IG51bGwpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmFmSWQpO1xuICAgIH1cbiAgICB0aGlzLnJhZklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMucmVuZGVyKTtcbiAgfTtcbiAgLyoqIENyZWF0ZXMgYSB0ZXh0dXJlIGZyb20gYW4gaW1hZ2UgYW5kIHNldHMgaXQgaW50byBhIHVuaWZvcm0gdmFsdWUgKi9cbiAgc2V0VGV4dHVyZVVuaWZvcm0gPSAodW5pZm9ybU5hbWUsIGltYWdlKSA9PiB7XG4gICAgaWYgKCFpbWFnZS5jb21wbGV0ZSB8fCBpbWFnZS5uYXR1cmFsV2lkdGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUGFwZXIgU2hhZGVyczogaW1hZ2UgZm9yIHVuaWZvcm0gJHt1bmlmb3JtTmFtZX0gbXVzdCBiZSBmdWxseSBsb2FkZWRgKTtcbiAgICB9XG4gICAgY29uc3QgZXhpc3RpbmdUZXh0dXJlID0gdGhpcy50ZXh0dXJlcy5nZXQodW5pZm9ybU5hbWUpO1xuICAgIGlmIChleGlzdGluZ1RleHR1cmUpIHtcbiAgICAgIHRoaXMuZ2wuZGVsZXRlVGV4dHVyZShleGlzdGluZ1RleHR1cmUpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMudGV4dHVyZVVuaXRNYXAuaGFzKHVuaWZvcm1OYW1lKSkge1xuICAgICAgdGhpcy50ZXh0dXJlVW5pdE1hcC5zZXQodW5pZm9ybU5hbWUsIHRoaXMudGV4dHVyZVVuaXRNYXAuc2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IHRleHR1cmVVbml0ID0gdGhpcy50ZXh0dXJlVW5pdE1hcC5nZXQodW5pZm9ybU5hbWUpO1xuICAgIHRoaXMuZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkUwICsgdGV4dHVyZVVuaXQpO1xuICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLmdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICB0aGlzLmdsLmJpbmRUZXh0dXJlKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgdGhpcy5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGhpcy5nbC5URVhUVVJFX1dSQVBfUywgdGhpcy5nbC5DTEFNUF9UT19FREdFKTtcbiAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLmdsLlRFWFRVUkVfV1JBUF9ULCB0aGlzLmdsLkNMQU1QX1RPX0VER0UpO1xuICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMuZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB0aGlzLmdsLkxJTkVBUik7XG4gICAgdGhpcy5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGhpcy5nbC5URVhUVVJFX01BR19GSUxURVIsIHRoaXMuZ2wuTElORUFSKTtcbiAgICB0aGlzLmdsLnRleEltYWdlMkQodGhpcy5nbC5URVhUVVJFXzJELCAwLCB0aGlzLmdsLlJHQkEsIHRoaXMuZ2wuUkdCQSwgdGhpcy5nbC5VTlNJR05FRF9CWVRFLCBpbWFnZSk7XG4gICAgaWYgKHRoaXMubWlwbWFwcy5pbmNsdWRlcyh1bmlmb3JtTmFtZSkpIHtcbiAgICAgIHRoaXMuZ2wuZ2VuZXJhdGVNaXBtYXAodGhpcy5nbC5URVhUVVJFXzJEKTtcbiAgICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMuZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB0aGlzLmdsLkxJTkVBUl9NSVBNQVBfTElORUFSKTtcbiAgICB9XG4gICAgY29uc3QgZXJyb3IgPSB0aGlzLmdsLmdldEVycm9yKCk7XG4gICAgaWYgKGVycm9yICE9PSB0aGlzLmdsLk5PX0VSUk9SIHx8IHRleHR1cmUgPT09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJQYXBlciBTaGFkZXJzOiBXZWJHTCBlcnJvciB3aGVuIHVwbG9hZGluZyB0ZXh0dXJlOlwiLCBlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudGV4dHVyZXMuc2V0KHVuaWZvcm1OYW1lLCB0ZXh0dXJlKTtcbiAgICBjb25zdCBsb2NhdGlvbiA9IHRoaXMudW5pZm9ybUxvY2F0aW9uc1t1bmlmb3JtTmFtZV07XG4gICAgaWYgKGxvY2F0aW9uKSB7XG4gICAgICB0aGlzLmdsLnVuaWZvcm0xaShsb2NhdGlvbiwgdGV4dHVyZVVuaXQpO1xuICAgICAgY29uc3QgYXNwZWN0UmF0aW9Vbmlmb3JtTmFtZSA9IGAke3VuaWZvcm1OYW1lfUFzcGVjdFJhdGlvYDtcbiAgICAgIGNvbnN0IGFzcGVjdFJhdGlvTG9jYXRpb24gPSB0aGlzLnVuaWZvcm1Mb2NhdGlvbnNbYXNwZWN0UmF0aW9Vbmlmb3JtTmFtZV07XG4gICAgICBpZiAoYXNwZWN0UmF0aW9Mb2NhdGlvbikge1xuICAgICAgICBjb25zdCBhc3BlY3RSYXRpbyA9IGltYWdlLm5hdHVyYWxXaWR0aCAvIGltYWdlLm5hdHVyYWxIZWlnaHQ7XG4gICAgICAgIHRoaXMuZ2wudW5pZm9ybTFmKGFzcGVjdFJhdGlvTG9jYXRpb24sIGFzcGVjdFJhdGlvKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qKiBVdGlsaXR5OiByZWN1cnNpdmUgZXF1YWxpdHkgdGVzdCBmb3IgYWxsIHRoZSB1bmlmb3JtcyAqL1xuICBhcmVVbmlmb3JtVmFsdWVzRXF1YWwgPSAoYSwgYikgPT4ge1xuICAgIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSAmJiBBcnJheS5pc0FycmF5KGIpICYmIGEubGVuZ3RoID09PSBiLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGEuZXZlcnkoKHZhbCwgaSkgPT4gdGhpcy5hcmVVbmlmb3JtVmFsdWVzRXF1YWwodmFsLCBiW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgLyoqIFNldHMgdGhlIHByb3ZpZGVkIHVuaWZvcm0gdmFsdWVzIGludG8gdGhlIFdlYkdMIHByb2dyYW0sIGNhbiBiZSBhIHBhcnRpYWwgbGlzdCBvZiB1bmlmb3JtcyB0aGF0IGhhdmUgY2hhbmdlZCAqL1xuICBzZXRVbmlmb3JtVmFsdWVzID0gKHVwZGF0ZWRVbmlmb3JtcykgPT4ge1xuICAgIHRoaXMuZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xuICAgIE9iamVjdC5lbnRyaWVzKHVwZGF0ZWRVbmlmb3JtcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBsZXQgY2FjaGVWYWx1ZSA9IHZhbHVlO1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkge1xuICAgICAgICBjYWNoZVZhbHVlID0gYCR7dmFsdWUuc3JjLnNsaWNlKDAsIDIwMCl9fCR7dmFsdWUubmF0dXJhbFdpZHRofXgke3ZhbHVlLm5hdHVyYWxIZWlnaHR9YDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmFyZVVuaWZvcm1WYWx1ZXNFcXVhbCh0aGlzLnVuaWZvcm1DYWNoZVtrZXldLCBjYWNoZVZhbHVlKSkgcmV0dXJuO1xuICAgICAgdGhpcy51bmlmb3JtQ2FjaGVba2V5XSA9IGNhY2hlVmFsdWU7XG4gICAgICBjb25zdCBsb2NhdGlvbiA9IHRoaXMudW5pZm9ybUxvY2F0aW9uc1trZXldO1xuICAgICAgaWYgKCFsb2NhdGlvbikge1xuICAgICAgICBjb25zb2xlLndhcm4oYFVuaWZvcm0gbG9jYXRpb24gZm9yICR7a2V5fSBub3QgZm91bmRgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkge1xuICAgICAgICB0aGlzLnNldFRleHR1cmVVbmlmb3JtKGtleSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBsZXQgZmxhdEFycmF5ID0gbnVsbDtcbiAgICAgICAgbGV0IHZhbHVlTGVuZ3RoID0gbnVsbDtcbiAgICAgICAgaWYgKHZhbHVlWzBdICE9PSB2b2lkIDAgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZVswXSkpIHtcbiAgICAgICAgICBjb25zdCBmaXJzdENoaWxkTGVuZ3RoID0gdmFsdWVbMF0ubGVuZ3RoO1xuICAgICAgICAgIGlmICh2YWx1ZS5ldmVyeSgoYXJyKSA9PiBhcnIubGVuZ3RoID09PSBmaXJzdENoaWxkTGVuZ3RoKSkge1xuICAgICAgICAgICAgZmxhdEFycmF5ID0gdmFsdWUuZmxhdCgpO1xuICAgICAgICAgICAgdmFsdWVMZW5ndGggPSBmaXJzdENoaWxkTGVuZ3RoO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYEFsbCBjaGlsZCBhcnJheXMgbXVzdCBiZSB0aGUgc2FtZSBsZW5ndGggZm9yICR7a2V5fWApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmbGF0QXJyYXkgPSB2YWx1ZTtcbiAgICAgICAgICB2YWx1ZUxlbmd0aCA9IGZsYXRBcnJheS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh2YWx1ZUxlbmd0aCkge1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHRoaXMuZ2wudW5pZm9ybTJmdihsb2NhdGlvbiwgZmxhdEFycmF5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHRoaXMuZ2wudW5pZm9ybTNmdihsb2NhdGlvbiwgZmxhdEFycmF5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHRoaXMuZ2wudW5pZm9ybTRmdihsb2NhdGlvbiwgZmxhdEFycmF5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHRoaXMuZ2wudW5pZm9ybU1hdHJpeDNmdihsb2NhdGlvbiwgZmFsc2UsIGZsYXRBcnJheSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgdGhpcy5nbC51bmlmb3JtTWF0cml4NGZ2KGxvY2F0aW9uLCBmYWxzZSwgZmxhdEFycmF5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFVuc3VwcG9ydGVkIHVuaWZvcm0gYXJyYXkgbGVuZ3RoOiAke3ZhbHVlTGVuZ3RofWApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICB0aGlzLmdsLnVuaWZvcm0xZihsb2NhdGlvbiwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIHRoaXMuZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCB2YWx1ZSA/IDEgOiAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgVW5zdXBwb3J0ZWQgdW5pZm9ybSB0eXBlIGZvciAke2tleX06ICR7dHlwZW9mIHZhbHVlfWApO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICAvKiogR2V0cyB0aGUgY3VycmVudCB0b3RhbCBhbmltYXRpb24gdGltZSBmcm9tIDBtcyAqL1xuICBnZXRDdXJyZW50RnJhbWUgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudEZyYW1lO1xuICB9O1xuICAvKiogU2V0IGEgZnJhbWUgdG8gZ2V0IGEgZGV0ZXJtaW5pc3RpYyByZXN1bHQsIGZyYW1lcyBhcmUgbGl0ZXJhbGx5IGp1c3QgbWlsbGlzZWNvbmRzIGZyb20gemVybyBzaW5jZSB0aGUgYW5pbWF0aW9uIHN0YXJ0ZWQgKi9cbiAgc2V0RnJhbWUgPSAobmV3RnJhbWUpID0+IHtcbiAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IG5ld0ZyYW1lO1xuICAgIHRoaXMubGFzdFJlbmRlclRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB0aGlzLnJlbmRlcihwZXJmb3JtYW5jZS5ub3coKSk7XG4gIH07XG4gIC8qKiBTZXQgYW4gYW5pbWF0aW9uIHNwZWVkIChvciAwIHRvIHN0b3AgYW5pbWF0aW9uKSAqL1xuICBzZXRTcGVlZCA9IChuZXdTcGVlZCA9IDEpID0+IHtcbiAgICB0aGlzLnNwZWVkID0gbmV3U3BlZWQ7XG4gICAgdGhpcy5zZXRDdXJyZW50U3BlZWQoZG9jdW1lbnQuaGlkZGVuID8gMCA6IG5ld1NwZWVkKTtcbiAgfTtcbiAgc2V0Q3VycmVudFNwZWVkID0gKG5ld1NwZWVkKSA9PiB7XG4gICAgdGhpcy5jdXJyZW50U3BlZWQgPSBuZXdTcGVlZDtcbiAgICBpZiAodGhpcy5yYWZJZCA9PT0gbnVsbCAmJiBuZXdTcGVlZCAhPT0gMCkge1xuICAgICAgdGhpcy5sYXN0UmVuZGVyVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgdGhpcy5yYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnJlbmRlcik7XG4gICAgfVxuICAgIGlmICh0aGlzLnJhZklkICE9PSBudWxsICYmIG5ld1NwZWVkID09PSAwKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJhZklkKTtcbiAgICAgIHRoaXMucmFmSWQgPSBudWxsO1xuICAgIH1cbiAgfTtcbiAgLyoqIFNldCB0aGUgbWF4aW11bSBwaXhlbCBjb3VudCBmb3IgdGhlIHNoYWRlciwgdGhpcyB3aWxsIGxpbWl0IHRoZSBudW1iZXIgb2YgcGl4ZWxzIHRoYXQgd2lsbCBiZSByZW5kZXJlZCAqL1xuICBzZXRNYXhQaXhlbENvdW50ID0gKG5ld01heFBpeGVsQ291bnQgPSBERUZBVUxUX01BWF9QSVhFTF9DT1VOVCkgPT4ge1xuICAgIHRoaXMubWF4UGl4ZWxDb3VudCA9IG5ld01heFBpeGVsQ291bnQ7XG4gICAgdGhpcy5oYW5kbGVSZXNpemUoKTtcbiAgfTtcbiAgLyoqIFNldCB0aGUgbWluaW11bSBwaXhlbCByYXRpbyBmb3IgdGhlIHNoYWRlciAqL1xuICBzZXRNaW5QaXhlbFJhdGlvID0gKG5ld01pblBpeGVsUmF0aW8gPSAyKSA9PiB7XG4gICAgdGhpcy5taW5QaXhlbFJhdGlvID0gbmV3TWluUGl4ZWxSYXRpbztcbiAgICB0aGlzLmhhbmRsZVJlc2l6ZSgpO1xuICB9O1xuICAvKiogVXBkYXRlIHRoZSB1bmlmb3JtcyB0aGF0IGFyZSBwcm92aWRlZCBieSB0aGUgb3V0c2lkZSBzaGFkZXIsIGNhbiBiZSBhIHBhcnRpYWwgc2V0IHdpdGggb25seSB0aGUgdW5pZm9ybXMgdGhhdCBoYXZlIGNoYW5nZWQgKi9cbiAgc2V0VW5pZm9ybXMgPSAobmV3VW5pZm9ybXMpID0+IHtcbiAgICB0aGlzLnNldFVuaWZvcm1WYWx1ZXMobmV3VW5pZm9ybXMpO1xuICAgIHRoaXMucHJvdmlkZWRVbmlmb3JtcyA9IHsgLi4udGhpcy5wcm92aWRlZFVuaWZvcm1zLCAuLi5uZXdVbmlmb3JtcyB9O1xuICAgIHRoaXMucmVuZGVyKHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgfTtcbiAgaGFuZGxlRG9jdW1lbnRWaXNpYmlsaXR5Q2hhbmdlID0gKCkgPT4ge1xuICAgIHRoaXMuc2V0Q3VycmVudFNwZWVkKGRvY3VtZW50LmhpZGRlbiA/IDAgOiB0aGlzLnNwZWVkKTtcbiAgfTtcbiAgLyoqIERpc3Bvc2Ugb2YgdGhlIHNoYWRlciBtb3VudCwgY2xlYW5pbmcgdXAgYWxsIG9mIHRoZSBXZWJHTCByZXNvdXJjZXMgKi9cbiAgZGlzcG9zZSA9ICgpID0+IHtcbiAgICB0aGlzLmhhc0JlZW5EaXNwb3NlZCA9IHRydWU7XG4gICAgaWYgKHRoaXMucmFmSWQgIT09IG51bGwpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmFmSWQpO1xuICAgICAgdGhpcy5yYWZJZCA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmdsICYmIHRoaXMucHJvZ3JhbSkge1xuICAgICAgdGhpcy50ZXh0dXJlcy5mb3JFYWNoKCh0ZXh0dXJlKSA9PiB7XG4gICAgICAgIHRoaXMuZ2wuZGVsZXRlVGV4dHVyZSh0ZXh0dXJlKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy50ZXh0dXJlcy5jbGVhcigpO1xuICAgICAgdGhpcy5nbC5kZWxldGVQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XG4gICAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xuICAgICAgdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLCBudWxsKTtcbiAgICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLmdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBudWxsKTtcbiAgICAgIHRoaXMuZ2wuYmluZFJlbmRlcmJ1ZmZlcih0aGlzLmdsLlJFTkRFUkJVRkZFUiwgbnVsbCk7XG4gICAgICB0aGlzLmdsLmJpbmRGcmFtZWJ1ZmZlcih0aGlzLmdsLkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgICAgIHRoaXMuZ2wuZ2V0RXJyb3IoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IG51bGw7XG4gICAgfVxuICAgIHZpc3VhbFZpZXdwb3J0Py5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMuaGFuZGxlVmlzdWFsVmlld3BvcnRDaGFuZ2UpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIHRoaXMuaGFuZGxlRG9jdW1lbnRWaXNpYmlsaXR5Q2hhbmdlKTtcbiAgICB0aGlzLnVuaWZvcm1Mb2NhdGlvbnMgPSB7fTtcbiAgICB0aGlzLmNhbnZhc0VsZW1lbnQucmVtb3ZlKCk7XG4gICAgZGVsZXRlIHRoaXMucGFyZW50RWxlbWVudC5wYXBlclNoYWRlck1vdW50O1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU2hhZGVyKGdsLCB0eXBlLCBzb3VyY2UpIHtcbiAgY29uc3Qgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHR5cGUpO1xuICBpZiAoIXNoYWRlcikgcmV0dXJuIG51bGw7XG4gIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNvdXJjZSk7XG4gIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcbiAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiQW4gZXJyb3Igb2NjdXJyZWQgY29tcGlsaW5nIHRoZSBzaGFkZXJzOiBcIiArIGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKSk7XG4gICAgZ2wuZGVsZXRlU2hhZGVyKHNoYWRlcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHNoYWRlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVByb2dyYW0oZ2wsIHZlcnRleFNoYWRlclNvdXJjZTIsIGZyYWdtZW50U2hhZGVyU291cmNlKSB7XG4gIGNvbnN0IGZvcm1hdCA9IGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5GUkFHTUVOVF9TSEFERVIsIGdsLk1FRElVTV9GTE9BVCk7XG4gIGNvbnN0IHByZWNpc2lvbiA9IGZvcm1hdCA/IGZvcm1hdC5wcmVjaXNpb24gOiBudWxsO1xuICBpZiAocHJlY2lzaW9uICYmIHByZWNpc2lvbiA8IDIzKSB7XG4gICAgdmVydGV4U2hhZGVyU291cmNlMiA9IHZlcnRleFNoYWRlclNvdXJjZTIucmVwbGFjZSgvcHJlY2lzaW9uXFxzKyhsb3dwfG1lZGl1bXApXFxzK2Zsb2F0Oy9nLCBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcIik7XG4gICAgZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBmcmFnbWVudFNoYWRlclNvdXJjZS5yZXBsYWNlKC9wcmVjaXNpb25cXHMrKGxvd3B8bWVkaXVtcClcXHMrZmxvYXQvZywgXCJwcmVjaXNpb24gaGlnaHAgZmxvYXRcIikucmVwbGFjZSgvXFxiKHVuaWZvcm18dmFyeWluZ3xhdHRyaWJ1dGUpXFxzKyhsb3dwfG1lZGl1bXApXFxzKyhcXHcrKS9nLCBcIiQxIGhpZ2hwICQzXCIpO1xuICB9XG4gIGNvbnN0IHZlcnRleFNoYWRlciA9IGNyZWF0ZVNoYWRlcihnbCwgZ2wuVkVSVEVYX1NIQURFUiwgdmVydGV4U2hhZGVyU291cmNlMik7XG4gIGNvbnN0IGZyYWdtZW50U2hhZGVyID0gY3JlYXRlU2hhZGVyKGdsLCBnbC5GUkFHTUVOVF9TSEFERVIsIGZyYWdtZW50U2hhZGVyU291cmNlKTtcbiAgaWYgKCF2ZXJ0ZXhTaGFkZXIgfHwgIWZyYWdtZW50U2hhZGVyKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgaWYgKCFwcm9ncmFtKSByZXR1cm4gbnVsbDtcbiAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcik7XG4gIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XG4gIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuICBpZiAoIWdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKSB7XG4gICAgY29uc29sZS5lcnJvcihcIlVuYWJsZSB0byBpbml0aWFsaXplIHRoZSBzaGFkZXIgcHJvZ3JhbTogXCIgKyBnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKSk7XG4gICAgZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICBnbC5kZWxldGVTaGFkZXIodmVydGV4U2hhZGVyKTtcbiAgICBnbC5kZWxldGVTaGFkZXIoZnJhZ21lbnRTaGFkZXIpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdsLmRldGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpO1xuICBnbC5kZXRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xuICBnbC5kZWxldGVTaGFkZXIodmVydGV4U2hhZGVyKTtcbiAgZ2wuZGVsZXRlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcbiAgcmV0dXJuIHByb2dyYW07XG59XG5jb25zdCBkZWZhdWx0U3R5bGUgPSBgQGxheWVyIHBhcGVyLXNoYWRlcnMge1xuICA6d2hlcmUoW2RhdGEtcGFwZXItc2hhZGVyXSkge1xuICAgIGlzb2xhdGlvbjogaXNvbGF0ZTtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG5cbiAgICAmIGNhbnZhcyB7XG4gICAgICBjb250YWluOiBzdHJpY3Q7XG4gICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIGluc2V0OiAwO1xuICAgICAgei1pbmRleDogLTE7XG4gICAgICB3aWR0aDogMTAwJTtcbiAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgIGJvcmRlci1yYWRpdXM6IGluaGVyaXQ7XG4gICAgICBjb3JuZXItc2hhcGU6IGluaGVyaXQ7XG4gICAgfVxuICB9XG59YDtcbmZ1bmN0aW9uIGlzUGFwZXJTaGFkZXJFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuIFwicGFwZXJTaGFkZXJNb3VudFwiIGluIGVsZW1lbnQ7XG59XG5mdW5jdGlvbiBpc1NhZmFyaSgpIHtcbiAgY29uc3QgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiB1YS5pbmNsdWRlcyhcInNhZmFyaVwiKSAmJiAhdWEuaW5jbHVkZXMoXCJjaHJvbWVcIikgJiYgIXVhLmluY2x1ZGVzKFwiYW5kcm9pZFwiKTtcbn1cbmZ1bmN0aW9uIGJlc3RHdWVzc0Jyb3dzZXJab29tKCkge1xuICBjb25zdCB2aWV3cG9ydFNjYWxlID0gdmlzdWFsVmlld3BvcnQ/LnNjYWxlID8/IDE7XG4gIGNvbnN0IHZpZXdwb3J0V2lkdGggPSB2aXN1YWxWaWV3cG9ydD8ud2lkdGggPz8gd2luZG93LmlubmVyV2lkdGg7XG4gIGNvbnN0IHNjcm9sbGJhcldpZHRoID0gd2luZG93LmlubmVyV2lkdGggLSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gIGNvbnN0IGlubmVyV2lkdGggPSB2aWV3cG9ydFNjYWxlICogdmlld3BvcnRXaWR0aCArIHNjcm9sbGJhcldpZHRoO1xuICBjb25zdCByYXRpbyA9IG91dGVyV2lkdGggLyBpbm5lcldpZHRoO1xuICBjb25zdCB6b29tUGVyY2VudGFnZVJvdW5kZWQgPSBNYXRoLnJvdW5kKDEwMCAqIHJhdGlvKTtcbiAgaWYgKHpvb21QZXJjZW50YWdlUm91bmRlZCAlIDUgPT09IDApIHtcbiAgICByZXR1cm4gem9vbVBlcmNlbnRhZ2VSb3VuZGVkIC8gMTAwO1xuICB9XG4gIGlmICh6b29tUGVyY2VudGFnZVJvdW5kZWQgPT09IDMzKSB7XG4gICAgcmV0dXJuIDEgLyAzO1xuICB9XG4gIGlmICh6b29tUGVyY2VudGFnZVJvdW5kZWQgPT09IDY3KSB7XG4gICAgcmV0dXJuIDIgLyAzO1xuICB9XG4gIGlmICh6b29tUGVyY2VudGFnZVJvdW5kZWQgPT09IDEzMykge1xuICAgIHJldHVybiA0IC8gMztcbiAgfVxuICByZXR1cm4gcmF0aW87XG59XG5leHBvcnQge1xuICBTaGFkZXJNb3VudCxcbiAgaXNQYXBlclNoYWRlckVsZW1lbnRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGFkZXItbW91bnQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/shader-mount.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/shader-sizing.js":
/*!******************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/shader-sizing.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShaderFitOptions: () => (/* binding */ ShaderFitOptions),\n/* harmony export */   defaultObjectSizing: () => (/* binding */ defaultObjectSizing),\n/* harmony export */   defaultPatternSizing: () => (/* binding */ defaultPatternSizing),\n/* harmony export */   drawSizingHelpers: () => (/* binding */ drawSizingHelpers),\n/* harmony export */   sizingDebugVariablesDeclaration: () => (/* binding */ sizingDebugVariablesDeclaration),\n/* harmony export */   sizingUV: () => (/* binding */ sizingUV),\n/* harmony export */   sizingUniformsDeclaration: () => (/* binding */ sizingUniformsDeclaration),\n/* harmony export */   sizingVariablesDeclaration: () => (/* binding */ sizingVariablesDeclaration)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nconst sizingVariablesDeclaration = `\nin vec2 v_objectUV;\nin vec2 v_responsiveUV;\nin vec2 v_responsiveBoxGivenSize;\nin vec2 v_patternUV;\nin vec2 v_imageUV;`;\nconst sizingDebugVariablesDeclaration = `\nin vec2 v_objectBoxSize;\nin vec2 v_objectHelperBox;\nin vec2 v_responsiveBoxSize;\nin vec2 v_responsiveHelperBox;\nin vec2 v_patternBoxSize;\nin vec2 v_patternHelperBox;`;\nconst sizingUniformsDeclaration = `\nuniform float u_originX;\nuniform float u_originY;\nuniform float u_worldWidth;\nuniform float u_worldHeight;\nuniform float u_fit;\n\nuniform float u_scale;\nuniform float u_rotation;\nuniform float u_offsetX;\nuniform float u_offsetY;`;\nconst sizingUV = `\n\n  vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n  #ifdef USE_PIXELIZATION\n    float pxSize = u_pxSize * u_pixelRatio;\n    vec2 pxSizeUv = gl_FragCoord.xy;\n    pxSizeUv -= .5 * u_resolution;\n    pxSizeUv /= pxSize;\n    uv = floor(pxSizeUv) * pxSize / u_resolution.xy;    \n    uv += .5;\n  #endif\n  uv -= .5;\n\n  \n  // ===================================================\n  // sizing params shared between objects and patterns\n  \n  vec2 boxOrigin = vec2(.5 - u_originX, u_originY - .5);\n  vec2 givenBoxSize = vec2(u_worldWidth, u_worldHeight);\n  givenBoxSize = max(givenBoxSize, vec2(1.)) * u_pixelRatio;\n  float r = u_rotation * 3.14159265358979323846 / 180.;\n  mat2 graphicRotation = mat2(cos(r), sin(r), -sin(r), cos(r));\n  vec2 graphicOffset = vec2(-u_offsetX, u_offsetY);\n\n  \n  // ===================================================\n  // Sizing api for objects (graphics with fixed ratio)\n\n  #ifdef USE_OBJECT_SIZING\n    float fixedRatio = 1.;\n    vec2 fixedRatioBoxGivenSize = vec2(\n      (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n      (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n    );\n    vec2 objectBoxSize = vec2(0.);\n    // fit = none\n    objectBoxSize.x = fixedRatio * min(fixedRatioBoxGivenSize.x / fixedRatio, fixedRatioBoxGivenSize.y);\n    if (u_fit == 1.) { // fit = contain\n      objectBoxSize.x = fixedRatio * min(u_resolution.x / fixedRatio, u_resolution.y);\n    } else if (u_fit == 2.) {  // fit = cover\n      objectBoxSize.x = fixedRatio * max(u_resolution.x / fixedRatio, u_resolution.y);\n    }\n    objectBoxSize.y = objectBoxSize.x / fixedRatio;\n    vec2 objectWorldScale = u_resolution.xy / objectBoxSize;\n  \n    #ifdef ADD_HELPERS\n      vec2 objectHelperBox = gl_FragCoord.xy / u_resolution.xy;\n      objectHelperBox -= .5;\n      objectHelperBox *= objectWorldScale;\n      objectHelperBox += boxOrigin * (objectWorldScale - 1.);  \n    #endif\n  \n    vec2 objectUV = uv;\n    objectUV *= objectWorldScale;\n    objectUV += boxOrigin * (objectWorldScale - 1.);\n    objectUV += vec2(-u_offsetX, u_offsetY);\n    objectUV /= u_scale;\n    objectUV = graphicRotation * objectUV;\n  #endif\n  \n  // ===================================================\n \n  // ===================================================\n  // Sizing api for patterns (graphics respecting u_worldWidth / u_worldHeight ratio)\n  \n  #ifdef USE_PATTERN_SIZING\n    float patternBoxRatio = givenBoxSize.x / givenBoxSize.y;\n    vec2 patternBoxGivenSize = vec2(\n      (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n      (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n    );\n    vec2 patternBoxSize = vec2(0.);\n    // fit = none\n    patternBoxSize.x = patternBoxRatio * min(patternBoxGivenSize.x / patternBoxRatio, patternBoxGivenSize.y);\n    float patternWorldNoFitBoxWidth = patternBoxSize.x;\n    if (u_fit == 1.) {  // fit = contain\n      patternBoxSize.x = patternBoxRatio * min(u_resolution.x / patternBoxRatio, u_resolution.y);\n    } else if (u_fit == 2.) {  // fit = cover\n      patternBoxSize.x = patternBoxRatio * max(u_resolution.x / patternBoxRatio, u_resolution.y);\n    }\n    patternBoxSize.y = patternBoxSize.x / patternBoxRatio;\n    vec2 patternWorldScale = u_resolution.xy / patternBoxSize;\n  \n    #ifdef ADD_HELPERS  \n      vec2 patternHelperBox = gl_FragCoord.xy / u_resolution.xy;\n      patternHelperBox -= .5;\n      patternHelperBox *= patternWorldScale;\n      patternHelperBox += boxOrigin * (patternWorldScale - 1.);  \n    #endif\n  \n    vec2 patternUV = uv;\n    patternUV += vec2(-u_offsetX, u_offsetY) / patternWorldScale;\n    patternUV += boxOrigin;\n    patternUV -= boxOrigin / patternWorldScale;\n    patternUV *= u_resolution.xy;\n    patternUV /= u_pixelRatio;\n    if (u_fit > 0.) {\n      patternUV *= (patternWorldNoFitBoxWidth / patternBoxSize.x);\n    }\n    patternUV /= u_scale;\n    patternUV = graphicRotation * patternUV;\n    patternUV += boxOrigin / patternWorldScale;\n    patternUV -= boxOrigin;\n    patternUV += .5;\n  #endif\n    \n  // ===================================================\n \n  // ===================================================\n  // Sizing api for image filters\n  \n  #ifdef USE_IMAGE_SIZING\n\n    vec2 imageBoxSize;\n    if (u_fit == 1.) { // contain\n      imageBoxSize.x = min(u_resolution.x / u_imageAspectRatio, u_resolution.y) * u_imageAspectRatio;\n    } else if (u_fit == 2.) { // cover\n      imageBoxSize.x = max(u_resolution.x / u_imageAspectRatio, u_resolution.y) * u_imageAspectRatio;\n    } else {\n      imageBoxSize.x = min(10.0, 10.0 / u_imageAspectRatio * u_imageAspectRatio);\n    }\n    imageBoxSize.y = imageBoxSize.x / u_imageAspectRatio;\n    vec2 imageBoxScale = u_resolution.xy / imageBoxSize;\n\n    #ifdef ADD_HELPERS\n      vec2 imageHelperBox = uv;\n      imageHelperBox *= imageBoxScale;\n      imageHelperBox += boxOrigin * (imageBoxScale - 1.);\n    #endif\n\n    vec2 imageUV = uv;\n    imageUV *= imageBoxScale;\n    imageUV += boxOrigin * (imageBoxScale - 1.);\n    imageUV += graphicOffset;\n    imageUV /= u_scale;\n    imageUV.x *= u_imageAspectRatio;\n    imageUV = graphicRotation * imageUV;\n    imageUV.x /= u_imageAspectRatio;\n    \n    imageUV += .5;\n    imageUV.y = 1. - imageUV.y;\n  #endif\n`;\nconst drawSizingHelpers = `\n  vec2 worldBoxDist = abs(helperBox);\n  float boxStroke = (step(max(worldBoxDist.x, worldBoxDist.y), .5) - step(max(worldBoxDist.x, worldBoxDist.y), .495));\n  color.rgb = mix(color.rgb, vec3(1., 0., 0.), boxStroke);\n  opacity += boxStroke;\n\n  vec2 boxOriginCopy = vec2(.5 - u_originX, u_originY - .5);\n  vec2 boxOriginDist = helperBox + boxOriginCopy;\n  boxOriginDist.x *= (boxSize.x / boxSize.y);\n  float boxOriginPoint = 1. - smoothstep(0., .05, length(boxOriginDist));\n  \n  vec2 graphicOriginPointDist = helperBox + vec2(-u_offsetX, u_offsetY);\n  graphicOriginPointDist.x *= (boxSize.x / boxSize.y);\n  float graphicOriginPoint = 1. - smoothstep(0., .05, length(graphicOriginPointDist));\n  \n  color.rgb = mix(color.rgb, vec3(0., 1., 0.), boxOriginPoint);\n  opacity += boxOriginPoint;\n  color.rgb = mix(color.rgb, vec3(0., 0., 1.), graphicOriginPoint);\n  opacity += graphicOriginPoint;\n`;\nconst defaultObjectSizing = {\n  fit: \"contain\",\n  scale: 1,\n  rotation: 0,\n  offsetX: 0,\n  offsetY: 0,\n  originX: 0.5,\n  originY: 0.5,\n  worldWidth: 0,\n  worldHeight: 0\n};\nconst defaultPatternSizing = {\n  fit: \"none\",\n  scale: 1,\n  rotation: 0,\n  offsetX: 0,\n  offsetY: 0,\n  originX: 0.5,\n  originY: 0.5,\n  worldWidth: 0,\n  worldHeight: 0\n};\nconst ShaderFitOptions = {\n  none: 0,\n  contain: 1,\n  cover: 2\n};\n\n//# sourceMappingURL=shader-sizing.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVyLXNpemluZy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLE1BQU0seUJBQXlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxNQUFNLHlCQUF5QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLE1BQU0sd0JBQXdCO0FBQzlCO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFVRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9AcGFwZXItZGVzaWduL3NoYWRlcnMvZGlzdC9zaGFkZXItc2l6aW5nLmpzPzZiMWMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqICAgICAgICAgICAgICAgICAgICBQYXBlciBTaGFkZXJzICAgICAgICAgICAgICAgICAgICAqXG4gKiAgICAgICBodHRwczovL2dpdGh1Yi5jb20vcGFwZXItZGVzaWduL3NoYWRlcnMgICAgICAgKlxuICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICovXG5cbmNvbnN0IHNpemluZ1ZhcmlhYmxlc0RlY2xhcmF0aW9uID0gYFxuaW4gdmVjMiB2X29iamVjdFVWO1xuaW4gdmVjMiB2X3Jlc3BvbnNpdmVVVjtcbmluIHZlYzIgdl9yZXNwb25zaXZlQm94R2l2ZW5TaXplO1xuaW4gdmVjMiB2X3BhdHRlcm5VVjtcbmluIHZlYzIgdl9pbWFnZVVWO2A7XG5jb25zdCBzaXppbmdEZWJ1Z1ZhcmlhYmxlc0RlY2xhcmF0aW9uID0gYFxuaW4gdmVjMiB2X29iamVjdEJveFNpemU7XG5pbiB2ZWMyIHZfb2JqZWN0SGVscGVyQm94O1xuaW4gdmVjMiB2X3Jlc3BvbnNpdmVCb3hTaXplO1xuaW4gdmVjMiB2X3Jlc3BvbnNpdmVIZWxwZXJCb3g7XG5pbiB2ZWMyIHZfcGF0dGVybkJveFNpemU7XG5pbiB2ZWMyIHZfcGF0dGVybkhlbHBlckJveDtgO1xuY29uc3Qgc2l6aW5nVW5pZm9ybXNEZWNsYXJhdGlvbiA9IGBcbnVuaWZvcm0gZmxvYXQgdV9vcmlnaW5YO1xudW5pZm9ybSBmbG9hdCB1X29yaWdpblk7XG51bmlmb3JtIGZsb2F0IHVfd29ybGRXaWR0aDtcbnVuaWZvcm0gZmxvYXQgdV93b3JsZEhlaWdodDtcbnVuaWZvcm0gZmxvYXQgdV9maXQ7XG5cbnVuaWZvcm0gZmxvYXQgdV9zY2FsZTtcbnVuaWZvcm0gZmxvYXQgdV9yb3RhdGlvbjtcbnVuaWZvcm0gZmxvYXQgdV9vZmZzZXRYO1xudW5pZm9ybSBmbG9hdCB1X29mZnNldFk7YDtcbmNvbnN0IHNpemluZ1VWID0gYFxuXG4gIHZlYzIgdXYgPSBnbF9GcmFnQ29vcmQueHkgLyB1X3Jlc29sdXRpb24ueHk7XG4gICNpZmRlZiBVU0VfUElYRUxJWkFUSU9OXG4gICAgZmxvYXQgcHhTaXplID0gdV9weFNpemUgKiB1X3BpeGVsUmF0aW87XG4gICAgdmVjMiBweFNpemVVdiA9IGdsX0ZyYWdDb29yZC54eTtcbiAgICBweFNpemVVdiAtPSAuNSAqIHVfcmVzb2x1dGlvbjtcbiAgICBweFNpemVVdiAvPSBweFNpemU7XG4gICAgdXYgPSBmbG9vcihweFNpemVVdikgKiBweFNpemUgLyB1X3Jlc29sdXRpb24ueHk7ICAgIFxuICAgIHV2ICs9IC41O1xuICAjZW5kaWZcbiAgdXYgLT0gLjU7XG5cbiAgXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBzaXppbmcgcGFyYW1zIHNoYXJlZCBiZXR3ZWVuIG9iamVjdHMgYW5kIHBhdHRlcm5zXG4gIFxuICB2ZWMyIGJveE9yaWdpbiA9IHZlYzIoLjUgLSB1X29yaWdpblgsIHVfb3JpZ2luWSAtIC41KTtcbiAgdmVjMiBnaXZlbkJveFNpemUgPSB2ZWMyKHVfd29ybGRXaWR0aCwgdV93b3JsZEhlaWdodCk7XG4gIGdpdmVuQm94U2l6ZSA9IG1heChnaXZlbkJveFNpemUsIHZlYzIoMS4pKSAqIHVfcGl4ZWxSYXRpbztcbiAgZmxvYXQgciA9IHVfcm90YXRpb24gKiAzLjE0MTU5MjY1MzU4OTc5MzIzODQ2IC8gMTgwLjtcbiAgbWF0MiBncmFwaGljUm90YXRpb24gPSBtYXQyKGNvcyhyKSwgc2luKHIpLCAtc2luKHIpLCBjb3MocikpO1xuICB2ZWMyIGdyYXBoaWNPZmZzZXQgPSB2ZWMyKC11X29mZnNldFgsIHVfb2Zmc2V0WSk7XG5cbiAgXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBTaXppbmcgYXBpIGZvciBvYmplY3RzIChncmFwaGljcyB3aXRoIGZpeGVkIHJhdGlvKVxuXG4gICNpZmRlZiBVU0VfT0JKRUNUX1NJWklOR1xuICAgIGZsb2F0IGZpeGVkUmF0aW8gPSAxLjtcbiAgICB2ZWMyIGZpeGVkUmF0aW9Cb3hHaXZlblNpemUgPSB2ZWMyKFxuICAgICAgKHVfd29ybGRXaWR0aCA9PSAwLikgPyB1X3Jlc29sdXRpb24ueCA6IGdpdmVuQm94U2l6ZS54LFxuICAgICAgKHVfd29ybGRIZWlnaHQgPT0gMC4pID8gdV9yZXNvbHV0aW9uLnkgOiBnaXZlbkJveFNpemUueVxuICAgICk7XG4gICAgdmVjMiBvYmplY3RCb3hTaXplID0gdmVjMigwLik7XG4gICAgLy8gZml0ID0gbm9uZVxuICAgIG9iamVjdEJveFNpemUueCA9IGZpeGVkUmF0aW8gKiBtaW4oZml4ZWRSYXRpb0JveEdpdmVuU2l6ZS54IC8gZml4ZWRSYXRpbywgZml4ZWRSYXRpb0JveEdpdmVuU2l6ZS55KTtcbiAgICBpZiAodV9maXQgPT0gMS4pIHsgLy8gZml0ID0gY29udGFpblxuICAgICAgb2JqZWN0Qm94U2l6ZS54ID0gZml4ZWRSYXRpbyAqIG1pbih1X3Jlc29sdXRpb24ueCAvIGZpeGVkUmF0aW8sIHVfcmVzb2x1dGlvbi55KTtcbiAgICB9IGVsc2UgaWYgKHVfZml0ID09IDIuKSB7ICAvLyBmaXQgPSBjb3ZlclxuICAgICAgb2JqZWN0Qm94U2l6ZS54ID0gZml4ZWRSYXRpbyAqIG1heCh1X3Jlc29sdXRpb24ueCAvIGZpeGVkUmF0aW8sIHVfcmVzb2x1dGlvbi55KTtcbiAgICB9XG4gICAgb2JqZWN0Qm94U2l6ZS55ID0gb2JqZWN0Qm94U2l6ZS54IC8gZml4ZWRSYXRpbztcbiAgICB2ZWMyIG9iamVjdFdvcmxkU2NhbGUgPSB1X3Jlc29sdXRpb24ueHkgLyBvYmplY3RCb3hTaXplO1xuICBcbiAgICAjaWZkZWYgQUREX0hFTFBFUlNcbiAgICAgIHZlYzIgb2JqZWN0SGVscGVyQm94ID0gZ2xfRnJhZ0Nvb3JkLnh5IC8gdV9yZXNvbHV0aW9uLnh5O1xuICAgICAgb2JqZWN0SGVscGVyQm94IC09IC41O1xuICAgICAgb2JqZWN0SGVscGVyQm94ICo9IG9iamVjdFdvcmxkU2NhbGU7XG4gICAgICBvYmplY3RIZWxwZXJCb3ggKz0gYm94T3JpZ2luICogKG9iamVjdFdvcmxkU2NhbGUgLSAxLik7ICBcbiAgICAjZW5kaWZcbiAgXG4gICAgdmVjMiBvYmplY3RVViA9IHV2O1xuICAgIG9iamVjdFVWICo9IG9iamVjdFdvcmxkU2NhbGU7XG4gICAgb2JqZWN0VVYgKz0gYm94T3JpZ2luICogKG9iamVjdFdvcmxkU2NhbGUgLSAxLik7XG4gICAgb2JqZWN0VVYgKz0gdmVjMigtdV9vZmZzZXRYLCB1X29mZnNldFkpO1xuICAgIG9iamVjdFVWIC89IHVfc2NhbGU7XG4gICAgb2JqZWN0VVYgPSBncmFwaGljUm90YXRpb24gKiBvYmplY3RVVjtcbiAgI2VuZGlmXG4gIFxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiBcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFNpemluZyBhcGkgZm9yIHBhdHRlcm5zIChncmFwaGljcyByZXNwZWN0aW5nIHVfd29ybGRXaWR0aCAvIHVfd29ybGRIZWlnaHQgcmF0aW8pXG4gIFxuICAjaWZkZWYgVVNFX1BBVFRFUk5fU0laSU5HXG4gICAgZmxvYXQgcGF0dGVybkJveFJhdGlvID0gZ2l2ZW5Cb3hTaXplLnggLyBnaXZlbkJveFNpemUueTtcbiAgICB2ZWMyIHBhdHRlcm5Cb3hHaXZlblNpemUgPSB2ZWMyKFxuICAgICAgKHVfd29ybGRXaWR0aCA9PSAwLikgPyB1X3Jlc29sdXRpb24ueCA6IGdpdmVuQm94U2l6ZS54LFxuICAgICAgKHVfd29ybGRIZWlnaHQgPT0gMC4pID8gdV9yZXNvbHV0aW9uLnkgOiBnaXZlbkJveFNpemUueVxuICAgICk7XG4gICAgdmVjMiBwYXR0ZXJuQm94U2l6ZSA9IHZlYzIoMC4pO1xuICAgIC8vIGZpdCA9IG5vbmVcbiAgICBwYXR0ZXJuQm94U2l6ZS54ID0gcGF0dGVybkJveFJhdGlvICogbWluKHBhdHRlcm5Cb3hHaXZlblNpemUueCAvIHBhdHRlcm5Cb3hSYXRpbywgcGF0dGVybkJveEdpdmVuU2l6ZS55KTtcbiAgICBmbG9hdCBwYXR0ZXJuV29ybGROb0ZpdEJveFdpZHRoID0gcGF0dGVybkJveFNpemUueDtcbiAgICBpZiAodV9maXQgPT0gMS4pIHsgIC8vIGZpdCA9IGNvbnRhaW5cbiAgICAgIHBhdHRlcm5Cb3hTaXplLnggPSBwYXR0ZXJuQm94UmF0aW8gKiBtaW4odV9yZXNvbHV0aW9uLnggLyBwYXR0ZXJuQm94UmF0aW8sIHVfcmVzb2x1dGlvbi55KTtcbiAgICB9IGVsc2UgaWYgKHVfZml0ID09IDIuKSB7ICAvLyBmaXQgPSBjb3ZlclxuICAgICAgcGF0dGVybkJveFNpemUueCA9IHBhdHRlcm5Cb3hSYXRpbyAqIG1heCh1X3Jlc29sdXRpb24ueCAvIHBhdHRlcm5Cb3hSYXRpbywgdV9yZXNvbHV0aW9uLnkpO1xuICAgIH1cbiAgICBwYXR0ZXJuQm94U2l6ZS55ID0gcGF0dGVybkJveFNpemUueCAvIHBhdHRlcm5Cb3hSYXRpbztcbiAgICB2ZWMyIHBhdHRlcm5Xb3JsZFNjYWxlID0gdV9yZXNvbHV0aW9uLnh5IC8gcGF0dGVybkJveFNpemU7XG4gIFxuICAgICNpZmRlZiBBRERfSEVMUEVSUyAgXG4gICAgICB2ZWMyIHBhdHRlcm5IZWxwZXJCb3ggPSBnbF9GcmFnQ29vcmQueHkgLyB1X3Jlc29sdXRpb24ueHk7XG4gICAgICBwYXR0ZXJuSGVscGVyQm94IC09IC41O1xuICAgICAgcGF0dGVybkhlbHBlckJveCAqPSBwYXR0ZXJuV29ybGRTY2FsZTtcbiAgICAgIHBhdHRlcm5IZWxwZXJCb3ggKz0gYm94T3JpZ2luICogKHBhdHRlcm5Xb3JsZFNjYWxlIC0gMS4pOyAgXG4gICAgI2VuZGlmXG4gIFxuICAgIHZlYzIgcGF0dGVyblVWID0gdXY7XG4gICAgcGF0dGVyblVWICs9IHZlYzIoLXVfb2Zmc2V0WCwgdV9vZmZzZXRZKSAvIHBhdHRlcm5Xb3JsZFNjYWxlO1xuICAgIHBhdHRlcm5VViArPSBib3hPcmlnaW47XG4gICAgcGF0dGVyblVWIC09IGJveE9yaWdpbiAvIHBhdHRlcm5Xb3JsZFNjYWxlO1xuICAgIHBhdHRlcm5VViAqPSB1X3Jlc29sdXRpb24ueHk7XG4gICAgcGF0dGVyblVWIC89IHVfcGl4ZWxSYXRpbztcbiAgICBpZiAodV9maXQgPiAwLikge1xuICAgICAgcGF0dGVyblVWICo9IChwYXR0ZXJuV29ybGROb0ZpdEJveFdpZHRoIC8gcGF0dGVybkJveFNpemUueCk7XG4gICAgfVxuICAgIHBhdHRlcm5VViAvPSB1X3NjYWxlO1xuICAgIHBhdHRlcm5VViA9IGdyYXBoaWNSb3RhdGlvbiAqIHBhdHRlcm5VVjtcbiAgICBwYXR0ZXJuVVYgKz0gYm94T3JpZ2luIC8gcGF0dGVybldvcmxkU2NhbGU7XG4gICAgcGF0dGVyblVWIC09IGJveE9yaWdpbjtcbiAgICBwYXR0ZXJuVVYgKz0gLjU7XG4gICNlbmRpZlxuICAgIFxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiBcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFNpemluZyBhcGkgZm9yIGltYWdlIGZpbHRlcnNcbiAgXG4gICNpZmRlZiBVU0VfSU1BR0VfU0laSU5HXG5cbiAgICB2ZWMyIGltYWdlQm94U2l6ZTtcbiAgICBpZiAodV9maXQgPT0gMS4pIHsgLy8gY29udGFpblxuICAgICAgaW1hZ2VCb3hTaXplLnggPSBtaW4odV9yZXNvbHV0aW9uLnggLyB1X2ltYWdlQXNwZWN0UmF0aW8sIHVfcmVzb2x1dGlvbi55KSAqIHVfaW1hZ2VBc3BlY3RSYXRpbztcbiAgICB9IGVsc2UgaWYgKHVfZml0ID09IDIuKSB7IC8vIGNvdmVyXG4gICAgICBpbWFnZUJveFNpemUueCA9IG1heCh1X3Jlc29sdXRpb24ueCAvIHVfaW1hZ2VBc3BlY3RSYXRpbywgdV9yZXNvbHV0aW9uLnkpICogdV9pbWFnZUFzcGVjdFJhdGlvO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbWFnZUJveFNpemUueCA9IG1pbigxMC4wLCAxMC4wIC8gdV9pbWFnZUFzcGVjdFJhdGlvICogdV9pbWFnZUFzcGVjdFJhdGlvKTtcbiAgICB9XG4gICAgaW1hZ2VCb3hTaXplLnkgPSBpbWFnZUJveFNpemUueCAvIHVfaW1hZ2VBc3BlY3RSYXRpbztcbiAgICB2ZWMyIGltYWdlQm94U2NhbGUgPSB1X3Jlc29sdXRpb24ueHkgLyBpbWFnZUJveFNpemU7XG5cbiAgICAjaWZkZWYgQUREX0hFTFBFUlNcbiAgICAgIHZlYzIgaW1hZ2VIZWxwZXJCb3ggPSB1djtcbiAgICAgIGltYWdlSGVscGVyQm94ICo9IGltYWdlQm94U2NhbGU7XG4gICAgICBpbWFnZUhlbHBlckJveCArPSBib3hPcmlnaW4gKiAoaW1hZ2VCb3hTY2FsZSAtIDEuKTtcbiAgICAjZW5kaWZcblxuICAgIHZlYzIgaW1hZ2VVViA9IHV2O1xuICAgIGltYWdlVVYgKj0gaW1hZ2VCb3hTY2FsZTtcbiAgICBpbWFnZVVWICs9IGJveE9yaWdpbiAqIChpbWFnZUJveFNjYWxlIC0gMS4pO1xuICAgIGltYWdlVVYgKz0gZ3JhcGhpY09mZnNldDtcbiAgICBpbWFnZVVWIC89IHVfc2NhbGU7XG4gICAgaW1hZ2VVVi54ICo9IHVfaW1hZ2VBc3BlY3RSYXRpbztcbiAgICBpbWFnZVVWID0gZ3JhcGhpY1JvdGF0aW9uICogaW1hZ2VVVjtcbiAgICBpbWFnZVVWLnggLz0gdV9pbWFnZUFzcGVjdFJhdGlvO1xuICAgIFxuICAgIGltYWdlVVYgKz0gLjU7XG4gICAgaW1hZ2VVVi55ID0gMS4gLSBpbWFnZVVWLnk7XG4gICNlbmRpZlxuYDtcbmNvbnN0IGRyYXdTaXppbmdIZWxwZXJzID0gYFxuICB2ZWMyIHdvcmxkQm94RGlzdCA9IGFicyhoZWxwZXJCb3gpO1xuICBmbG9hdCBib3hTdHJva2UgPSAoc3RlcChtYXgod29ybGRCb3hEaXN0LngsIHdvcmxkQm94RGlzdC55KSwgLjUpIC0gc3RlcChtYXgod29ybGRCb3hEaXN0LngsIHdvcmxkQm94RGlzdC55KSwgLjQ5NSkpO1xuICBjb2xvci5yZ2IgPSBtaXgoY29sb3IucmdiLCB2ZWMzKDEuLCAwLiwgMC4pLCBib3hTdHJva2UpO1xuICBvcGFjaXR5ICs9IGJveFN0cm9rZTtcblxuICB2ZWMyIGJveE9yaWdpbkNvcHkgPSB2ZWMyKC41IC0gdV9vcmlnaW5YLCB1X29yaWdpblkgLSAuNSk7XG4gIHZlYzIgYm94T3JpZ2luRGlzdCA9IGhlbHBlckJveCArIGJveE9yaWdpbkNvcHk7XG4gIGJveE9yaWdpbkRpc3QueCAqPSAoYm94U2l6ZS54IC8gYm94U2l6ZS55KTtcbiAgZmxvYXQgYm94T3JpZ2luUG9pbnQgPSAxLiAtIHNtb290aHN0ZXAoMC4sIC4wNSwgbGVuZ3RoKGJveE9yaWdpbkRpc3QpKTtcbiAgXG4gIHZlYzIgZ3JhcGhpY09yaWdpblBvaW50RGlzdCA9IGhlbHBlckJveCArIHZlYzIoLXVfb2Zmc2V0WCwgdV9vZmZzZXRZKTtcbiAgZ3JhcGhpY09yaWdpblBvaW50RGlzdC54ICo9IChib3hTaXplLnggLyBib3hTaXplLnkpO1xuICBmbG9hdCBncmFwaGljT3JpZ2luUG9pbnQgPSAxLiAtIHNtb290aHN0ZXAoMC4sIC4wNSwgbGVuZ3RoKGdyYXBoaWNPcmlnaW5Qb2ludERpc3QpKTtcbiAgXG4gIGNvbG9yLnJnYiA9IG1peChjb2xvci5yZ2IsIHZlYzMoMC4sIDEuLCAwLiksIGJveE9yaWdpblBvaW50KTtcbiAgb3BhY2l0eSArPSBib3hPcmlnaW5Qb2ludDtcbiAgY29sb3IucmdiID0gbWl4KGNvbG9yLnJnYiwgdmVjMygwLiwgMC4sIDEuKSwgZ3JhcGhpY09yaWdpblBvaW50KTtcbiAgb3BhY2l0eSArPSBncmFwaGljT3JpZ2luUG9pbnQ7XG5gO1xuY29uc3QgZGVmYXVsdE9iamVjdFNpemluZyA9IHtcbiAgZml0OiBcImNvbnRhaW5cIixcbiAgc2NhbGU6IDEsXG4gIHJvdGF0aW9uOiAwLFxuICBvZmZzZXRYOiAwLFxuICBvZmZzZXRZOiAwLFxuICBvcmlnaW5YOiAwLjUsXG4gIG9yaWdpblk6IDAuNSxcbiAgd29ybGRXaWR0aDogMCxcbiAgd29ybGRIZWlnaHQ6IDBcbn07XG5jb25zdCBkZWZhdWx0UGF0dGVyblNpemluZyA9IHtcbiAgZml0OiBcIm5vbmVcIixcbiAgc2NhbGU6IDEsXG4gIHJvdGF0aW9uOiAwLFxuICBvZmZzZXRYOiAwLFxuICBvZmZzZXRZOiAwLFxuICBvcmlnaW5YOiAwLjUsXG4gIG9yaWdpblk6IDAuNSxcbiAgd29ybGRXaWR0aDogMCxcbiAgd29ybGRIZWlnaHQ6IDBcbn07XG5jb25zdCBTaGFkZXJGaXRPcHRpb25zID0ge1xuICBub25lOiAwLFxuICBjb250YWluOiAxLFxuICBjb3ZlcjogMlxufTtcbmV4cG9ydCB7XG4gIFNoYWRlckZpdE9wdGlvbnMsXG4gIGRlZmF1bHRPYmplY3RTaXppbmcsXG4gIGRlZmF1bHRQYXR0ZXJuU2l6aW5nLFxuICBkcmF3U2l6aW5nSGVscGVycyxcbiAgc2l6aW5nRGVidWdWYXJpYWJsZXNEZWNsYXJhdGlvbixcbiAgc2l6aW5nVVYsXG4gIHNpemluZ1VuaWZvcm1zRGVjbGFyYXRpb24sXG4gIHNpemluZ1ZhcmlhYmxlc0RlY2xhcmF0aW9uXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhZGVyLXNpemluZy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/shader-sizing.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/shader-utils.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/shader-utils.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   colorBandingFix: () => (/* binding */ colorBandingFix),\n/* harmony export */   declarePI: () => (/* binding */ declarePI),\n/* harmony export */   fiberNoise: () => (/* binding */ fiberNoise),\n/* harmony export */   proceduralHash11: () => (/* binding */ proceduralHash11),\n/* harmony export */   proceduralHash21: () => (/* binding */ proceduralHash21),\n/* harmony export */   proceduralHash22: () => (/* binding */ proceduralHash22),\n/* harmony export */   rotation2: () => (/* binding */ rotation2),\n/* harmony export */   simplexNoise: () => (/* binding */ simplexNoise),\n/* harmony export */   textureRandomizerGB: () => (/* binding */ textureRandomizerGB),\n/* harmony export */   textureRandomizerR: () => (/* binding */ textureRandomizerR)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nconst declarePI = `\n#define TWO_PI 6.28318530718\n#define PI 3.14159265358979323846\n`;\nconst rotation2 = `\nvec2 rotate(vec2 uv, float th) {\n  return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\n}\n`;\nconst proceduralHash11 = `\n  float hash11(float p) {\n    p = fract(p * 0.3183099) + 0.1;\n    p *= p + 19.19;\n    return fract(p * p);\n  }\n`;\nconst proceduralHash21 = `\n  float hash21(vec2 p) {\n    p = fract(p * vec2(0.3183099, 0.3678794)) + 0.1;\n    p += dot(p, p + 19.19);\n    return fract(p.x * p.y);\n  }\n`;\nconst proceduralHash22 = `\n  vec2 hash22(vec2 p) {\n    p = fract(p * vec2(0.3183099, 0.3678794)) + 0.1;\n    p += dot(p, p.yx + 19.19);\n    return fract(vec2(p.x * p.y, p.x + p.y));\n  }\n`;\nconst textureRandomizerR = `\n  float randomR(vec2 p) {\n    vec2 uv = floor(p) / 100. + .5;\n    return texture(u_noiseTexture, fract(uv)).r;\n  }\n`;\nconst textureRandomizerGB = `\n  vec2 randomGB(vec2 p) {\n    vec2 uv = floor(p) / 100. + .5;\n    return texture(u_noiseTexture, fract(uv)).gb;\n  }\n`;\nconst colorBandingFix = `\n  color += 1. / 256. * (fract(sin(dot(.014 * gl_FragCoord.xy, vec2(12.9898, 78.233))) * 43758.5453123) - .5);\n`;\nconst simplexNoise = `\nvec3 permute(vec3 x) { return mod(((x * 34.0) + 1.0) * x, 289.0); }\nfloat snoise(vec2 v) {\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n    -0.577350269189626, 0.024390243902439);\n  vec2 i = floor(v + dot(v, C.yy));\n  vec2 x0 = v - i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))\n    + i.x + vec3(0.0, i1.x, 1.0));\n  vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy),\n      dot(x12.zw, x12.zw)), 0.0);\n  m = m * m;\n  m = m * m;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\n  vec3 g;\n  g.x = a0.x * x0.x + h.x * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n`;\nconst fiberNoise = `\nfloat fiberRandom(vec2 p) {\n  vec2 uv = floor(p) / 100.;\n  return texture(u_noiseTexture, fract(uv)).b;\n}\n\nfloat fiberValueNoise(vec2 st) {\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n  float a = fiberRandom(i);\n  float b = fiberRandom(i + vec2(1.0, 0.0));\n  float c = fiberRandom(i + vec2(0.0, 1.0));\n  float d = fiberRandom(i + vec2(1.0, 1.0));\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  float x1 = mix(a, b, u.x);\n  float x2 = mix(c, d, u.x);\n  return mix(x1, x2, u.y);\n}\n\nfloat fiberNoiseFbm(in vec2 n, vec2 seedOffset) {\n  float total = 0.0, amplitude = 1.;\n  for (int i = 0; i < 4; i++) {\n    n = rotate(n, .7);\n    total += fiberValueNoise(n + seedOffset) * amplitude;\n    n *= 2.;\n    amplitude *= 0.6;\n  }\n  return total;\n}\n\nfloat fiberNoise(vec2 uv, vec2 seedOffset) {\n  float epsilon = 0.001;\n  float n1 = fiberNoiseFbm(uv + vec2(epsilon, 0.0), seedOffset);\n  float n2 = fiberNoiseFbm(uv - vec2(epsilon, 0.0), seedOffset);\n  float n3 = fiberNoiseFbm(uv + vec2(0.0, epsilon), seedOffset);\n  float n4 = fiberNoiseFbm(uv - vec2(0.0, epsilon), seedOffset);\n  return length(vec2(n1 - n2, n3 - n4)) / (2.0 * epsilon);\n}\n`;\n\n//# sourceMappingURL=shader-utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVyLXV0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVyLXV0aWxzLmpzPzhhOTEiXSwic291cmNlc0NvbnRlbnQiOlsiLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqICAgICAgICAgICAgICAgICAgICBQYXBlciBTaGFkZXJzICAgICAgICAgICAgICAgICAgICAqXG4gKiAgICAgICBodHRwczovL2dpdGh1Yi5jb20vcGFwZXItZGVzaWduL3NoYWRlcnMgICAgICAgKlxuICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICovXG5cbmNvbnN0IGRlY2xhcmVQSSA9IGBcbiNkZWZpbmUgVFdPX1BJIDYuMjgzMTg1MzA3MThcbiNkZWZpbmUgUEkgMy4xNDE1OTI2NTM1ODk3OTMyMzg0NlxuYDtcbmNvbnN0IHJvdGF0aW9uMiA9IGBcbnZlYzIgcm90YXRlKHZlYzIgdXYsIGZsb2F0IHRoKSB7XG4gIHJldHVybiBtYXQyKGNvcyh0aCksIHNpbih0aCksIC1zaW4odGgpLCBjb3ModGgpKSAqIHV2O1xufVxuYDtcbmNvbnN0IHByb2NlZHVyYWxIYXNoMTEgPSBgXG4gIGZsb2F0IGhhc2gxMShmbG9hdCBwKSB7XG4gICAgcCA9IGZyYWN0KHAgKiAwLjMxODMwOTkpICsgMC4xO1xuICAgIHAgKj0gcCArIDE5LjE5O1xuICAgIHJldHVybiBmcmFjdChwICogcCk7XG4gIH1cbmA7XG5jb25zdCBwcm9jZWR1cmFsSGFzaDIxID0gYFxuICBmbG9hdCBoYXNoMjEodmVjMiBwKSB7XG4gICAgcCA9IGZyYWN0KHAgKiB2ZWMyKDAuMzE4MzA5OSwgMC4zNjc4Nzk0KSkgKyAwLjE7XG4gICAgcCArPSBkb3QocCwgcCArIDE5LjE5KTtcbiAgICByZXR1cm4gZnJhY3QocC54ICogcC55KTtcbiAgfVxuYDtcbmNvbnN0IHByb2NlZHVyYWxIYXNoMjIgPSBgXG4gIHZlYzIgaGFzaDIyKHZlYzIgcCkge1xuICAgIHAgPSBmcmFjdChwICogdmVjMigwLjMxODMwOTksIDAuMzY3ODc5NCkpICsgMC4xO1xuICAgIHAgKz0gZG90KHAsIHAueXggKyAxOS4xOSk7XG4gICAgcmV0dXJuIGZyYWN0KHZlYzIocC54ICogcC55LCBwLnggKyBwLnkpKTtcbiAgfVxuYDtcbmNvbnN0IHRleHR1cmVSYW5kb21pemVyUiA9IGBcbiAgZmxvYXQgcmFuZG9tUih2ZWMyIHApIHtcbiAgICB2ZWMyIHV2ID0gZmxvb3IocCkgLyAxMDAuICsgLjU7XG4gICAgcmV0dXJuIHRleHR1cmUodV9ub2lzZVRleHR1cmUsIGZyYWN0KHV2KSkucjtcbiAgfVxuYDtcbmNvbnN0IHRleHR1cmVSYW5kb21pemVyR0IgPSBgXG4gIHZlYzIgcmFuZG9tR0IodmVjMiBwKSB7XG4gICAgdmVjMiB1diA9IGZsb29yKHApIC8gMTAwLiArIC41O1xuICAgIHJldHVybiB0ZXh0dXJlKHVfbm9pc2VUZXh0dXJlLCBmcmFjdCh1dikpLmdiO1xuICB9XG5gO1xuY29uc3QgY29sb3JCYW5kaW5nRml4ID0gYFxuICBjb2xvciArPSAxLiAvIDI1Ni4gKiAoZnJhY3Qoc2luKGRvdCguMDE0ICogZ2xfRnJhZ0Nvb3JkLnh5LCB2ZWMyKDEyLjk4OTgsIDc4LjIzMykpKSAqIDQzNzU4LjU0NTMxMjMpIC0gLjUpO1xuYDtcbmNvbnN0IHNpbXBsZXhOb2lzZSA9IGBcbnZlYzMgcGVybXV0ZSh2ZWMzIHgpIHsgcmV0dXJuIG1vZCgoKHggKiAzNC4wKSArIDEuMCkgKiB4LCAyODkuMCk7IH1cbmZsb2F0IHNub2lzZSh2ZWMyIHYpIHtcbiAgY29uc3QgdmVjNCBDID0gdmVjNCgwLjIxMTMyNDg2NTQwNTE4NywgMC4zNjYwMjU0MDM3ODQ0MzksXG4gICAgLTAuNTc3MzUwMjY5MTg5NjI2LCAwLjAyNDM5MDI0MzkwMjQzOSk7XG4gIHZlYzIgaSA9IGZsb29yKHYgKyBkb3QodiwgQy55eSkpO1xuICB2ZWMyIHgwID0gdiAtIGkgKyBkb3QoaSwgQy54eCk7XG4gIHZlYzIgaTE7XG4gIGkxID0gKHgwLnggPiB4MC55KSA/IHZlYzIoMS4wLCAwLjApIDogdmVjMigwLjAsIDEuMCk7XG4gIHZlYzQgeDEyID0geDAueHl4eSArIEMueHh6ejtcbiAgeDEyLnh5IC09IGkxO1xuICBpID0gbW9kKGksIDI4OS4wKTtcbiAgdmVjMyBwID0gcGVybXV0ZShwZXJtdXRlKGkueSArIHZlYzMoMC4wLCBpMS55LCAxLjApKVxuICAgICsgaS54ICsgdmVjMygwLjAsIGkxLngsIDEuMCkpO1xuICB2ZWMzIG0gPSBtYXgoMC41IC0gdmVjMyhkb3QoeDAsIHgwKSwgZG90KHgxMi54eSwgeDEyLnh5KSxcbiAgICAgIGRvdCh4MTIuencsIHgxMi56dykpLCAwLjApO1xuICBtID0gbSAqIG07XG4gIG0gPSBtICogbTtcbiAgdmVjMyB4ID0gMi4wICogZnJhY3QocCAqIEMud3d3KSAtIDEuMDtcbiAgdmVjMyBoID0gYWJzKHgpIC0gMC41O1xuICB2ZWMzIG94ID0gZmxvb3IoeCArIDAuNSk7XG4gIHZlYzMgYTAgPSB4IC0gb3g7XG4gIG0gKj0gMS43OTI4NDI5MTQwMDE1OSAtIDAuODUzNzM0NzIwOTUzMTQgKiAoYTAgKiBhMCArIGggKiBoKTtcbiAgdmVjMyBnO1xuICBnLnggPSBhMC54ICogeDAueCArIGgueCAqIHgwLnk7XG4gIGcueXogPSBhMC55eiAqIHgxMi54eiArIGgueXogKiB4MTIueXc7XG4gIHJldHVybiAxMzAuMCAqIGRvdChtLCBnKTtcbn1cbmA7XG5jb25zdCBmaWJlck5vaXNlID0gYFxuZmxvYXQgZmliZXJSYW5kb20odmVjMiBwKSB7XG4gIHZlYzIgdXYgPSBmbG9vcihwKSAvIDEwMC47XG4gIHJldHVybiB0ZXh0dXJlKHVfbm9pc2VUZXh0dXJlLCBmcmFjdCh1dikpLmI7XG59XG5cbmZsb2F0IGZpYmVyVmFsdWVOb2lzZSh2ZWMyIHN0KSB7XG4gIHZlYzIgaSA9IGZsb29yKHN0KTtcbiAgdmVjMiBmID0gZnJhY3Qoc3QpO1xuICBmbG9hdCBhID0gZmliZXJSYW5kb20oaSk7XG4gIGZsb2F0IGIgPSBmaWJlclJhbmRvbShpICsgdmVjMigxLjAsIDAuMCkpO1xuICBmbG9hdCBjID0gZmliZXJSYW5kb20oaSArIHZlYzIoMC4wLCAxLjApKTtcbiAgZmxvYXQgZCA9IGZpYmVyUmFuZG9tKGkgKyB2ZWMyKDEuMCwgMS4wKSk7XG4gIHZlYzIgdSA9IGYgKiBmICogKDMuMCAtIDIuMCAqIGYpO1xuICBmbG9hdCB4MSA9IG1peChhLCBiLCB1LngpO1xuICBmbG9hdCB4MiA9IG1peChjLCBkLCB1LngpO1xuICByZXR1cm4gbWl4KHgxLCB4MiwgdS55KTtcbn1cblxuZmxvYXQgZmliZXJOb2lzZUZibShpbiB2ZWMyIG4sIHZlYzIgc2VlZE9mZnNldCkge1xuICBmbG9hdCB0b3RhbCA9IDAuMCwgYW1wbGl0dWRlID0gMS47XG4gIGZvciAoaW50IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgbiA9IHJvdGF0ZShuLCAuNyk7XG4gICAgdG90YWwgKz0gZmliZXJWYWx1ZU5vaXNlKG4gKyBzZWVkT2Zmc2V0KSAqIGFtcGxpdHVkZTtcbiAgICBuICo9IDIuO1xuICAgIGFtcGxpdHVkZSAqPSAwLjY7XG4gIH1cbiAgcmV0dXJuIHRvdGFsO1xufVxuXG5mbG9hdCBmaWJlck5vaXNlKHZlYzIgdXYsIHZlYzIgc2VlZE9mZnNldCkge1xuICBmbG9hdCBlcHNpbG9uID0gMC4wMDE7XG4gIGZsb2F0IG4xID0gZmliZXJOb2lzZUZibSh1diArIHZlYzIoZXBzaWxvbiwgMC4wKSwgc2VlZE9mZnNldCk7XG4gIGZsb2F0IG4yID0gZmliZXJOb2lzZUZibSh1diAtIHZlYzIoZXBzaWxvbiwgMC4wKSwgc2VlZE9mZnNldCk7XG4gIGZsb2F0IG4zID0gZmliZXJOb2lzZUZibSh1diArIHZlYzIoMC4wLCBlcHNpbG9uKSwgc2VlZE9mZnNldCk7XG4gIGZsb2F0IG40ID0gZmliZXJOb2lzZUZibSh1diAtIHZlYzIoMC4wLCBlcHNpbG9uKSwgc2VlZE9mZnNldCk7XG4gIHJldHVybiBsZW5ndGgodmVjMihuMSAtIG4yLCBuMyAtIG40KSkgLyAoMi4wICogZXBzaWxvbik7XG59XG5gO1xuZXhwb3J0IHtcbiAgY29sb3JCYW5kaW5nRml4LFxuICBkZWNsYXJlUEksXG4gIGZpYmVyTm9pc2UsXG4gIHByb2NlZHVyYWxIYXNoMTEsXG4gIHByb2NlZHVyYWxIYXNoMjEsXG4gIHByb2NlZHVyYWxIYXNoMjIsXG4gIHJvdGF0aW9uMixcbiAgc2ltcGxleE5vaXNlLFxuICB0ZXh0dXJlUmFuZG9taXplckdCLFxuICB0ZXh0dXJlUmFuZG9taXplclJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGFkZXItdXRpbHMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/shader-utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/shaders/liquid-metal.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/shaders/liquid-metal.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LiquidMetalShapes: () => (/* binding */ LiquidMetalShapes),\n/* harmony export */   POISSON_CONFIG_OPTIMIZED: () => (/* binding */ POISSON_CONFIG_OPTIMIZED),\n/* harmony export */   liquidMetalFragmentShader: () => (/* binding */ liquidMetalFragmentShader),\n/* harmony export */   toProcessedLiquidMetal: () => (/* binding */ toProcessedLiquidMetal)\n/* harmony export */ });\n/* harmony import */ var _shader_sizing_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shader-sizing.js */ \"(ssr)/./node_modules/@paper-design/shaders/dist/shader-sizing.js\");\n/* harmony import */ var _shader_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shader-utils.js */ \"(ssr)/./node_modules/@paper-design/shaders/dist/shader-utils.js\");\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\n\nconst liquidMetalFragmentShader = `#version 300 es\nprecision mediump float;\n\nuniform sampler2D u_image;\nuniform float u_imageAspectRatio;\n\nuniform vec2 u_resolution;\nuniform float u_time;\n\nuniform vec4 u_colorBack;\nuniform vec4 u_colorTint;\n\nuniform float u_softness;\nuniform float u_repetition;\nuniform float u_shiftRed;\nuniform float u_shiftBlue;\nuniform float u_distortion;\nuniform float u_contour;\nuniform float u_angle;\n\nuniform float u_shape;\nuniform bool u_isImage;\n\n${_shader_sizing_js__WEBPACK_IMPORTED_MODULE_0__.sizingVariablesDeclaration}\n\nout vec4 fragColor;\n\n${_shader_utils_js__WEBPACK_IMPORTED_MODULE_1__.declarePI}\n${_shader_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotation2}\n${_shader_utils_js__WEBPACK_IMPORTED_MODULE_1__.simplexNoise}\n\nfloat getColorChanges(float c1, float c2, float stripe_p, vec3 w, float blur, float bump, float tint) {\n\n  float ch = mix(c2, c1, smoothstep(.0, 2. * blur, stripe_p));\n\n  float border = w[0];\n  ch = mix(ch, c2, smoothstep(border, border + 2. * blur, stripe_p));\n\n  if (u_isImage == true) {\n    bump = smoothstep(.2, .8, bump);\n  }\n  border = w[0] + .4 * (1. - bump) * w[1];\n  ch = mix(ch, c1, smoothstep(border, border + 2. * blur, stripe_p));\n\n  border = w[0] + .5 * (1. - bump) * w[1];\n  ch = mix(ch, c2, smoothstep(border, border + 2. * blur, stripe_p));\n\n  border = w[0] + w[1];\n  ch = mix(ch, c1, smoothstep(border, border + 2. * blur, stripe_p));\n\n  float gradient_t = (stripe_p - w[0] - w[1]) / w[2];\n  float gradient = mix(c1, c2, smoothstep(0., 1., gradient_t));\n  ch = mix(ch, gradient, smoothstep(border, border + .5 * blur, stripe_p));\n\n  // Tint color is applied with color burn blending\n  ch = mix(ch, 1. - min(1., (1. - ch) / max(tint, 0.0001)), u_colorTint.a);\n  return ch;\n}\n\nfloat getImgFrame(vec2 uv, float th) {\n  float frame = 1.;\n  frame *= smoothstep(0., th, uv.y);\n  frame *= 1.0 - smoothstep(1. - th, 1., uv.y);\n  frame *= smoothstep(0., th, uv.x);\n  frame *= 1.0 - smoothstep(1. - th, 1., uv.x);\n  return frame;\n}\n\nfloat blurEdge3x3(sampler2D tex, vec2 uv, vec2 dudx, vec2 dudy, float radius, float centerSample) {\n  vec2 texel = 1.0 / vec2(textureSize(tex, 0));\n  vec2 r = radius * texel;\n\n  float w1 = 1.0, w2 = 2.0, w4 = 4.0;\n  float norm = 16.0;\n  float sum = w4 * centerSample;\n\n  sum += w2 * textureGrad(tex, uv + vec2(0.0, -r.y), dudx, dudy).r;\n  sum += w2 * textureGrad(tex, uv + vec2(0.0, r.y), dudx, dudy).r;\n  sum += w2 * textureGrad(tex, uv + vec2(-r.x, 0.0), dudx, dudy).r;\n  sum += w2 * textureGrad(tex, uv + vec2(r.x, 0.0), dudx, dudy).r;\n\n  sum += w1 * textureGrad(tex, uv + vec2(-r.x, -r.y), dudx, dudy).r;\n  sum += w1 * textureGrad(tex, uv + vec2(r.x, -r.y), dudx, dudy).r;\n  sum += w1 * textureGrad(tex, uv + vec2(-r.x, r.y), dudx, dudy).r;\n  sum += w1 * textureGrad(tex, uv + vec2(r.x, r.y), dudx, dudy).r;\n\n  return sum / norm;\n}\n\nfloat lst(float edge0, float edge1, float x) {\n  return clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n}\n\nvoid main() {\n\n  const float firstFrameOffset = 2.8;\n  float t = .3 * (u_time + firstFrameOffset);\n\n  vec2 uv = v_imageUV;\n  vec2 dudx = dFdx(v_imageUV);\n  vec2 dudy = dFdy(v_imageUV);\n  vec4 img = textureGrad(u_image, uv, dudx, dudy);\n\n  if (u_isImage == false) {\n    uv = v_objectUV + .5;\n    uv.y = 1. - uv.y;\n  }\n\n  float cycleWidth = u_repetition;\n  float edge = 0.;\n  float contOffset = 1.;\n\n  vec2 rotatedUV = uv - vec2(.5);\n  float angle = (-u_angle + 70.) * PI / 180.;\n  float cosA = cos(angle);\n  float sinA = sin(angle);\n  rotatedUV = vec2(\n  rotatedUV.x * cosA - rotatedUV.y * sinA,\n  rotatedUV.x * sinA + rotatedUV.y * cosA\n  ) + vec2(.5);\n\n  if (u_isImage == true) {\n    float edgeRaw = img.r;\n    edge = blurEdge3x3(u_image, uv, dudx, dudy, 6., edgeRaw);\n    edge = pow(edge, 1.6);\n    edge *= mix(0.0, 1.0, smoothstep(0.0, 0.4, u_contour));\n  } else {\n    if (u_shape < 1.) {\n      // full-fill on canvas\n      vec2 borderUV = v_responsiveUV + .5;\n      float ratio = v_responsiveBoxGivenSize.x / v_responsiveBoxGivenSize.y;\n      vec2 mask = min(borderUV, 1. - borderUV);\n      vec2 pixel_thickness = 250. / v_responsiveBoxGivenSize;\n      float maskX = smoothstep(0.0, pixel_thickness.x, mask.x);\n      float maskY = smoothstep(0.0, pixel_thickness.y, mask.y);\n      maskX = pow(maskX, .25);\n      maskY = pow(maskY, .25);\n      edge = clamp(1. - maskX * maskY, 0., 1.);\n\n      uv = v_responsiveUV;\n      if (ratio > 1.) {\n        uv.y /= ratio;\n      } else {\n        uv.x *= ratio;\n      }\n      uv += .5;\n      uv.y = 1. - uv.y;\n\n      cycleWidth *= 2.;\n      contOffset = 1.5;\n\n    } else if (u_shape < 2.) {\n      // circle\n      vec2 shapeUV = uv - .5;\n      shapeUV *= .67;\n      edge = pow(clamp(3. * length(shapeUV), 0., 1.), 18.);\n    } else if (u_shape < 3.) {\n      // daisy\n      vec2 shapeUV = uv - .5;\n      shapeUV *= 1.68;\n\n      float r = length(shapeUV) * 2.;\n      float a = atan(shapeUV.y, shapeUV.x) + .2;\n      r *= (1. + .05 * sin(3. * a + 2. * t));\n      float f = abs(cos(a * 3.));\n      edge = smoothstep(f, f + .7, r);\n      edge *= edge;\n\n      uv *= .8;\n      cycleWidth *= 1.6;\n\n    } else if (u_shape < 4.) {\n      // diamond\n      vec2 shapeUV = uv - .5;\n      shapeUV = rotate(shapeUV, .25 * PI);\n      shapeUV *= 1.42;\n      shapeUV += .5;\n      vec2 mask = min(shapeUV, 1. - shapeUV);\n      vec2 pixel_thickness = vec2(.15);\n      float maskX = smoothstep(0.0, pixel_thickness.x, mask.x);\n      float maskY = smoothstep(0.0, pixel_thickness.y, mask.y);\n      maskX = pow(maskX, .25);\n      maskY = pow(maskY, .25);\n      edge = clamp(1. - maskX * maskY, 0., 1.);\n    } else if (u_shape < 5.) {\n      // metaballs\n      vec2 shapeUV = uv - .5;\n      shapeUV *= 1.3;\n      edge = 0.;\n      for (int i = 0; i < 5; i++) {\n        float fi = float(i);\n        float speed = 1.5 + 2./3. * sin(fi * 12.345);\n        float angle = -fi * 1.5;\n        vec2 dir1 = vec2(cos(angle), sin(angle));\n        vec2 dir2 = vec2(cos(angle + 1.57), sin(angle + 1.));\n        vec2 traj = .4 * (dir1 * sin(t * speed + fi * 1.23) + dir2 * cos(t * (speed * 0.7) + fi * 2.17));\n        float d = length(shapeUV + traj);\n        edge += pow(1.0 - clamp(d, 0.0, 1.0), 4.0);\n      }\n      edge = 1. - smoothstep(.65, .9, edge);\n      edge = pow(edge, 4.);\n    }\n\n    edge = mix(smoothstep(.9 - 2. * fwidth(edge), .9, edge), edge, smoothstep(0.0, 0.4, u_contour));\n\n  }\n\n  float opacity = 0.;\n  if (u_isImage == true) {\n    opacity = img.g;\n    float frame = getImgFrame(v_imageUV, 0.);\n    opacity *= frame;\n  } else {\n    opacity = 1. - smoothstep(.9 - 2. * fwidth(edge), .9, edge);\n    if (u_shape < 2.) {\n      edge = 1.2 * edge;\n    } else if (u_shape < 5.) {\n      edge = 1.8 * pow(edge, 1.5);\n    }\n  }\n\n  float diagBLtoTR = rotatedUV.x - rotatedUV.y;\n  float diagTLtoBR = rotatedUV.x + rotatedUV.y;\n\n  vec3 color = vec3(0.);\n  vec3 color1 = vec3(.98, 0.98, 1.);\n  vec3 color2 = vec3(.1, .1, .1 + .1 * smoothstep(.7, 1.3, diagTLtoBR));\n\n  vec2 grad_uv = uv - .5;\n\n  float dist = length(grad_uv + vec2(0., .2 * diagBLtoTR));\n  grad_uv = rotate(grad_uv, (.25 - .2 * diagBLtoTR) * PI);\n  float direction = grad_uv.x;\n\n  float bump = pow(1.8 * dist, 1.2);\n  bump = 1. - bump;\n  bump *= pow(uv.y, .3);\n\n\n  float thin_strip_1_ratio = .12 / cycleWidth * (1. - .4 * bump);\n  float thin_strip_2_ratio = .07 / cycleWidth * (1. + .4 * bump);\n  float wide_strip_ratio = (1. - thin_strip_1_ratio - thin_strip_2_ratio);\n\n  float thin_strip_1_width = cycleWidth * thin_strip_1_ratio;\n  float thin_strip_2_width = cycleWidth * thin_strip_2_ratio;\n\n  float noise = snoise(uv - t);\n\n  edge += (1. - edge) * u_distortion * noise;\n\n  direction += diagBLtoTR;\n  float contour = 0.;\n  direction -= 2. * noise * diagBLtoTR * (smoothstep(0., 1., edge) * (1.0 - smoothstep(0., 1., edge)));\n  direction *= mix(1., 1. - edge, smoothstep(.5, 1., u_contour));\n  direction -= 1.7 * edge * smoothstep(.5, 1., u_contour);\n  direction += .2 * pow(u_contour, 4.) * (1.0 - smoothstep(0., 1., edge));\n\n  bump *= clamp(pow(uv.y, .1), .3, 1.);\n  direction *= (.1 + (1.1 - edge) * bump);\n\n  direction *= (.4 + .6 * (1.0 - smoothstep(.5, 1., edge)));\n  direction += .18 * (smoothstep(.1, .2, uv.y) * (1.0 - smoothstep(.2, .4, uv.y)));\n  direction += .03 * (smoothstep(.1, .2, 1. - uv.y) * (1.0 - smoothstep(.2, .4, 1. - uv.y)));\n\n  direction *= (.5 + .5 * pow(uv.y, 2.));\n  direction *= cycleWidth;\n  direction -= t;\n\n\n  float colorDispersion = (1. - bump);\n  colorDispersion = clamp(colorDispersion, 0., 1.);\n  float dispersionRed = colorDispersion;\n  dispersionRed += .03 * bump * noise;\n  dispersionRed += 5. * (smoothstep(-.1, .2, uv.y) * (1.0 - smoothstep(.1, .5, uv.y))) * (smoothstep(.4, .6, bump) * (1.0 - smoothstep(.4, 1., bump)));\n  dispersionRed -= diagBLtoTR;\n\n  float dispersionBlue = colorDispersion;\n  dispersionBlue *= 1.3;\n  dispersionBlue += (smoothstep(0., .4, uv.y) * (1.0 - smoothstep(.1, .8, uv.y))) * (smoothstep(.4, .6, bump) * (1.0 - smoothstep(.4, .8, bump)));\n  dispersionBlue -= .2 * edge;\n\n  dispersionRed *= (u_shiftRed / 20.);\n  dispersionBlue *= (u_shiftBlue / 20.);\n\n  float blur = 0.;\n  float rExtraBlur = 0.;\n  float gExtraBlur = 0.;\n  if (u_isImage == true) {\n    float softness = 0.05 * u_softness;\n    blur = softness + .5 * smoothstep(1., 10., u_repetition) * smoothstep(.0, 1., edge);\n    float smallCanvasT = 1.0 - smoothstep(100., 500., min(u_resolution.x, u_resolution.y));\n    blur += smallCanvasT * smoothstep(.0, 1., edge);\n    rExtraBlur = softness * (0.05 + .1 * (u_shiftRed / 20.) * bump);\n    gExtraBlur = softness * 0.05 / max(0.001, abs(1. - diagBLtoTR));\n  } else {\n    blur = u_softness / 15. + .3 * contour;\n  }\n\n  vec3 w = vec3(thin_strip_1_width, thin_strip_2_width, wide_strip_ratio);\n  w[1] -= .02 * smoothstep(.0, 1., edge + bump);\n  float stripe_r = fract(direction + dispersionRed);\n  float r = getColorChanges(color1.r, color2.r, stripe_r, w, blur + fwidth(stripe_r) + rExtraBlur, bump, u_colorTint.r);\n  float stripe_g = fract(direction);\n  float g = getColorChanges(color1.g, color2.g, stripe_g, w, blur + fwidth(stripe_g) + gExtraBlur, bump, u_colorTint.g);\n  float stripe_b = fract(direction - dispersionBlue);\n  float b = getColorChanges(color1.b, color2.b, stripe_b, w, blur + fwidth(stripe_b), bump, u_colorTint.b);\n\n  color = vec3(r, g, b);\n  color *= opacity;\n\n  vec3 bgColor = u_colorBack.rgb * u_colorBack.a;\n  color = color + bgColor * (1. - opacity);\n  opacity = opacity + u_colorBack.a * (1. - opacity);\n\n  ${_shader_utils_js__WEBPACK_IMPORTED_MODULE_1__.colorBandingFix}\n\n  fragColor = vec4(color, opacity);\n}\n`;\nconst POISSON_CONFIG_OPTIMIZED = {\n  measurePerformance: false,\n  // Set to true to see performance metrics\n  workingSize: 512,\n  // Size to solve Poisson at (will upscale to original size)\n  iterations: 40\n  // SOR converges ~2-20x faster than standard Gauss-Seidel\n};\nfunction toProcessedLiquidMetal(file) {\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n  const isBlob = typeof file === \"string\" && file.startsWith(\"blob:\");\n  return new Promise((resolve, reject) => {\n    if (!file || !ctx) {\n      reject(new Error(\"Invalid file or canvas context\"));\n      return;\n    }\n    const blobContentTypePromise = isBlob && fetch(file).then((res) => res.headers.get(\"Content-Type\"));\n    const img = new Image();\n    img.crossOrigin = \"anonymous\";\n    const totalStartTime = performance.now();\n    img.onload = async () => {\n      let isSVG;\n      const blobContentType = await blobContentTypePromise;\n      if (blobContentType) {\n        isSVG = blobContentType === \"image/svg+xml\";\n      } else if (typeof file === \"string\") {\n        isSVG = file.endsWith(\".svg\") || file.startsWith(\"data:image/svg+xml\");\n      } else {\n        isSVG = file.type === \"image/svg+xml\";\n      }\n      let originalWidth = img.width || img.naturalWidth;\n      let originalHeight = img.height || img.naturalHeight;\n      if (isSVG) {\n        const svgMaxSize = 4096;\n        const aspectRatio = originalWidth / originalHeight;\n        if (originalWidth > originalHeight) {\n          originalWidth = svgMaxSize;\n          originalHeight = svgMaxSize / aspectRatio;\n        } else {\n          originalHeight = svgMaxSize;\n          originalWidth = svgMaxSize * aspectRatio;\n        }\n        img.width = originalWidth;\n        img.height = originalHeight;\n      }\n      const minDimension = Math.min(originalWidth, originalHeight);\n      const targetSize = POISSON_CONFIG_OPTIMIZED.workingSize;\n      const scaleFactor = targetSize / minDimension;\n      const width = Math.round(originalWidth * scaleFactor);\n      const height = Math.round(originalHeight * scaleFactor);\n      if (POISSON_CONFIG_OPTIMIZED.measurePerformance) {\n        console.log(`[Processing Mode]`);\n        console.log(`  Original: ${originalWidth}\\xD7${originalHeight}`);\n        console.log(`  Working: ${width}\\xD7${height} (${(scaleFactor * 100).toFixed(1)}% scale)`);\n        if (scaleFactor < 1) {\n          console.log(`  Speedup: ~${Math.round(1 / (scaleFactor * scaleFactor))}\\xD7`);\n        }\n      }\n      canvas.width = originalWidth;\n      canvas.height = originalHeight;\n      const shapeCanvas = document.createElement(\"canvas\");\n      shapeCanvas.width = width;\n      shapeCanvas.height = height;\n      const shapeCtx = shapeCanvas.getContext(\"2d\");\n      shapeCtx.drawImage(img, 0, 0, width, height);\n      const startMask = performance.now();\n      const shapeImageData = shapeCtx.getImageData(0, 0, width, height);\n      const data = shapeImageData.data;\n      const shapeMask = new Uint8Array(width * height);\n      const boundaryMask = new Uint8Array(width * height);\n      let shapePixelCount = 0;\n      for (let i = 0, idx = 0; i < data.length; i += 4, idx++) {\n        const a = data[i + 3];\n        const isShape = a === 0 ? 0 : 1;\n        shapeMask[idx] = isShape;\n        shapePixelCount += isShape;\n      }\n      const boundaryIndices = [];\n      const interiorIndices = [];\n      for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n          const idx = y * width + x;\n          if (!shapeMask[idx]) continue;\n          let isBoundary = false;\n          if (x === 0 || x === width - 1 || y === 0 || y === height - 1) {\n            isBoundary = true;\n          } else {\n            isBoundary = !shapeMask[idx - 1] || // left\n            !shapeMask[idx + 1] || // right\n            !shapeMask[idx - width] || // top\n            !shapeMask[idx + width] || // bottom\n            !shapeMask[idx - width - 1] || // top-left\n            !shapeMask[idx - width + 1] || // top-right\n            !shapeMask[idx + width - 1] || // bottom-left\n            !shapeMask[idx + width + 1];\n          }\n          if (isBoundary) {\n            boundaryMask[idx] = 1;\n            boundaryIndices.push(idx);\n          } else {\n            interiorIndices.push(idx);\n          }\n        }\n      }\n      if (POISSON_CONFIG_OPTIMIZED.measurePerformance) {\n        console.log(`[Mask Building] Time: ${(performance.now() - startMask).toFixed(2)}ms`);\n        console.log(\n          `  Shape pixels: ${shapePixelCount} / ${width * height} (${(shapePixelCount / (width * height) * 100).toFixed(1)}%)`\n        );\n        console.log(`  Interior pixels: ${interiorIndices.length}`);\n        console.log(`  Boundary pixels: ${boundaryIndices.length}`);\n      }\n      const sparseData = buildSparseData(\n        shapeMask,\n        boundaryMask,\n        new Uint32Array(interiorIndices),\n        new Uint32Array(boundaryIndices),\n        width,\n        height\n      );\n      const startSolve = performance.now();\n      const u = solvePoissonSparse(sparseData, shapeMask, boundaryMask, width, height);\n      if (POISSON_CONFIG_OPTIMIZED.measurePerformance) {\n        console.log(`[Poisson Solve] Time: ${(performance.now() - startSolve).toFixed(2)}ms`);\n      }\n      let maxVal = 0;\n      let finalImageData;\n      for (let i = 0; i < interiorIndices.length; i++) {\n        const idx = interiorIndices[i];\n        if (u[idx] > maxVal) maxVal = u[idx];\n      }\n      const tempCanvas = document.createElement(\"canvas\");\n      tempCanvas.width = width;\n      tempCanvas.height = height;\n      const tempCtx = tempCanvas.getContext(\"2d\");\n      const tempImg = tempCtx.createImageData(width, height);\n      for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n          const idx = y * width + x;\n          const px = idx * 4;\n          if (!shapeMask[idx]) {\n            tempImg.data[px] = 255;\n            tempImg.data[px + 1] = 255;\n            tempImg.data[px + 2] = 255;\n            tempImg.data[px + 3] = 0;\n          } else {\n            const poissonRatio = u[idx] / maxVal;\n            const gray = 255 * (1 - poissonRatio);\n            tempImg.data[px] = gray;\n            tempImg.data[px + 1] = gray;\n            tempImg.data[px + 2] = gray;\n            tempImg.data[px + 3] = 255;\n          }\n        }\n      }\n      tempCtx.putImageData(tempImg, 0, 0);\n      ctx.imageSmoothingEnabled = true;\n      ctx.imageSmoothingQuality = \"high\";\n      ctx.drawImage(tempCanvas, 0, 0, width, height, 0, 0, originalWidth, originalHeight);\n      const outImg = ctx.getImageData(0, 0, originalWidth, originalHeight);\n      const originalCanvas = document.createElement(\"canvas\");\n      originalCanvas.width = originalWidth;\n      originalCanvas.height = originalHeight;\n      const originalCtx = originalCanvas.getContext(\"2d\");\n      originalCtx.drawImage(img, 0, 0, originalWidth, originalHeight);\n      const originalData = originalCtx.getImageData(0, 0, originalWidth, originalHeight);\n      for (let i = 0; i < outImg.data.length; i += 4) {\n        const a = originalData.data[i + 3];\n        const upscaledAlpha = outImg.data[i + 3];\n        if (a === 0) {\n          outImg.data[i] = 255;\n          outImg.data[i + 1] = 0;\n        } else {\n          outImg.data[i] = upscaledAlpha === 0 ? 0 : outImg.data[i];\n          outImg.data[i + 1] = a;\n        }\n        outImg.data[i + 2] = 255;\n        outImg.data[i + 3] = 255;\n      }\n      ctx.putImageData(outImg, 0, 0);\n      finalImageData = outImg;\n      canvas.toBlob((blob) => {\n        if (!blob) {\n          reject(new Error(\"Failed to create PNG blob\"));\n          return;\n        }\n        if (POISSON_CONFIG_OPTIMIZED.measurePerformance) {\n          const totalTime = performance.now() - totalStartTime;\n          console.log(`[Total Processing Time] ${totalTime.toFixed(2)}ms`);\n          if (scaleFactor < 1) {\n            const estimatedFullResTime = totalTime * Math.pow(originalWidth * originalHeight / (width * height), 1.5);\n            console.log(`[Estimated time at full resolution] ~${estimatedFullResTime.toFixed(0)}ms`);\n            console.log(\n              `[Time saved] ~${(estimatedFullResTime - totalTime).toFixed(0)}ms (${Math.round(estimatedFullResTime / totalTime)}\\xD7 faster)`\n            );\n          }\n        }\n        resolve({\n          imageData: finalImageData,\n          pngBlob: blob\n        });\n      }, \"image/png\");\n    };\n    img.onerror = () => reject(new Error(\"Failed to load image\"));\n    img.src = typeof file === \"string\" ? file : URL.createObjectURL(file);\n  });\n}\nfunction buildSparseData(shapeMask, boundaryMask, interiorPixels, boundaryPixels, width, height) {\n  const pixelCount = interiorPixels.length;\n  const neighborIndices = new Int32Array(pixelCount * 4);\n  for (let i = 0; i < pixelCount; i++) {\n    const idx = interiorPixels[i];\n    const x = idx % width;\n    const y = Math.floor(idx / width);\n    neighborIndices[i * 4 + 0] = x < width - 1 && shapeMask[idx + 1] ? idx + 1 : -1;\n    neighborIndices[i * 4 + 1] = x > 0 && shapeMask[idx - 1] ? idx - 1 : -1;\n    neighborIndices[i * 4 + 2] = y > 0 && shapeMask[idx - width] ? idx - width : -1;\n    neighborIndices[i * 4 + 3] = y < height - 1 && shapeMask[idx + width] ? idx + width : -1;\n  }\n  return {\n    interiorPixels,\n    boundaryPixels,\n    pixelCount,\n    neighborIndices\n  };\n}\nfunction solvePoissonSparse(sparseData, shapeMask, boundaryMask, width, height) {\n  const ITERATIONS = POISSON_CONFIG_OPTIMIZED.iterations;\n  const C = 0.01;\n  const u = new Float32Array(width * height);\n  const { interiorPixels, neighborIndices, pixelCount } = sparseData;\n  const startTime = performance.now();\n  const omega = 1.9;\n  const redPixels = [];\n  const blackPixels = [];\n  for (let i = 0; i < pixelCount; i++) {\n    const idx = interiorPixels[i];\n    const x = idx % width;\n    const y = Math.floor(idx / width);\n    if ((x + y) % 2 === 0) {\n      redPixels.push(i);\n    } else {\n      blackPixels.push(i);\n    }\n  }\n  for (let iter = 0; iter < ITERATIONS; iter++) {\n    for (const i of redPixels) {\n      const idx = interiorPixels[i];\n      const eastIdx = neighborIndices[i * 4 + 0];\n      const westIdx = neighborIndices[i * 4 + 1];\n      const northIdx = neighborIndices[i * 4 + 2];\n      const southIdx = neighborIndices[i * 4 + 3];\n      let sumN = 0;\n      if (eastIdx >= 0) sumN += u[eastIdx];\n      if (westIdx >= 0) sumN += u[westIdx];\n      if (northIdx >= 0) sumN += u[northIdx];\n      if (southIdx >= 0) sumN += u[southIdx];\n      const newValue = (C + sumN) / 4;\n      u[idx] = omega * newValue + (1 - omega) * u[idx];\n    }\n    for (const i of blackPixels) {\n      const idx = interiorPixels[i];\n      const eastIdx = neighborIndices[i * 4 + 0];\n      const westIdx = neighborIndices[i * 4 + 1];\n      const northIdx = neighborIndices[i * 4 + 2];\n      const southIdx = neighborIndices[i * 4 + 3];\n      let sumN = 0;\n      if (eastIdx >= 0) sumN += u[eastIdx];\n      if (westIdx >= 0) sumN += u[westIdx];\n      if (northIdx >= 0) sumN += u[northIdx];\n      if (southIdx >= 0) sumN += u[southIdx];\n      const newValue = (C + sumN) / 4;\n      u[idx] = omega * newValue + (1 - omega) * u[idx];\n    }\n  }\n  if (POISSON_CONFIG_OPTIMIZED.measurePerformance) {\n    const elapsed = performance.now() - startTime;\n    console.log(`[Optimized Poisson Solver (SOR \\u03C9=${omega})]`);\n    console.log(`  Working size: ${width}\\xD7${height}`);\n    console.log(`  Iterations: ${ITERATIONS}`);\n    console.log(`  Time: ${elapsed.toFixed(2)}ms`);\n    console.log(`  Interior pixels processed: ${pixelCount}`);\n    console.log(`  Speed: ${(ITERATIONS * pixelCount / (elapsed * 1e3)).toFixed(2)} Mpixels/sec`);\n  }\n  return u;\n}\nconst LiquidMetalShapes = {\n  none: 0,\n  circle: 1,\n  daisy: 2,\n  diamond: 3,\n  metaballs: 4\n};\n\n//# sourceMappingURL=liquid-metal.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVycy9saXF1aWQtbWV0YWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRWlFO0FBQ3dCO0FBQ3pGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFLHlFQUEwQjs7QUFFNUI7O0FBRUEsRUFBRSx1REFBUztBQUNYLEVBQUUsdURBQVM7QUFDWCxFQUFFLDBEQUFZOztBQUVkOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLDZEQUFlOztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGNBQWMsTUFBTSxlQUFlO0FBQ3RFLGtDQUFrQyxNQUFNLE1BQU0sUUFBUSxHQUFHLCtCQUErQjtBQUN4RjtBQUNBLHFDQUFxQyw0Q0FBNEM7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlCQUFpQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsMkNBQTJDO0FBQ3hGO0FBQ0EsNkJBQTZCLGlCQUFpQixJQUFJLGdCQUFnQixHQUFHLHNEQUFzRDtBQUMzSDtBQUNBLDBDQUEwQyx1QkFBdUI7QUFDakUsMENBQTBDLHVCQUF1QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsNENBQTRDO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0QkFBNEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0JBQXdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHFCQUFxQjtBQUN0RTtBQUNBO0FBQ0EsZ0VBQWdFLGdDQUFnQztBQUNoRztBQUNBLCtCQUErQiw4Q0FBOEMsTUFBTSw2Q0FBNkM7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4Q0FBOEM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxNQUFNO0FBQy9ELG1DQUFtQyxNQUFNLE1BQU0sT0FBTztBQUN0RCxpQ0FBaUMsV0FBVztBQUM1QywyQkFBMkIsbUJBQW1CO0FBQzlDLGdEQUFnRCxXQUFXO0FBQzNELDRCQUE0Qix3REFBd0Q7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9AcGFwZXItZGVzaWduL3NoYWRlcnMvZGlzdC9zaGFkZXJzL2xpcXVpZC1tZXRhbC5qcz82NTkwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiAgICAgICAgICAgICAgICAgICAgUGFwZXIgU2hhZGVycyAgICAgICAgICAgICAgICAgICAgKlxuICogICAgICAgaHR0cHM6Ly9naXRodWIuY29tL3BhcGVyLWRlc2lnbi9zaGFkZXJzICAgICAgICpcbiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqL1xuXG5pbXBvcnQgeyBzaXppbmdWYXJpYWJsZXNEZWNsYXJhdGlvbiB9IGZyb20gXCIuLi9zaGFkZXItc2l6aW5nLmpzXCI7XG5pbXBvcnQgeyBkZWNsYXJlUEksIHJvdGF0aW9uMiwgc2ltcGxleE5vaXNlLCBjb2xvckJhbmRpbmdGaXggfSBmcm9tIFwiLi4vc2hhZGVyLXV0aWxzLmpzXCI7XG5jb25zdCBsaXF1aWRNZXRhbEZyYWdtZW50U2hhZGVyID0gYCN2ZXJzaW9uIDMwMCBlc1xucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG5cbnVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7XG51bmlmb3JtIGZsb2F0IHVfaW1hZ2VBc3BlY3RSYXRpbztcblxudW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjtcbnVuaWZvcm0gZmxvYXQgdV90aW1lO1xuXG51bmlmb3JtIHZlYzQgdV9jb2xvckJhY2s7XG51bmlmb3JtIHZlYzQgdV9jb2xvclRpbnQ7XG5cbnVuaWZvcm0gZmxvYXQgdV9zb2Z0bmVzcztcbnVuaWZvcm0gZmxvYXQgdV9yZXBldGl0aW9uO1xudW5pZm9ybSBmbG9hdCB1X3NoaWZ0UmVkO1xudW5pZm9ybSBmbG9hdCB1X3NoaWZ0Qmx1ZTtcbnVuaWZvcm0gZmxvYXQgdV9kaXN0b3J0aW9uO1xudW5pZm9ybSBmbG9hdCB1X2NvbnRvdXI7XG51bmlmb3JtIGZsb2F0IHVfYW5nbGU7XG5cbnVuaWZvcm0gZmxvYXQgdV9zaGFwZTtcbnVuaWZvcm0gYm9vbCB1X2lzSW1hZ2U7XG5cbiR7c2l6aW5nVmFyaWFibGVzRGVjbGFyYXRpb259XG5cbm91dCB2ZWM0IGZyYWdDb2xvcjtcblxuJHtkZWNsYXJlUEl9XG4ke3JvdGF0aW9uMn1cbiR7c2ltcGxleE5vaXNlfVxuXG5mbG9hdCBnZXRDb2xvckNoYW5nZXMoZmxvYXQgYzEsIGZsb2F0IGMyLCBmbG9hdCBzdHJpcGVfcCwgdmVjMyB3LCBmbG9hdCBibHVyLCBmbG9hdCBidW1wLCBmbG9hdCB0aW50KSB7XG5cbiAgZmxvYXQgY2ggPSBtaXgoYzIsIGMxLCBzbW9vdGhzdGVwKC4wLCAyLiAqIGJsdXIsIHN0cmlwZV9wKSk7XG5cbiAgZmxvYXQgYm9yZGVyID0gd1swXTtcbiAgY2ggPSBtaXgoY2gsIGMyLCBzbW9vdGhzdGVwKGJvcmRlciwgYm9yZGVyICsgMi4gKiBibHVyLCBzdHJpcGVfcCkpO1xuXG4gIGlmICh1X2lzSW1hZ2UgPT0gdHJ1ZSkge1xuICAgIGJ1bXAgPSBzbW9vdGhzdGVwKC4yLCAuOCwgYnVtcCk7XG4gIH1cbiAgYm9yZGVyID0gd1swXSArIC40ICogKDEuIC0gYnVtcCkgKiB3WzFdO1xuICBjaCA9IG1peChjaCwgYzEsIHNtb290aHN0ZXAoYm9yZGVyLCBib3JkZXIgKyAyLiAqIGJsdXIsIHN0cmlwZV9wKSk7XG5cbiAgYm9yZGVyID0gd1swXSArIC41ICogKDEuIC0gYnVtcCkgKiB3WzFdO1xuICBjaCA9IG1peChjaCwgYzIsIHNtb290aHN0ZXAoYm9yZGVyLCBib3JkZXIgKyAyLiAqIGJsdXIsIHN0cmlwZV9wKSk7XG5cbiAgYm9yZGVyID0gd1swXSArIHdbMV07XG4gIGNoID0gbWl4KGNoLCBjMSwgc21vb3Roc3RlcChib3JkZXIsIGJvcmRlciArIDIuICogYmx1ciwgc3RyaXBlX3ApKTtcblxuICBmbG9hdCBncmFkaWVudF90ID0gKHN0cmlwZV9wIC0gd1swXSAtIHdbMV0pIC8gd1syXTtcbiAgZmxvYXQgZ3JhZGllbnQgPSBtaXgoYzEsIGMyLCBzbW9vdGhzdGVwKDAuLCAxLiwgZ3JhZGllbnRfdCkpO1xuICBjaCA9IG1peChjaCwgZ3JhZGllbnQsIHNtb290aHN0ZXAoYm9yZGVyLCBib3JkZXIgKyAuNSAqIGJsdXIsIHN0cmlwZV9wKSk7XG5cbiAgLy8gVGludCBjb2xvciBpcyBhcHBsaWVkIHdpdGggY29sb3IgYnVybiBibGVuZGluZ1xuICBjaCA9IG1peChjaCwgMS4gLSBtaW4oMS4sICgxLiAtIGNoKSAvIG1heCh0aW50LCAwLjAwMDEpKSwgdV9jb2xvclRpbnQuYSk7XG4gIHJldHVybiBjaDtcbn1cblxuZmxvYXQgZ2V0SW1nRnJhbWUodmVjMiB1diwgZmxvYXQgdGgpIHtcbiAgZmxvYXQgZnJhbWUgPSAxLjtcbiAgZnJhbWUgKj0gc21vb3Roc3RlcCgwLiwgdGgsIHV2LnkpO1xuICBmcmFtZSAqPSAxLjAgLSBzbW9vdGhzdGVwKDEuIC0gdGgsIDEuLCB1di55KTtcbiAgZnJhbWUgKj0gc21vb3Roc3RlcCgwLiwgdGgsIHV2LngpO1xuICBmcmFtZSAqPSAxLjAgLSBzbW9vdGhzdGVwKDEuIC0gdGgsIDEuLCB1di54KTtcbiAgcmV0dXJuIGZyYW1lO1xufVxuXG5mbG9hdCBibHVyRWRnZTN4MyhzYW1wbGVyMkQgdGV4LCB2ZWMyIHV2LCB2ZWMyIGR1ZHgsIHZlYzIgZHVkeSwgZmxvYXQgcmFkaXVzLCBmbG9hdCBjZW50ZXJTYW1wbGUpIHtcbiAgdmVjMiB0ZXhlbCA9IDEuMCAvIHZlYzIodGV4dHVyZVNpemUodGV4LCAwKSk7XG4gIHZlYzIgciA9IHJhZGl1cyAqIHRleGVsO1xuXG4gIGZsb2F0IHcxID0gMS4wLCB3MiA9IDIuMCwgdzQgPSA0LjA7XG4gIGZsb2F0IG5vcm0gPSAxNi4wO1xuICBmbG9hdCBzdW0gPSB3NCAqIGNlbnRlclNhbXBsZTtcblxuICBzdW0gKz0gdzIgKiB0ZXh0dXJlR3JhZCh0ZXgsIHV2ICsgdmVjMigwLjAsIC1yLnkpLCBkdWR4LCBkdWR5KS5yO1xuICBzdW0gKz0gdzIgKiB0ZXh0dXJlR3JhZCh0ZXgsIHV2ICsgdmVjMigwLjAsIHIueSksIGR1ZHgsIGR1ZHkpLnI7XG4gIHN1bSArPSB3MiAqIHRleHR1cmVHcmFkKHRleCwgdXYgKyB2ZWMyKC1yLngsIDAuMCksIGR1ZHgsIGR1ZHkpLnI7XG4gIHN1bSArPSB3MiAqIHRleHR1cmVHcmFkKHRleCwgdXYgKyB2ZWMyKHIueCwgMC4wKSwgZHVkeCwgZHVkeSkucjtcblxuICBzdW0gKz0gdzEgKiB0ZXh0dXJlR3JhZCh0ZXgsIHV2ICsgdmVjMigtci54LCAtci55KSwgZHVkeCwgZHVkeSkucjtcbiAgc3VtICs9IHcxICogdGV4dHVyZUdyYWQodGV4LCB1diArIHZlYzIoci54LCAtci55KSwgZHVkeCwgZHVkeSkucjtcbiAgc3VtICs9IHcxICogdGV4dHVyZUdyYWQodGV4LCB1diArIHZlYzIoLXIueCwgci55KSwgZHVkeCwgZHVkeSkucjtcbiAgc3VtICs9IHcxICogdGV4dHVyZUdyYWQodGV4LCB1diArIHZlYzIoci54LCByLnkpLCBkdWR4LCBkdWR5KS5yO1xuXG4gIHJldHVybiBzdW0gLyBub3JtO1xufVxuXG5mbG9hdCBsc3QoZmxvYXQgZWRnZTAsIGZsb2F0IGVkZ2UxLCBmbG9hdCB4KSB7XG4gIHJldHVybiBjbGFtcCgoeCAtIGVkZ2UwKSAvIChlZGdlMSAtIGVkZ2UwKSwgMC4wLCAxLjApO1xufVxuXG52b2lkIG1haW4oKSB7XG5cbiAgY29uc3QgZmxvYXQgZmlyc3RGcmFtZU9mZnNldCA9IDIuODtcbiAgZmxvYXQgdCA9IC4zICogKHVfdGltZSArIGZpcnN0RnJhbWVPZmZzZXQpO1xuXG4gIHZlYzIgdXYgPSB2X2ltYWdlVVY7XG4gIHZlYzIgZHVkeCA9IGRGZHgodl9pbWFnZVVWKTtcbiAgdmVjMiBkdWR5ID0gZEZkeSh2X2ltYWdlVVYpO1xuICB2ZWM0IGltZyA9IHRleHR1cmVHcmFkKHVfaW1hZ2UsIHV2LCBkdWR4LCBkdWR5KTtcblxuICBpZiAodV9pc0ltYWdlID09IGZhbHNlKSB7XG4gICAgdXYgPSB2X29iamVjdFVWICsgLjU7XG4gICAgdXYueSA9IDEuIC0gdXYueTtcbiAgfVxuXG4gIGZsb2F0IGN5Y2xlV2lkdGggPSB1X3JlcGV0aXRpb247XG4gIGZsb2F0IGVkZ2UgPSAwLjtcbiAgZmxvYXQgY29udE9mZnNldCA9IDEuO1xuXG4gIHZlYzIgcm90YXRlZFVWID0gdXYgLSB2ZWMyKC41KTtcbiAgZmxvYXQgYW5nbGUgPSAoLXVfYW5nbGUgKyA3MC4pICogUEkgLyAxODAuO1xuICBmbG9hdCBjb3NBID0gY29zKGFuZ2xlKTtcbiAgZmxvYXQgc2luQSA9IHNpbihhbmdsZSk7XG4gIHJvdGF0ZWRVViA9IHZlYzIoXG4gIHJvdGF0ZWRVVi54ICogY29zQSAtIHJvdGF0ZWRVVi55ICogc2luQSxcbiAgcm90YXRlZFVWLnggKiBzaW5BICsgcm90YXRlZFVWLnkgKiBjb3NBXG4gICkgKyB2ZWMyKC41KTtcblxuICBpZiAodV9pc0ltYWdlID09IHRydWUpIHtcbiAgICBmbG9hdCBlZGdlUmF3ID0gaW1nLnI7XG4gICAgZWRnZSA9IGJsdXJFZGdlM3gzKHVfaW1hZ2UsIHV2LCBkdWR4LCBkdWR5LCA2LiwgZWRnZVJhdyk7XG4gICAgZWRnZSA9IHBvdyhlZGdlLCAxLjYpO1xuICAgIGVkZ2UgKj0gbWl4KDAuMCwgMS4wLCBzbW9vdGhzdGVwKDAuMCwgMC40LCB1X2NvbnRvdXIpKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodV9zaGFwZSA8IDEuKSB7XG4gICAgICAvLyBmdWxsLWZpbGwgb24gY2FudmFzXG4gICAgICB2ZWMyIGJvcmRlclVWID0gdl9yZXNwb25zaXZlVVYgKyAuNTtcbiAgICAgIGZsb2F0IHJhdGlvID0gdl9yZXNwb25zaXZlQm94R2l2ZW5TaXplLnggLyB2X3Jlc3BvbnNpdmVCb3hHaXZlblNpemUueTtcbiAgICAgIHZlYzIgbWFzayA9IG1pbihib3JkZXJVViwgMS4gLSBib3JkZXJVVik7XG4gICAgICB2ZWMyIHBpeGVsX3RoaWNrbmVzcyA9IDI1MC4gLyB2X3Jlc3BvbnNpdmVCb3hHaXZlblNpemU7XG4gICAgICBmbG9hdCBtYXNrWCA9IHNtb290aHN0ZXAoMC4wLCBwaXhlbF90aGlja25lc3MueCwgbWFzay54KTtcbiAgICAgIGZsb2F0IG1hc2tZID0gc21vb3Roc3RlcCgwLjAsIHBpeGVsX3RoaWNrbmVzcy55LCBtYXNrLnkpO1xuICAgICAgbWFza1ggPSBwb3cobWFza1gsIC4yNSk7XG4gICAgICBtYXNrWSA9IHBvdyhtYXNrWSwgLjI1KTtcbiAgICAgIGVkZ2UgPSBjbGFtcCgxLiAtIG1hc2tYICogbWFza1ksIDAuLCAxLik7XG5cbiAgICAgIHV2ID0gdl9yZXNwb25zaXZlVVY7XG4gICAgICBpZiAocmF0aW8gPiAxLikge1xuICAgICAgICB1di55IC89IHJhdGlvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXYueCAqPSByYXRpbztcbiAgICAgIH1cbiAgICAgIHV2ICs9IC41O1xuICAgICAgdXYueSA9IDEuIC0gdXYueTtcblxuICAgICAgY3ljbGVXaWR0aCAqPSAyLjtcbiAgICAgIGNvbnRPZmZzZXQgPSAxLjU7XG5cbiAgICB9IGVsc2UgaWYgKHVfc2hhcGUgPCAyLikge1xuICAgICAgLy8gY2lyY2xlXG4gICAgICB2ZWMyIHNoYXBlVVYgPSB1diAtIC41O1xuICAgICAgc2hhcGVVViAqPSAuNjc7XG4gICAgICBlZGdlID0gcG93KGNsYW1wKDMuICogbGVuZ3RoKHNoYXBlVVYpLCAwLiwgMS4pLCAxOC4pO1xuICAgIH0gZWxzZSBpZiAodV9zaGFwZSA8IDMuKSB7XG4gICAgICAvLyBkYWlzeVxuICAgICAgdmVjMiBzaGFwZVVWID0gdXYgLSAuNTtcbiAgICAgIHNoYXBlVVYgKj0gMS42ODtcblxuICAgICAgZmxvYXQgciA9IGxlbmd0aChzaGFwZVVWKSAqIDIuO1xuICAgICAgZmxvYXQgYSA9IGF0YW4oc2hhcGVVVi55LCBzaGFwZVVWLngpICsgLjI7XG4gICAgICByICo9ICgxLiArIC4wNSAqIHNpbigzLiAqIGEgKyAyLiAqIHQpKTtcbiAgICAgIGZsb2F0IGYgPSBhYnMoY29zKGEgKiAzLikpO1xuICAgICAgZWRnZSA9IHNtb290aHN0ZXAoZiwgZiArIC43LCByKTtcbiAgICAgIGVkZ2UgKj0gZWRnZTtcblxuICAgICAgdXYgKj0gLjg7XG4gICAgICBjeWNsZVdpZHRoICo9IDEuNjtcblxuICAgIH0gZWxzZSBpZiAodV9zaGFwZSA8IDQuKSB7XG4gICAgICAvLyBkaWFtb25kXG4gICAgICB2ZWMyIHNoYXBlVVYgPSB1diAtIC41O1xuICAgICAgc2hhcGVVViA9IHJvdGF0ZShzaGFwZVVWLCAuMjUgKiBQSSk7XG4gICAgICBzaGFwZVVWICo9IDEuNDI7XG4gICAgICBzaGFwZVVWICs9IC41O1xuICAgICAgdmVjMiBtYXNrID0gbWluKHNoYXBlVVYsIDEuIC0gc2hhcGVVVik7XG4gICAgICB2ZWMyIHBpeGVsX3RoaWNrbmVzcyA9IHZlYzIoLjE1KTtcbiAgICAgIGZsb2F0IG1hc2tYID0gc21vb3Roc3RlcCgwLjAsIHBpeGVsX3RoaWNrbmVzcy54LCBtYXNrLngpO1xuICAgICAgZmxvYXQgbWFza1kgPSBzbW9vdGhzdGVwKDAuMCwgcGl4ZWxfdGhpY2tuZXNzLnksIG1hc2sueSk7XG4gICAgICBtYXNrWCA9IHBvdyhtYXNrWCwgLjI1KTtcbiAgICAgIG1hc2tZID0gcG93KG1hc2tZLCAuMjUpO1xuICAgICAgZWRnZSA9IGNsYW1wKDEuIC0gbWFza1ggKiBtYXNrWSwgMC4sIDEuKTtcbiAgICB9IGVsc2UgaWYgKHVfc2hhcGUgPCA1Likge1xuICAgICAgLy8gbWV0YWJhbGxzXG4gICAgICB2ZWMyIHNoYXBlVVYgPSB1diAtIC41O1xuICAgICAgc2hhcGVVViAqPSAxLjM7XG4gICAgICBlZGdlID0gMC47XG4gICAgICBmb3IgKGludCBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICBmbG9hdCBmaSA9IGZsb2F0KGkpO1xuICAgICAgICBmbG9hdCBzcGVlZCA9IDEuNSArIDIuLzMuICogc2luKGZpICogMTIuMzQ1KTtcbiAgICAgICAgZmxvYXQgYW5nbGUgPSAtZmkgKiAxLjU7XG4gICAgICAgIHZlYzIgZGlyMSA9IHZlYzIoY29zKGFuZ2xlKSwgc2luKGFuZ2xlKSk7XG4gICAgICAgIHZlYzIgZGlyMiA9IHZlYzIoY29zKGFuZ2xlICsgMS41NyksIHNpbihhbmdsZSArIDEuKSk7XG4gICAgICAgIHZlYzIgdHJhaiA9IC40ICogKGRpcjEgKiBzaW4odCAqIHNwZWVkICsgZmkgKiAxLjIzKSArIGRpcjIgKiBjb3ModCAqIChzcGVlZCAqIDAuNykgKyBmaSAqIDIuMTcpKTtcbiAgICAgICAgZmxvYXQgZCA9IGxlbmd0aChzaGFwZVVWICsgdHJhaik7XG4gICAgICAgIGVkZ2UgKz0gcG93KDEuMCAtIGNsYW1wKGQsIDAuMCwgMS4wKSwgNC4wKTtcbiAgICAgIH1cbiAgICAgIGVkZ2UgPSAxLiAtIHNtb290aHN0ZXAoLjY1LCAuOSwgZWRnZSk7XG4gICAgICBlZGdlID0gcG93KGVkZ2UsIDQuKTtcbiAgICB9XG5cbiAgICBlZGdlID0gbWl4KHNtb290aHN0ZXAoLjkgLSAyLiAqIGZ3aWR0aChlZGdlKSwgLjksIGVkZ2UpLCBlZGdlLCBzbW9vdGhzdGVwKDAuMCwgMC40LCB1X2NvbnRvdXIpKTtcblxuICB9XG5cbiAgZmxvYXQgb3BhY2l0eSA9IDAuO1xuICBpZiAodV9pc0ltYWdlID09IHRydWUpIHtcbiAgICBvcGFjaXR5ID0gaW1nLmc7XG4gICAgZmxvYXQgZnJhbWUgPSBnZXRJbWdGcmFtZSh2X2ltYWdlVVYsIDAuKTtcbiAgICBvcGFjaXR5ICo9IGZyYW1lO1xuICB9IGVsc2Uge1xuICAgIG9wYWNpdHkgPSAxLiAtIHNtb290aHN0ZXAoLjkgLSAyLiAqIGZ3aWR0aChlZGdlKSwgLjksIGVkZ2UpO1xuICAgIGlmICh1X3NoYXBlIDwgMi4pIHtcbiAgICAgIGVkZ2UgPSAxLjIgKiBlZGdlO1xuICAgIH0gZWxzZSBpZiAodV9zaGFwZSA8IDUuKSB7XG4gICAgICBlZGdlID0gMS44ICogcG93KGVkZ2UsIDEuNSk7XG4gICAgfVxuICB9XG5cbiAgZmxvYXQgZGlhZ0JMdG9UUiA9IHJvdGF0ZWRVVi54IC0gcm90YXRlZFVWLnk7XG4gIGZsb2F0IGRpYWdUTHRvQlIgPSByb3RhdGVkVVYueCArIHJvdGF0ZWRVVi55O1xuXG4gIHZlYzMgY29sb3IgPSB2ZWMzKDAuKTtcbiAgdmVjMyBjb2xvcjEgPSB2ZWMzKC45OCwgMC45OCwgMS4pO1xuICB2ZWMzIGNvbG9yMiA9IHZlYzMoLjEsIC4xLCAuMSArIC4xICogc21vb3Roc3RlcCguNywgMS4zLCBkaWFnVEx0b0JSKSk7XG5cbiAgdmVjMiBncmFkX3V2ID0gdXYgLSAuNTtcblxuICBmbG9hdCBkaXN0ID0gbGVuZ3RoKGdyYWRfdXYgKyB2ZWMyKDAuLCAuMiAqIGRpYWdCTHRvVFIpKTtcbiAgZ3JhZF91diA9IHJvdGF0ZShncmFkX3V2LCAoLjI1IC0gLjIgKiBkaWFnQkx0b1RSKSAqIFBJKTtcbiAgZmxvYXQgZGlyZWN0aW9uID0gZ3JhZF91di54O1xuXG4gIGZsb2F0IGJ1bXAgPSBwb3coMS44ICogZGlzdCwgMS4yKTtcbiAgYnVtcCA9IDEuIC0gYnVtcDtcbiAgYnVtcCAqPSBwb3codXYueSwgLjMpO1xuXG5cbiAgZmxvYXQgdGhpbl9zdHJpcF8xX3JhdGlvID0gLjEyIC8gY3ljbGVXaWR0aCAqICgxLiAtIC40ICogYnVtcCk7XG4gIGZsb2F0IHRoaW5fc3RyaXBfMl9yYXRpbyA9IC4wNyAvIGN5Y2xlV2lkdGggKiAoMS4gKyAuNCAqIGJ1bXApO1xuICBmbG9hdCB3aWRlX3N0cmlwX3JhdGlvID0gKDEuIC0gdGhpbl9zdHJpcF8xX3JhdGlvIC0gdGhpbl9zdHJpcF8yX3JhdGlvKTtcblxuICBmbG9hdCB0aGluX3N0cmlwXzFfd2lkdGggPSBjeWNsZVdpZHRoICogdGhpbl9zdHJpcF8xX3JhdGlvO1xuICBmbG9hdCB0aGluX3N0cmlwXzJfd2lkdGggPSBjeWNsZVdpZHRoICogdGhpbl9zdHJpcF8yX3JhdGlvO1xuXG4gIGZsb2F0IG5vaXNlID0gc25vaXNlKHV2IC0gdCk7XG5cbiAgZWRnZSArPSAoMS4gLSBlZGdlKSAqIHVfZGlzdG9ydGlvbiAqIG5vaXNlO1xuXG4gIGRpcmVjdGlvbiArPSBkaWFnQkx0b1RSO1xuICBmbG9hdCBjb250b3VyID0gMC47XG4gIGRpcmVjdGlvbiAtPSAyLiAqIG5vaXNlICogZGlhZ0JMdG9UUiAqIChzbW9vdGhzdGVwKDAuLCAxLiwgZWRnZSkgKiAoMS4wIC0gc21vb3Roc3RlcCgwLiwgMS4sIGVkZ2UpKSk7XG4gIGRpcmVjdGlvbiAqPSBtaXgoMS4sIDEuIC0gZWRnZSwgc21vb3Roc3RlcCguNSwgMS4sIHVfY29udG91cikpO1xuICBkaXJlY3Rpb24gLT0gMS43ICogZWRnZSAqIHNtb290aHN0ZXAoLjUsIDEuLCB1X2NvbnRvdXIpO1xuICBkaXJlY3Rpb24gKz0gLjIgKiBwb3codV9jb250b3VyLCA0LikgKiAoMS4wIC0gc21vb3Roc3RlcCgwLiwgMS4sIGVkZ2UpKTtcblxuICBidW1wICo9IGNsYW1wKHBvdyh1di55LCAuMSksIC4zLCAxLik7XG4gIGRpcmVjdGlvbiAqPSAoLjEgKyAoMS4xIC0gZWRnZSkgKiBidW1wKTtcblxuICBkaXJlY3Rpb24gKj0gKC40ICsgLjYgKiAoMS4wIC0gc21vb3Roc3RlcCguNSwgMS4sIGVkZ2UpKSk7XG4gIGRpcmVjdGlvbiArPSAuMTggKiAoc21vb3Roc3RlcCguMSwgLjIsIHV2LnkpICogKDEuMCAtIHNtb290aHN0ZXAoLjIsIC40LCB1di55KSkpO1xuICBkaXJlY3Rpb24gKz0gLjAzICogKHNtb290aHN0ZXAoLjEsIC4yLCAxLiAtIHV2LnkpICogKDEuMCAtIHNtb290aHN0ZXAoLjIsIC40LCAxLiAtIHV2LnkpKSk7XG5cbiAgZGlyZWN0aW9uICo9ICguNSArIC41ICogcG93KHV2LnksIDIuKSk7XG4gIGRpcmVjdGlvbiAqPSBjeWNsZVdpZHRoO1xuICBkaXJlY3Rpb24gLT0gdDtcblxuXG4gIGZsb2F0IGNvbG9yRGlzcGVyc2lvbiA9ICgxLiAtIGJ1bXApO1xuICBjb2xvckRpc3BlcnNpb24gPSBjbGFtcChjb2xvckRpc3BlcnNpb24sIDAuLCAxLik7XG4gIGZsb2F0IGRpc3BlcnNpb25SZWQgPSBjb2xvckRpc3BlcnNpb247XG4gIGRpc3BlcnNpb25SZWQgKz0gLjAzICogYnVtcCAqIG5vaXNlO1xuICBkaXNwZXJzaW9uUmVkICs9IDUuICogKHNtb290aHN0ZXAoLS4xLCAuMiwgdXYueSkgKiAoMS4wIC0gc21vb3Roc3RlcCguMSwgLjUsIHV2LnkpKSkgKiAoc21vb3Roc3RlcCguNCwgLjYsIGJ1bXApICogKDEuMCAtIHNtb290aHN0ZXAoLjQsIDEuLCBidW1wKSkpO1xuICBkaXNwZXJzaW9uUmVkIC09IGRpYWdCTHRvVFI7XG5cbiAgZmxvYXQgZGlzcGVyc2lvbkJsdWUgPSBjb2xvckRpc3BlcnNpb247XG4gIGRpc3BlcnNpb25CbHVlICo9IDEuMztcbiAgZGlzcGVyc2lvbkJsdWUgKz0gKHNtb290aHN0ZXAoMC4sIC40LCB1di55KSAqICgxLjAgLSBzbW9vdGhzdGVwKC4xLCAuOCwgdXYueSkpKSAqIChzbW9vdGhzdGVwKC40LCAuNiwgYnVtcCkgKiAoMS4wIC0gc21vb3Roc3RlcCguNCwgLjgsIGJ1bXApKSk7XG4gIGRpc3BlcnNpb25CbHVlIC09IC4yICogZWRnZTtcblxuICBkaXNwZXJzaW9uUmVkICo9ICh1X3NoaWZ0UmVkIC8gMjAuKTtcbiAgZGlzcGVyc2lvbkJsdWUgKj0gKHVfc2hpZnRCbHVlIC8gMjAuKTtcblxuICBmbG9hdCBibHVyID0gMC47XG4gIGZsb2F0IHJFeHRyYUJsdXIgPSAwLjtcbiAgZmxvYXQgZ0V4dHJhQmx1ciA9IDAuO1xuICBpZiAodV9pc0ltYWdlID09IHRydWUpIHtcbiAgICBmbG9hdCBzb2Z0bmVzcyA9IDAuMDUgKiB1X3NvZnRuZXNzO1xuICAgIGJsdXIgPSBzb2Z0bmVzcyArIC41ICogc21vb3Roc3RlcCgxLiwgMTAuLCB1X3JlcGV0aXRpb24pICogc21vb3Roc3RlcCguMCwgMS4sIGVkZ2UpO1xuICAgIGZsb2F0IHNtYWxsQ2FudmFzVCA9IDEuMCAtIHNtb290aHN0ZXAoMTAwLiwgNTAwLiwgbWluKHVfcmVzb2x1dGlvbi54LCB1X3Jlc29sdXRpb24ueSkpO1xuICAgIGJsdXIgKz0gc21hbGxDYW52YXNUICogc21vb3Roc3RlcCguMCwgMS4sIGVkZ2UpO1xuICAgIHJFeHRyYUJsdXIgPSBzb2Z0bmVzcyAqICgwLjA1ICsgLjEgKiAodV9zaGlmdFJlZCAvIDIwLikgKiBidW1wKTtcbiAgICBnRXh0cmFCbHVyID0gc29mdG5lc3MgKiAwLjA1IC8gbWF4KDAuMDAxLCBhYnMoMS4gLSBkaWFnQkx0b1RSKSk7XG4gIH0gZWxzZSB7XG4gICAgYmx1ciA9IHVfc29mdG5lc3MgLyAxNS4gKyAuMyAqIGNvbnRvdXI7XG4gIH1cblxuICB2ZWMzIHcgPSB2ZWMzKHRoaW5fc3RyaXBfMV93aWR0aCwgdGhpbl9zdHJpcF8yX3dpZHRoLCB3aWRlX3N0cmlwX3JhdGlvKTtcbiAgd1sxXSAtPSAuMDIgKiBzbW9vdGhzdGVwKC4wLCAxLiwgZWRnZSArIGJ1bXApO1xuICBmbG9hdCBzdHJpcGVfciA9IGZyYWN0KGRpcmVjdGlvbiArIGRpc3BlcnNpb25SZWQpO1xuICBmbG9hdCByID0gZ2V0Q29sb3JDaGFuZ2VzKGNvbG9yMS5yLCBjb2xvcjIuciwgc3RyaXBlX3IsIHcsIGJsdXIgKyBmd2lkdGgoc3RyaXBlX3IpICsgckV4dHJhQmx1ciwgYnVtcCwgdV9jb2xvclRpbnQucik7XG4gIGZsb2F0IHN0cmlwZV9nID0gZnJhY3QoZGlyZWN0aW9uKTtcbiAgZmxvYXQgZyA9IGdldENvbG9yQ2hhbmdlcyhjb2xvcjEuZywgY29sb3IyLmcsIHN0cmlwZV9nLCB3LCBibHVyICsgZndpZHRoKHN0cmlwZV9nKSArIGdFeHRyYUJsdXIsIGJ1bXAsIHVfY29sb3JUaW50LmcpO1xuICBmbG9hdCBzdHJpcGVfYiA9IGZyYWN0KGRpcmVjdGlvbiAtIGRpc3BlcnNpb25CbHVlKTtcbiAgZmxvYXQgYiA9IGdldENvbG9yQ2hhbmdlcyhjb2xvcjEuYiwgY29sb3IyLmIsIHN0cmlwZV9iLCB3LCBibHVyICsgZndpZHRoKHN0cmlwZV9iKSwgYnVtcCwgdV9jb2xvclRpbnQuYik7XG5cbiAgY29sb3IgPSB2ZWMzKHIsIGcsIGIpO1xuICBjb2xvciAqPSBvcGFjaXR5O1xuXG4gIHZlYzMgYmdDb2xvciA9IHVfY29sb3JCYWNrLnJnYiAqIHVfY29sb3JCYWNrLmE7XG4gIGNvbG9yID0gY29sb3IgKyBiZ0NvbG9yICogKDEuIC0gb3BhY2l0eSk7XG4gIG9wYWNpdHkgPSBvcGFjaXR5ICsgdV9jb2xvckJhY2suYSAqICgxLiAtIG9wYWNpdHkpO1xuXG4gICR7Y29sb3JCYW5kaW5nRml4fVxuXG4gIGZyYWdDb2xvciA9IHZlYzQoY29sb3IsIG9wYWNpdHkpO1xufVxuYDtcbmNvbnN0IFBPSVNTT05fQ09ORklHX09QVElNSVpFRCA9IHtcbiAgbWVhc3VyZVBlcmZvcm1hbmNlOiBmYWxzZSxcbiAgLy8gU2V0IHRvIHRydWUgdG8gc2VlIHBlcmZvcm1hbmNlIG1ldHJpY3NcbiAgd29ya2luZ1NpemU6IDUxMixcbiAgLy8gU2l6ZSB0byBzb2x2ZSBQb2lzc29uIGF0ICh3aWxsIHVwc2NhbGUgdG8gb3JpZ2luYWwgc2l6ZSlcbiAgaXRlcmF0aW9uczogNDBcbiAgLy8gU09SIGNvbnZlcmdlcyB+Mi0yMHggZmFzdGVyIHRoYW4gc3RhbmRhcmQgR2F1c3MtU2VpZGVsXG59O1xuZnVuY3Rpb24gdG9Qcm9jZXNzZWRMaXF1aWRNZXRhbChmaWxlKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gIGNvbnN0IGlzQmxvYiA9IHR5cGVvZiBmaWxlID09PSBcInN0cmluZ1wiICYmIGZpbGUuc3RhcnRzV2l0aChcImJsb2I6XCIpO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGlmICghZmlsZSB8fCAhY3R4KSB7XG4gICAgICByZWplY3QobmV3IEVycm9yKFwiSW52YWxpZCBmaWxlIG9yIGNhbnZhcyBjb250ZXh0XCIpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYmxvYkNvbnRlbnRUeXBlUHJvbWlzZSA9IGlzQmxvYiAmJiBmZXRjaChmaWxlKS50aGVuKChyZXMpID0+IHJlcy5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKSk7XG4gICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgaW1nLmNyb3NzT3JpZ2luID0gXCJhbm9ueW1vdXNcIjtcbiAgICBjb25zdCB0b3RhbFN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGltZy5vbmxvYWQgPSBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgaXNTVkc7XG4gICAgICBjb25zdCBibG9iQ29udGVudFR5cGUgPSBhd2FpdCBibG9iQ29udGVudFR5cGVQcm9taXNlO1xuICAgICAgaWYgKGJsb2JDb250ZW50VHlwZSkge1xuICAgICAgICBpc1NWRyA9IGJsb2JDb250ZW50VHlwZSA9PT0gXCJpbWFnZS9zdmcreG1sXCI7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmaWxlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlzU1ZHID0gZmlsZS5lbmRzV2l0aChcIi5zdmdcIikgfHwgZmlsZS5zdGFydHNXaXRoKFwiZGF0YTppbWFnZS9zdmcreG1sXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNTVkcgPSBmaWxlLnR5cGUgPT09IFwiaW1hZ2Uvc3ZnK3htbFwiO1xuICAgICAgfVxuICAgICAgbGV0IG9yaWdpbmFsV2lkdGggPSBpbWcud2lkdGggfHwgaW1nLm5hdHVyYWxXaWR0aDtcbiAgICAgIGxldCBvcmlnaW5hbEhlaWdodCA9IGltZy5oZWlnaHQgfHwgaW1nLm5hdHVyYWxIZWlnaHQ7XG4gICAgICBpZiAoaXNTVkcpIHtcbiAgICAgICAgY29uc3Qgc3ZnTWF4U2l6ZSA9IDQwOTY7XG4gICAgICAgIGNvbnN0IGFzcGVjdFJhdGlvID0gb3JpZ2luYWxXaWR0aCAvIG9yaWdpbmFsSGVpZ2h0O1xuICAgICAgICBpZiAob3JpZ2luYWxXaWR0aCA+IG9yaWdpbmFsSGVpZ2h0KSB7XG4gICAgICAgICAgb3JpZ2luYWxXaWR0aCA9IHN2Z01heFNpemU7XG4gICAgICAgICAgb3JpZ2luYWxIZWlnaHQgPSBzdmdNYXhTaXplIC8gYXNwZWN0UmF0aW87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3JpZ2luYWxIZWlnaHQgPSBzdmdNYXhTaXplO1xuICAgICAgICAgIG9yaWdpbmFsV2lkdGggPSBzdmdNYXhTaXplICogYXNwZWN0UmF0aW87XG4gICAgICAgIH1cbiAgICAgICAgaW1nLndpZHRoID0gb3JpZ2luYWxXaWR0aDtcbiAgICAgICAgaW1nLmhlaWdodCA9IG9yaWdpbmFsSGVpZ2h0O1xuICAgICAgfVxuICAgICAgY29uc3QgbWluRGltZW5zaW9uID0gTWF0aC5taW4ob3JpZ2luYWxXaWR0aCwgb3JpZ2luYWxIZWlnaHQpO1xuICAgICAgY29uc3QgdGFyZ2V0U2l6ZSA9IFBPSVNTT05fQ09ORklHX09QVElNSVpFRC53b3JraW5nU2l6ZTtcbiAgICAgIGNvbnN0IHNjYWxlRmFjdG9yID0gdGFyZ2V0U2l6ZSAvIG1pbkRpbWVuc2lvbjtcbiAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC5yb3VuZChvcmlnaW5hbFdpZHRoICogc2NhbGVGYWN0b3IpO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5yb3VuZChvcmlnaW5hbEhlaWdodCAqIHNjYWxlRmFjdG9yKTtcbiAgICAgIGlmIChQT0lTU09OX0NPTkZJR19PUFRJTUlaRUQubWVhc3VyZVBlcmZvcm1hbmNlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbUHJvY2Vzc2luZyBNb2RlXWApO1xuICAgICAgICBjb25zb2xlLmxvZyhgICBPcmlnaW5hbDogJHtvcmlnaW5hbFdpZHRofVxceEQ3JHtvcmlnaW5hbEhlaWdodH1gKTtcbiAgICAgICAgY29uc29sZS5sb2coYCAgV29ya2luZzogJHt3aWR0aH1cXHhENyR7aGVpZ2h0fSAoJHsoc2NhbGVGYWN0b3IgKiAxMDApLnRvRml4ZWQoMSl9JSBzY2FsZSlgKTtcbiAgICAgICAgaWYgKHNjYWxlRmFjdG9yIDwgMSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGAgIFNwZWVkdXA6IH4ke01hdGgucm91bmQoMSAvIChzY2FsZUZhY3RvciAqIHNjYWxlRmFjdG9yKSl9XFx4RDdgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2FudmFzLndpZHRoID0gb3JpZ2luYWxXaWR0aDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBvcmlnaW5hbEhlaWdodDtcbiAgICAgIGNvbnN0IHNoYXBlQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgIHNoYXBlQ2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICBzaGFwZUNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICBjb25zdCBzaGFwZUN0eCA9IHNoYXBlQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIHNoYXBlQ3R4LmRyYXdJbWFnZShpbWcsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY29uc3Qgc3RhcnRNYXNrID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCBzaGFwZUltYWdlRGF0YSA9IHNoYXBlQ3R4LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBzaGFwZUltYWdlRGF0YS5kYXRhO1xuICAgICAgY29uc3Qgc2hhcGVNYXNrID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQpO1xuICAgICAgY29uc3QgYm91bmRhcnlNYXNrID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQpO1xuICAgICAgbGV0IHNoYXBlUGl4ZWxDb3VudCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWR4ID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQsIGlkeCsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBkYXRhW2kgKyAzXTtcbiAgICAgICAgY29uc3QgaXNTaGFwZSA9IGEgPT09IDAgPyAwIDogMTtcbiAgICAgICAgc2hhcGVNYXNrW2lkeF0gPSBpc1NoYXBlO1xuICAgICAgICBzaGFwZVBpeGVsQ291bnQgKz0gaXNTaGFwZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJvdW5kYXJ5SW5kaWNlcyA9IFtdO1xuICAgICAgY29uc3QgaW50ZXJpb3JJbmRpY2VzID0gW107XG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgIGNvbnN0IGlkeCA9IHkgKiB3aWR0aCArIHg7XG4gICAgICAgICAgaWYgKCFzaGFwZU1hc2tbaWR4XSkgY29udGludWU7XG4gICAgICAgICAgbGV0IGlzQm91bmRhcnkgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoeCA9PT0gMCB8fCB4ID09PSB3aWR0aCAtIDEgfHwgeSA9PT0gMCB8fCB5ID09PSBoZWlnaHQgLSAxKSB7XG4gICAgICAgICAgICBpc0JvdW5kYXJ5ID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXNCb3VuZGFyeSA9ICFzaGFwZU1hc2tbaWR4IC0gMV0gfHwgLy8gbGVmdFxuICAgICAgICAgICAgIXNoYXBlTWFza1tpZHggKyAxXSB8fCAvLyByaWdodFxuICAgICAgICAgICAgIXNoYXBlTWFza1tpZHggLSB3aWR0aF0gfHwgLy8gdG9wXG4gICAgICAgICAgICAhc2hhcGVNYXNrW2lkeCArIHdpZHRoXSB8fCAvLyBib3R0b21cbiAgICAgICAgICAgICFzaGFwZU1hc2tbaWR4IC0gd2lkdGggLSAxXSB8fCAvLyB0b3AtbGVmdFxuICAgICAgICAgICAgIXNoYXBlTWFza1tpZHggLSB3aWR0aCArIDFdIHx8IC8vIHRvcC1yaWdodFxuICAgICAgICAgICAgIXNoYXBlTWFza1tpZHggKyB3aWR0aCAtIDFdIHx8IC8vIGJvdHRvbS1sZWZ0XG4gICAgICAgICAgICAhc2hhcGVNYXNrW2lkeCArIHdpZHRoICsgMV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0JvdW5kYXJ5KSB7XG4gICAgICAgICAgICBib3VuZGFyeU1hc2tbaWR4XSA9IDE7XG4gICAgICAgICAgICBib3VuZGFyeUluZGljZXMucHVzaChpZHgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnRlcmlvckluZGljZXMucHVzaChpZHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKFBPSVNTT05fQ09ORklHX09QVElNSVpFRC5tZWFzdXJlUGVyZm9ybWFuY2UpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFtNYXNrIEJ1aWxkaW5nXSBUaW1lOiAkeyhwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0TWFzaykudG9GaXhlZCgyKX1tc2ApO1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICBgICBTaGFwZSBwaXhlbHM6ICR7c2hhcGVQaXhlbENvdW50fSAvICR7d2lkdGggKiBoZWlnaHR9ICgkeyhzaGFwZVBpeGVsQ291bnQgLyAod2lkdGggKiBoZWlnaHQpICogMTAwKS50b0ZpeGVkKDEpfSUpYFxuICAgICAgICApO1xuICAgICAgICBjb25zb2xlLmxvZyhgICBJbnRlcmlvciBwaXhlbHM6ICR7aW50ZXJpb3JJbmRpY2VzLmxlbmd0aH1gKTtcbiAgICAgICAgY29uc29sZS5sb2coYCAgQm91bmRhcnkgcGl4ZWxzOiAke2JvdW5kYXJ5SW5kaWNlcy5sZW5ndGh9YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBzcGFyc2VEYXRhID0gYnVpbGRTcGFyc2VEYXRhKFxuICAgICAgICBzaGFwZU1hc2ssXG4gICAgICAgIGJvdW5kYXJ5TWFzayxcbiAgICAgICAgbmV3IFVpbnQzMkFycmF5KGludGVyaW9ySW5kaWNlcyksXG4gICAgICAgIG5ldyBVaW50MzJBcnJheShib3VuZGFyeUluZGljZXMpLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICApO1xuICAgICAgY29uc3Qgc3RhcnRTb2x2ZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgdSA9IHNvbHZlUG9pc3NvblNwYXJzZShzcGFyc2VEYXRhLCBzaGFwZU1hc2ssIGJvdW5kYXJ5TWFzaywgd2lkdGgsIGhlaWdodCk7XG4gICAgICBpZiAoUE9JU1NPTl9DT05GSUdfT1BUSU1JWkVELm1lYXN1cmVQZXJmb3JtYW5jZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhgW1BvaXNzb24gU29sdmVdIFRpbWU6ICR7KHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRTb2x2ZSkudG9GaXhlZCgyKX1tc2ApO1xuICAgICAgfVxuICAgICAgbGV0IG1heFZhbCA9IDA7XG4gICAgICBsZXQgZmluYWxJbWFnZURhdGE7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGludGVyaW9ySW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBpZHggPSBpbnRlcmlvckluZGljZXNbaV07XG4gICAgICAgIGlmICh1W2lkeF0gPiBtYXhWYWwpIG1heFZhbCA9IHVbaWR4XTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRlbXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgdGVtcENhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgdGVtcENhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICBjb25zdCB0ZW1wQ3R4ID0gdGVtcENhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICBjb25zdCB0ZW1wSW1nID0gdGVtcEN0eC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIGhlaWdodCk7XG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgIGNvbnN0IGlkeCA9IHkgKiB3aWR0aCArIHg7XG4gICAgICAgICAgY29uc3QgcHggPSBpZHggKiA0O1xuICAgICAgICAgIGlmICghc2hhcGVNYXNrW2lkeF0pIHtcbiAgICAgICAgICAgIHRlbXBJbWcuZGF0YVtweF0gPSAyNTU7XG4gICAgICAgICAgICB0ZW1wSW1nLmRhdGFbcHggKyAxXSA9IDI1NTtcbiAgICAgICAgICAgIHRlbXBJbWcuZGF0YVtweCArIDJdID0gMjU1O1xuICAgICAgICAgICAgdGVtcEltZy5kYXRhW3B4ICsgM10gPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwb2lzc29uUmF0aW8gPSB1W2lkeF0gLyBtYXhWYWw7XG4gICAgICAgICAgICBjb25zdCBncmF5ID0gMjU1ICogKDEgLSBwb2lzc29uUmF0aW8pO1xuICAgICAgICAgICAgdGVtcEltZy5kYXRhW3B4XSA9IGdyYXk7XG4gICAgICAgICAgICB0ZW1wSW1nLmRhdGFbcHggKyAxXSA9IGdyYXk7XG4gICAgICAgICAgICB0ZW1wSW1nLmRhdGFbcHggKyAyXSA9IGdyYXk7XG4gICAgICAgICAgICB0ZW1wSW1nLmRhdGFbcHggKyAzXSA9IDI1NTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRlbXBDdHgucHV0SW1hZ2VEYXRhKHRlbXBJbWcsIDAsIDApO1xuICAgICAgY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IHRydWU7XG4gICAgICBjdHguaW1hZ2VTbW9vdGhpbmdRdWFsaXR5ID0gXCJoaWdoXCI7XG4gICAgICBjdHguZHJhd0ltYWdlKHRlbXBDYW52YXMsIDAsIDAsIHdpZHRoLCBoZWlnaHQsIDAsIDAsIG9yaWdpbmFsV2lkdGgsIG9yaWdpbmFsSGVpZ2h0KTtcbiAgICAgIGNvbnN0IG91dEltZyA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgb3JpZ2luYWxXaWR0aCwgb3JpZ2luYWxIZWlnaHQpO1xuICAgICAgY29uc3Qgb3JpZ2luYWxDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgb3JpZ2luYWxDYW52YXMud2lkdGggPSBvcmlnaW5hbFdpZHRoO1xuICAgICAgb3JpZ2luYWxDYW52YXMuaGVpZ2h0ID0gb3JpZ2luYWxIZWlnaHQ7XG4gICAgICBjb25zdCBvcmlnaW5hbEN0eCA9IG9yaWdpbmFsQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIG9yaWdpbmFsQ3R4LmRyYXdJbWFnZShpbWcsIDAsIDAsIG9yaWdpbmFsV2lkdGgsIG9yaWdpbmFsSGVpZ2h0KTtcbiAgICAgIGNvbnN0IG9yaWdpbmFsRGF0YSA9IG9yaWdpbmFsQ3R4LmdldEltYWdlRGF0YSgwLCAwLCBvcmlnaW5hbFdpZHRoLCBvcmlnaW5hbEhlaWdodCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dEltZy5kYXRhLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgIGNvbnN0IGEgPSBvcmlnaW5hbERhdGEuZGF0YVtpICsgM107XG4gICAgICAgIGNvbnN0IHVwc2NhbGVkQWxwaGEgPSBvdXRJbWcuZGF0YVtpICsgM107XG4gICAgICAgIGlmIChhID09PSAwKSB7XG4gICAgICAgICAgb3V0SW1nLmRhdGFbaV0gPSAyNTU7XG4gICAgICAgICAgb3V0SW1nLmRhdGFbaSArIDFdID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXRJbWcuZGF0YVtpXSA9IHVwc2NhbGVkQWxwaGEgPT09IDAgPyAwIDogb3V0SW1nLmRhdGFbaV07XG4gICAgICAgICAgb3V0SW1nLmRhdGFbaSArIDFdID0gYTtcbiAgICAgICAgfVxuICAgICAgICBvdXRJbWcuZGF0YVtpICsgMl0gPSAyNTU7XG4gICAgICAgIG91dEltZy5kYXRhW2kgKyAzXSA9IDI1NTtcbiAgICAgIH1cbiAgICAgIGN0eC5wdXRJbWFnZURhdGEob3V0SW1nLCAwLCAwKTtcbiAgICAgIGZpbmFsSW1hZ2VEYXRhID0gb3V0SW1nO1xuICAgICAgY2FudmFzLnRvQmxvYigoYmxvYikgPT4ge1xuICAgICAgICBpZiAoIWJsb2IpIHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiRmFpbGVkIHRvIGNyZWF0ZSBQTkcgYmxvYlwiKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChQT0lTU09OX0NPTkZJR19PUFRJTUlaRUQubWVhc3VyZVBlcmZvcm1hbmNlKSB7XG4gICAgICAgICAgY29uc3QgdG90YWxUaW1lID0gcGVyZm9ybWFuY2Uubm93KCkgLSB0b3RhbFN0YXJ0VGltZTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgW1RvdGFsIFByb2Nlc3NpbmcgVGltZV0gJHt0b3RhbFRpbWUudG9GaXhlZCgyKX1tc2ApO1xuICAgICAgICAgIGlmIChzY2FsZUZhY3RvciA8IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGVzdGltYXRlZEZ1bGxSZXNUaW1lID0gdG90YWxUaW1lICogTWF0aC5wb3cob3JpZ2luYWxXaWR0aCAqIG9yaWdpbmFsSGVpZ2h0IC8gKHdpZHRoICogaGVpZ2h0KSwgMS41KTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbRXN0aW1hdGVkIHRpbWUgYXQgZnVsbCByZXNvbHV0aW9uXSB+JHtlc3RpbWF0ZWRGdWxsUmVzVGltZS50b0ZpeGVkKDApfW1zYCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgYFtUaW1lIHNhdmVkXSB+JHsoZXN0aW1hdGVkRnVsbFJlc1RpbWUgLSB0b3RhbFRpbWUpLnRvRml4ZWQoMCl9bXMgKCR7TWF0aC5yb3VuZChlc3RpbWF0ZWRGdWxsUmVzVGltZSAvIHRvdGFsVGltZSl9XFx4RDcgZmFzdGVyKWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgIGltYWdlRGF0YTogZmluYWxJbWFnZURhdGEsXG4gICAgICAgICAgcG5nQmxvYjogYmxvYlxuICAgICAgICB9KTtcbiAgICAgIH0sIFwiaW1hZ2UvcG5nXCIpO1xuICAgIH07XG4gICAgaW1nLm9uZXJyb3IgPSAoKSA9PiByZWplY3QobmV3IEVycm9yKFwiRmFpbGVkIHRvIGxvYWQgaW1hZ2VcIikpO1xuICAgIGltZy5zcmMgPSB0eXBlb2YgZmlsZSA9PT0gXCJzdHJpbmdcIiA/IGZpbGUgOiBVUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGJ1aWxkU3BhcnNlRGF0YShzaGFwZU1hc2ssIGJvdW5kYXJ5TWFzaywgaW50ZXJpb3JQaXhlbHMsIGJvdW5kYXJ5UGl4ZWxzLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIGNvbnN0IHBpeGVsQ291bnQgPSBpbnRlcmlvclBpeGVscy5sZW5ndGg7XG4gIGNvbnN0IG5laWdoYm9ySW5kaWNlcyA9IG5ldyBJbnQzMkFycmF5KHBpeGVsQ291bnQgKiA0KTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwaXhlbENvdW50OyBpKyspIHtcbiAgICBjb25zdCBpZHggPSBpbnRlcmlvclBpeGVsc1tpXTtcbiAgICBjb25zdCB4ID0gaWR4ICUgd2lkdGg7XG4gICAgY29uc3QgeSA9IE1hdGguZmxvb3IoaWR4IC8gd2lkdGgpO1xuICAgIG5laWdoYm9ySW5kaWNlc1tpICogNCArIDBdID0geCA8IHdpZHRoIC0gMSAmJiBzaGFwZU1hc2tbaWR4ICsgMV0gPyBpZHggKyAxIDogLTE7XG4gICAgbmVpZ2hib3JJbmRpY2VzW2kgKiA0ICsgMV0gPSB4ID4gMCAmJiBzaGFwZU1hc2tbaWR4IC0gMV0gPyBpZHggLSAxIDogLTE7XG4gICAgbmVpZ2hib3JJbmRpY2VzW2kgKiA0ICsgMl0gPSB5ID4gMCAmJiBzaGFwZU1hc2tbaWR4IC0gd2lkdGhdID8gaWR4IC0gd2lkdGggOiAtMTtcbiAgICBuZWlnaGJvckluZGljZXNbaSAqIDQgKyAzXSA9IHkgPCBoZWlnaHQgLSAxICYmIHNoYXBlTWFza1tpZHggKyB3aWR0aF0gPyBpZHggKyB3aWR0aCA6IC0xO1xuICB9XG4gIHJldHVybiB7XG4gICAgaW50ZXJpb3JQaXhlbHMsXG4gICAgYm91bmRhcnlQaXhlbHMsXG4gICAgcGl4ZWxDb3VudCxcbiAgICBuZWlnaGJvckluZGljZXNcbiAgfTtcbn1cbmZ1bmN0aW9uIHNvbHZlUG9pc3NvblNwYXJzZShzcGFyc2VEYXRhLCBzaGFwZU1hc2ssIGJvdW5kYXJ5TWFzaywgd2lkdGgsIGhlaWdodCkge1xuICBjb25zdCBJVEVSQVRJT05TID0gUE9JU1NPTl9DT05GSUdfT1BUSU1JWkVELml0ZXJhdGlvbnM7XG4gIGNvbnN0IEMgPSAwLjAxO1xuICBjb25zdCB1ID0gbmV3IEZsb2F0MzJBcnJheSh3aWR0aCAqIGhlaWdodCk7XG4gIGNvbnN0IHsgaW50ZXJpb3JQaXhlbHMsIG5laWdoYm9ySW5kaWNlcywgcGl4ZWxDb3VudCB9ID0gc3BhcnNlRGF0YTtcbiAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gIGNvbnN0IG9tZWdhID0gMS45O1xuICBjb25zdCByZWRQaXhlbHMgPSBbXTtcbiAgY29uc3QgYmxhY2tQaXhlbHMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwaXhlbENvdW50OyBpKyspIHtcbiAgICBjb25zdCBpZHggPSBpbnRlcmlvclBpeGVsc1tpXTtcbiAgICBjb25zdCB4ID0gaWR4ICUgd2lkdGg7XG4gICAgY29uc3QgeSA9IE1hdGguZmxvb3IoaWR4IC8gd2lkdGgpO1xuICAgIGlmICgoeCArIHkpICUgMiA9PT0gMCkge1xuICAgICAgcmVkUGl4ZWxzLnB1c2goaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJsYWNrUGl4ZWxzLnB1c2goaSk7XG4gICAgfVxuICB9XG4gIGZvciAobGV0IGl0ZXIgPSAwOyBpdGVyIDwgSVRFUkFUSU9OUzsgaXRlcisrKSB7XG4gICAgZm9yIChjb25zdCBpIG9mIHJlZFBpeGVscykge1xuICAgICAgY29uc3QgaWR4ID0gaW50ZXJpb3JQaXhlbHNbaV07XG4gICAgICBjb25zdCBlYXN0SWR4ID0gbmVpZ2hib3JJbmRpY2VzW2kgKiA0ICsgMF07XG4gICAgICBjb25zdCB3ZXN0SWR4ID0gbmVpZ2hib3JJbmRpY2VzW2kgKiA0ICsgMV07XG4gICAgICBjb25zdCBub3J0aElkeCA9IG5laWdoYm9ySW5kaWNlc1tpICogNCArIDJdO1xuICAgICAgY29uc3Qgc291dGhJZHggPSBuZWlnaGJvckluZGljZXNbaSAqIDQgKyAzXTtcbiAgICAgIGxldCBzdW1OID0gMDtcbiAgICAgIGlmIChlYXN0SWR4ID49IDApIHN1bU4gKz0gdVtlYXN0SWR4XTtcbiAgICAgIGlmICh3ZXN0SWR4ID49IDApIHN1bU4gKz0gdVt3ZXN0SWR4XTtcbiAgICAgIGlmIChub3J0aElkeCA+PSAwKSBzdW1OICs9IHVbbm9ydGhJZHhdO1xuICAgICAgaWYgKHNvdXRoSWR4ID49IDApIHN1bU4gKz0gdVtzb3V0aElkeF07XG4gICAgICBjb25zdCBuZXdWYWx1ZSA9IChDICsgc3VtTikgLyA0O1xuICAgICAgdVtpZHhdID0gb21lZ2EgKiBuZXdWYWx1ZSArICgxIC0gb21lZ2EpICogdVtpZHhdO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGkgb2YgYmxhY2tQaXhlbHMpIHtcbiAgICAgIGNvbnN0IGlkeCA9IGludGVyaW9yUGl4ZWxzW2ldO1xuICAgICAgY29uc3QgZWFzdElkeCA9IG5laWdoYm9ySW5kaWNlc1tpICogNCArIDBdO1xuICAgICAgY29uc3Qgd2VzdElkeCA9IG5laWdoYm9ySW5kaWNlc1tpICogNCArIDFdO1xuICAgICAgY29uc3Qgbm9ydGhJZHggPSBuZWlnaGJvckluZGljZXNbaSAqIDQgKyAyXTtcbiAgICAgIGNvbnN0IHNvdXRoSWR4ID0gbmVpZ2hib3JJbmRpY2VzW2kgKiA0ICsgM107XG4gICAgICBsZXQgc3VtTiA9IDA7XG4gICAgICBpZiAoZWFzdElkeCA+PSAwKSBzdW1OICs9IHVbZWFzdElkeF07XG4gICAgICBpZiAod2VzdElkeCA+PSAwKSBzdW1OICs9IHVbd2VzdElkeF07XG4gICAgICBpZiAobm9ydGhJZHggPj0gMCkgc3VtTiArPSB1W25vcnRoSWR4XTtcbiAgICAgIGlmIChzb3V0aElkeCA+PSAwKSBzdW1OICs9IHVbc291dGhJZHhdO1xuICAgICAgY29uc3QgbmV3VmFsdWUgPSAoQyArIHN1bU4pIC8gNDtcbiAgICAgIHVbaWR4XSA9IG9tZWdhICogbmV3VmFsdWUgKyAoMSAtIG9tZWdhKSAqIHVbaWR4XTtcbiAgICB9XG4gIH1cbiAgaWYgKFBPSVNTT05fQ09ORklHX09QVElNSVpFRC5tZWFzdXJlUGVyZm9ybWFuY2UpIHtcbiAgICBjb25zdCBlbGFwc2VkID0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWU7XG4gICAgY29uc29sZS5sb2coYFtPcHRpbWl6ZWQgUG9pc3NvbiBTb2x2ZXIgKFNPUiBcXHUwM0M5PSR7b21lZ2F9KV1gKTtcbiAgICBjb25zb2xlLmxvZyhgICBXb3JraW5nIHNpemU6ICR7d2lkdGh9XFx4RDcke2hlaWdodH1gKTtcbiAgICBjb25zb2xlLmxvZyhgICBJdGVyYXRpb25zOiAke0lURVJBVElPTlN9YCk7XG4gICAgY29uc29sZS5sb2coYCAgVGltZTogJHtlbGFwc2VkLnRvRml4ZWQoMil9bXNgKTtcbiAgICBjb25zb2xlLmxvZyhgICBJbnRlcmlvciBwaXhlbHMgcHJvY2Vzc2VkOiAke3BpeGVsQ291bnR9YCk7XG4gICAgY29uc29sZS5sb2coYCAgU3BlZWQ6ICR7KElURVJBVElPTlMgKiBwaXhlbENvdW50IC8gKGVsYXBzZWQgKiAxZTMpKS50b0ZpeGVkKDIpfSBNcGl4ZWxzL3NlY2ApO1xuICB9XG4gIHJldHVybiB1O1xufVxuY29uc3QgTGlxdWlkTWV0YWxTaGFwZXMgPSB7XG4gIG5vbmU6IDAsXG4gIGNpcmNsZTogMSxcbiAgZGFpc3k6IDIsXG4gIGRpYW1vbmQ6IDMsXG4gIG1ldGFiYWxsczogNFxufTtcbmV4cG9ydCB7XG4gIExpcXVpZE1ldGFsU2hhcGVzLFxuICBQT0lTU09OX0NPTkZJR19PUFRJTUlaRUQsXG4gIGxpcXVpZE1ldGFsRnJhZ21lbnRTaGFkZXIsXG4gIHRvUHJvY2Vzc2VkTGlxdWlkTWV0YWxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saXF1aWQtbWV0YWwuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/shaders/liquid-metal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/shaders/pulsing-border.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/shaders/pulsing-border.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PulsingBorderAspectRatios: () => (/* binding */ PulsingBorderAspectRatios),\n/* harmony export */   pulsingBorderFragmentShader: () => (/* binding */ pulsingBorderFragmentShader),\n/* harmony export */   pulsingBorderMeta: () => (/* binding */ pulsingBorderMeta)\n/* harmony export */ });\n/* harmony import */ var _shader_sizing_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shader-sizing.js */ \"(ssr)/./node_modules/@paper-design/shaders/dist/shader-sizing.js\");\n/* harmony import */ var _shader_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shader-utils.js */ \"(ssr)/./node_modules/@paper-design/shaders/dist/shader-utils.js\");\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\n\nconst pulsingBorderMeta = {\n  maxColorCount: 5,\n  maxSpots: 4\n};\nconst pulsingBorderFragmentShader = `#version 300 es\nprecision lowp float;\n\nuniform float u_time;\n\nuniform vec4 u_colorBack;\nuniform vec4 u_colors[${pulsingBorderMeta.maxColorCount}];\nuniform float u_colorsCount;\nuniform float u_roundness;\nuniform float u_thickness;\nuniform float u_marginLeft;\nuniform float u_marginRight;\nuniform float u_marginTop;\nuniform float u_marginBottom;\nuniform float u_aspectRatio;\nuniform float u_softness;\nuniform float u_intensity;\nuniform float u_bloom;\nuniform float u_spotSize;\nuniform float u_spots;\nuniform float u_pulse;\nuniform float u_smoke;\nuniform float u_smokeSize;\n\nuniform sampler2D u_noiseTexture;\n\n${_shader_sizing_js__WEBPACK_IMPORTED_MODULE_0__.sizingVariablesDeclaration}\n\nout vec4 fragColor;\n\n${_shader_utils_js__WEBPACK_IMPORTED_MODULE_1__.declarePI}\n\nfloat beat(float time) {\n  float first = pow(abs(sin(time * TWO_PI)), 10.);\n  float second = pow(abs(sin((time - .15) * TWO_PI)), 10.);\n\n  return clamp(first + 0.6 * second, 0.0, 1.0);\n}\n\nfloat sst(float edge0, float edge1, float x) {\n  return smoothstep(edge0, edge1, x);\n}\n\nfloat roundedBox(vec2 uv, vec2 halfSize, float distance, float cornerDistance, float thickness, float softness) {\n  float borderDistance = abs(distance);\n  float aa = 2. * fwidth(distance);\n  float border = 1. - sst(min(mix(thickness, -thickness, softness), thickness + aa), max(mix(thickness, -thickness, softness), thickness + aa), borderDistance);\n  float cornerFadeCircles = 0.;\n  cornerFadeCircles = mix(1., cornerFadeCircles, sst(0., 1., length((uv + halfSize) / thickness)));\n  cornerFadeCircles = mix(1., cornerFadeCircles, sst(0., 1., length((uv - vec2(-halfSize.x, halfSize.y)) / thickness)));\n  cornerFadeCircles = mix(1., cornerFadeCircles, sst(0., 1., length((uv - vec2(halfSize.x, -halfSize.y)) / thickness)));\n  cornerFadeCircles = mix(1., cornerFadeCircles, sst(0., 1., length((uv - halfSize) / thickness)));\n  aa = fwidth(cornerDistance);\n  float cornerFade = sst(0., mix(aa, thickness, softness), cornerDistance);\n  cornerFade *= cornerFadeCircles;\n  border += cornerFade;\n  return border;\n}\n\n${_shader_utils_js__WEBPACK_IMPORTED_MODULE_1__.textureRandomizerGB}\n\nfloat randomG(vec2 p) {\n  vec2 uv = floor(p) / 100. + .5;\n  return texture(u_noiseTexture, fract(uv)).g;\n}\nfloat valueNoise(vec2 st) {\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n  float a = randomG(i);\n  float b = randomG(i + vec2(1.0, 0.0));\n  float c = randomG(i + vec2(0.0, 1.0));\n  float d = randomG(i + vec2(1.0, 1.0));\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  float x1 = mix(a, b, u.x);\n  float x2 = mix(c, d, u.x);\n  return mix(x1, x2, u.y);\n}\n\nvoid main() {\n  const float firstFrameOffset = 109.;\n  float t = 1.2 * (u_time + firstFrameOffset);\n\n  vec2 borderUV = v_responsiveUV;\n  float pulse = u_pulse * beat(.18 * u_time);\n\n  float canvasRatio = v_responsiveBoxGivenSize.x / v_responsiveBoxGivenSize.y;\n  vec2 halfSize = vec2(.5);\n  borderUV.x *= max(canvasRatio, 1.);\n  borderUV.y /= min(canvasRatio, 1.);\n  halfSize.x *= max(canvasRatio, 1.);\n  halfSize.y /= min(canvasRatio, 1.);\n\n  float mL = u_marginLeft;\n  float mR = u_marginRight;\n  float mT = u_marginTop;\n  float mB = u_marginBottom;\n  float mX = mL + mR;\n  float mY = mT + mB;\n\n  if (u_aspectRatio > 0.) {\n    float shapeRatio = canvasRatio * (1. - mX) / max(1. - mY, 1e-6);\n    float freeX = shapeRatio > 1. ? (1. - mX) * (1. - 1. / max(abs(shapeRatio), 1e-6)) : 0.;\n    float freeY = shapeRatio < 1. ? (1. - mY) * (1. - shapeRatio) : 0.;\n    mL += freeX * 0.5;\n    mR += freeX * 0.5;\n    mT += freeY * 0.5;\n    mB += freeY * 0.5;\n    mX = mL + mR;\n    mY = mT + mB;\n  }\n\n  float thickness = .5 * u_thickness * min(halfSize.x, halfSize.y);\n\n  halfSize.x *= (1. - mX);\n  halfSize.y *= (1. - mY);\n\n  vec2 centerShift = vec2(\n    (mL - mR) * max(canvasRatio, 1.) * 0.5,\n    (mB - mT) / min(canvasRatio, 1.) * 0.5\n  );\n\n  borderUV -= centerShift;\n  halfSize -= mix(thickness, 0., u_softness);\n\n  float radius = mix(0., min(halfSize.x, halfSize.y), u_roundness);\n  vec2 d = abs(borderUV) - halfSize + radius;\n  float outsideDistance = length(max(d, .0001)) - radius;\n  float insideDistance = min(max(d.x, d.y), .0001);\n  float cornerDistance = abs(min(max(d.x, d.y) - .45 * radius, .0));\n  float distance = outsideDistance + insideDistance;\n\n  float borderThickness = mix(thickness, 3. * thickness, u_softness);\n  float border = roundedBox(borderUV, halfSize, distance, cornerDistance, borderThickness, u_softness);\n  border = pow(border, 1. + u_softness);\n\n  vec2 smokeUV = .3 * u_smokeSize * v_patternUV;\n  float smoke = clamp(3. * valueNoise(2.7 * smokeUV + .5 * t), 0., 1.);\n  smoke -= valueNoise(3.4 * smokeUV - .5 * t);\n  float smokeThickness = thickness + .2;\n  smokeThickness = min(.4, max(smokeThickness, .1));\n  smoke *= roundedBox(borderUV, halfSize, distance, cornerDistance, smokeThickness, 1.);\n  smoke = 30. * smoke * smoke;\n  smoke *= mix(0., .5, pow(u_smoke, 2.));\n  smoke *= mix(1., pulse, u_pulse);\n  smoke = clamp(smoke, 0., 1.);\n  border += smoke;\n\n  border = clamp(border, 0., 1.);\n\n  vec3 blendColor = vec3(0.);\n  float blendAlpha = 0.;\n  vec3 addColor = vec3(0.);\n  float addAlpha = 0.;\n\n  float bloom = 4. * u_bloom;\n  float intensity = 1. + (1. + 4. * u_softness) * u_intensity;\n\n  float angle = atan(borderUV.y, borderUV.x) / TWO_PI;\n\n  for (int colorIdx = 0; colorIdx < ${pulsingBorderMeta.maxColorCount}; colorIdx++) {\n    if (colorIdx >= int(u_colorsCount)) break;\n    float colorIdxF = float(colorIdx);\n\n    vec3 c = u_colors[colorIdx].rgb * u_colors[colorIdx].a;\n    float a = u_colors[colorIdx].a;\n\n    for (int spotIdx = 0; spotIdx < ${pulsingBorderMeta.maxSpots}; spotIdx++) {\n      if (spotIdx >= int(u_spots)) break;\n      float spotIdxF = float(spotIdx);\n\n      vec2 randVal = randomGB(vec2(spotIdxF * 10. + 2., 40. + colorIdxF));\n\n      float time = (.1 + .15 * abs(sin(spotIdxF * (2. + colorIdxF)) * cos(spotIdxF * (2. + 2.5 * colorIdxF)))) * t + randVal.x * 3.;\n      time *= mix(1., -1., step(.5, randVal.y));\n\n      float mask = .5 + .5 * mix(\n        sin(t + spotIdxF * (5. - 1.5 * colorIdxF)),\n        cos(t + spotIdxF * (3. + 1.3 * colorIdxF)),\n        step(mod(colorIdxF, 2.), .5)\n      );\n\n      float p = clamp(2. * u_pulse - randVal.x, 0., 1.);\n      mask = mix(mask, pulse, p);\n\n      float atg1 = fract(angle + time);\n      float spotSize = .05 + .6 * pow(u_spotSize, 2.) + .05 * randVal.x;\n      spotSize = mix(spotSize, .1, p);\n      float sector = sst(.5 - spotSize, .5, atg1) * (1. - sst(.5, .5 + spotSize, atg1));\n\n      sector *= mask;\n      sector *= border;\n      sector *= intensity;\n      sector = clamp(sector, 0., 1.);\n\n      vec3 srcColor = c * sector;\n      float srcAlpha = a * sector;\n\n      blendColor += ((1. - blendAlpha) * srcColor);\n      blendAlpha = blendAlpha + (1. - blendAlpha) * srcAlpha;\n      addColor += srcColor;\n      addAlpha += srcAlpha;\n    }\n  }\n\n  vec3 accumColor = mix(blendColor, addColor, bloom);\n  float accumAlpha = mix(blendAlpha, addAlpha, bloom);\n  accumAlpha = clamp(accumAlpha, 0., 1.);\n\n  vec3 bgColor = u_colorBack.rgb * u_colorBack.a;\n  vec3 color = accumColor + (1. - accumAlpha) * bgColor;\n  float opacity = accumAlpha + (1. - accumAlpha) * u_colorBack.a;\n\n  ${_shader_utils_js__WEBPACK_IMPORTED_MODULE_1__.colorBandingFix}\n\n  fragColor = vec4(color, opacity);\n}`;\nconst PulsingBorderAspectRatios = {\n  auto: 0,\n  square: 1\n};\n\n//# sourceMappingURL=pulsing-border.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVycy9wdWxzaW5nLWJvcmRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVpRTtBQUNvQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx3QkFBd0IsZ0NBQWdDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUUseUVBQTBCOztBQUU1Qjs7QUFFQSxFQUFFLHVEQUFTOztBQUVYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSxpRUFBbUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEseUJBQXlCLGFBQWEsa0NBQWtDO0FBQ3hFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwQkFBMEIsWUFBWSw2QkFBNkI7QUFDbkU7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUksNkRBQWU7O0FBRW5CO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBS0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVycy9wdWxzaW5nLWJvcmRlci5qcz8yYjhhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiAgICAgICAgICAgICAgICAgICAgUGFwZXIgU2hhZGVycyAgICAgICAgICAgICAgICAgICAgKlxuICogICAgICAgaHR0cHM6Ly9naXRodWIuY29tL3BhcGVyLWRlc2lnbi9zaGFkZXJzICAgICAgICpcbiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqL1xuXG5pbXBvcnQgeyBzaXppbmdWYXJpYWJsZXNEZWNsYXJhdGlvbiB9IGZyb20gXCIuLi9zaGFkZXItc2l6aW5nLmpzXCI7XG5pbXBvcnQgeyBkZWNsYXJlUEksIHRleHR1cmVSYW5kb21pemVyR0IsIGNvbG9yQmFuZGluZ0ZpeCB9IGZyb20gXCIuLi9zaGFkZXItdXRpbHMuanNcIjtcbmNvbnN0IHB1bHNpbmdCb3JkZXJNZXRhID0ge1xuICBtYXhDb2xvckNvdW50OiA1LFxuICBtYXhTcG90czogNFxufTtcbmNvbnN0IHB1bHNpbmdCb3JkZXJGcmFnbWVudFNoYWRlciA9IGAjdmVyc2lvbiAzMDAgZXNcbnByZWNpc2lvbiBsb3dwIGZsb2F0O1xuXG51bmlmb3JtIGZsb2F0IHVfdGltZTtcblxudW5pZm9ybSB2ZWM0IHVfY29sb3JCYWNrO1xudW5pZm9ybSB2ZWM0IHVfY29sb3JzWyR7cHVsc2luZ0JvcmRlck1ldGEubWF4Q29sb3JDb3VudH1dO1xudW5pZm9ybSBmbG9hdCB1X2NvbG9yc0NvdW50O1xudW5pZm9ybSBmbG9hdCB1X3JvdW5kbmVzcztcbnVuaWZvcm0gZmxvYXQgdV90aGlja25lc3M7XG51bmlmb3JtIGZsb2F0IHVfbWFyZ2luTGVmdDtcbnVuaWZvcm0gZmxvYXQgdV9tYXJnaW5SaWdodDtcbnVuaWZvcm0gZmxvYXQgdV9tYXJnaW5Ub3A7XG51bmlmb3JtIGZsb2F0IHVfbWFyZ2luQm90dG9tO1xudW5pZm9ybSBmbG9hdCB1X2FzcGVjdFJhdGlvO1xudW5pZm9ybSBmbG9hdCB1X3NvZnRuZXNzO1xudW5pZm9ybSBmbG9hdCB1X2ludGVuc2l0eTtcbnVuaWZvcm0gZmxvYXQgdV9ibG9vbTtcbnVuaWZvcm0gZmxvYXQgdV9zcG90U2l6ZTtcbnVuaWZvcm0gZmxvYXQgdV9zcG90cztcbnVuaWZvcm0gZmxvYXQgdV9wdWxzZTtcbnVuaWZvcm0gZmxvYXQgdV9zbW9rZTtcbnVuaWZvcm0gZmxvYXQgdV9zbW9rZVNpemU7XG5cbnVuaWZvcm0gc2FtcGxlcjJEIHVfbm9pc2VUZXh0dXJlO1xuXG4ke3NpemluZ1ZhcmlhYmxlc0RlY2xhcmF0aW9ufVxuXG5vdXQgdmVjNCBmcmFnQ29sb3I7XG5cbiR7ZGVjbGFyZVBJfVxuXG5mbG9hdCBiZWF0KGZsb2F0IHRpbWUpIHtcbiAgZmxvYXQgZmlyc3QgPSBwb3coYWJzKHNpbih0aW1lICogVFdPX1BJKSksIDEwLik7XG4gIGZsb2F0IHNlY29uZCA9IHBvdyhhYnMoc2luKCh0aW1lIC0gLjE1KSAqIFRXT19QSSkpLCAxMC4pO1xuXG4gIHJldHVybiBjbGFtcChmaXJzdCArIDAuNiAqIHNlY29uZCwgMC4wLCAxLjApO1xufVxuXG5mbG9hdCBzc3QoZmxvYXQgZWRnZTAsIGZsb2F0IGVkZ2UxLCBmbG9hdCB4KSB7XG4gIHJldHVybiBzbW9vdGhzdGVwKGVkZ2UwLCBlZGdlMSwgeCk7XG59XG5cbmZsb2F0IHJvdW5kZWRCb3godmVjMiB1diwgdmVjMiBoYWxmU2l6ZSwgZmxvYXQgZGlzdGFuY2UsIGZsb2F0IGNvcm5lckRpc3RhbmNlLCBmbG9hdCB0aGlja25lc3MsIGZsb2F0IHNvZnRuZXNzKSB7XG4gIGZsb2F0IGJvcmRlckRpc3RhbmNlID0gYWJzKGRpc3RhbmNlKTtcbiAgZmxvYXQgYWEgPSAyLiAqIGZ3aWR0aChkaXN0YW5jZSk7XG4gIGZsb2F0IGJvcmRlciA9IDEuIC0gc3N0KG1pbihtaXgodGhpY2tuZXNzLCAtdGhpY2tuZXNzLCBzb2Z0bmVzcyksIHRoaWNrbmVzcyArIGFhKSwgbWF4KG1peCh0aGlja25lc3MsIC10aGlja25lc3MsIHNvZnRuZXNzKSwgdGhpY2tuZXNzICsgYWEpLCBib3JkZXJEaXN0YW5jZSk7XG4gIGZsb2F0IGNvcm5lckZhZGVDaXJjbGVzID0gMC47XG4gIGNvcm5lckZhZGVDaXJjbGVzID0gbWl4KDEuLCBjb3JuZXJGYWRlQ2lyY2xlcywgc3N0KDAuLCAxLiwgbGVuZ3RoKCh1diArIGhhbGZTaXplKSAvIHRoaWNrbmVzcykpKTtcbiAgY29ybmVyRmFkZUNpcmNsZXMgPSBtaXgoMS4sIGNvcm5lckZhZGVDaXJjbGVzLCBzc3QoMC4sIDEuLCBsZW5ndGgoKHV2IC0gdmVjMigtaGFsZlNpemUueCwgaGFsZlNpemUueSkpIC8gdGhpY2tuZXNzKSkpO1xuICBjb3JuZXJGYWRlQ2lyY2xlcyA9IG1peCgxLiwgY29ybmVyRmFkZUNpcmNsZXMsIHNzdCgwLiwgMS4sIGxlbmd0aCgodXYgLSB2ZWMyKGhhbGZTaXplLngsIC1oYWxmU2l6ZS55KSkgLyB0aGlja25lc3MpKSk7XG4gIGNvcm5lckZhZGVDaXJjbGVzID0gbWl4KDEuLCBjb3JuZXJGYWRlQ2lyY2xlcywgc3N0KDAuLCAxLiwgbGVuZ3RoKCh1diAtIGhhbGZTaXplKSAvIHRoaWNrbmVzcykpKTtcbiAgYWEgPSBmd2lkdGgoY29ybmVyRGlzdGFuY2UpO1xuICBmbG9hdCBjb3JuZXJGYWRlID0gc3N0KDAuLCBtaXgoYWEsIHRoaWNrbmVzcywgc29mdG5lc3MpLCBjb3JuZXJEaXN0YW5jZSk7XG4gIGNvcm5lckZhZGUgKj0gY29ybmVyRmFkZUNpcmNsZXM7XG4gIGJvcmRlciArPSBjb3JuZXJGYWRlO1xuICByZXR1cm4gYm9yZGVyO1xufVxuXG4ke3RleHR1cmVSYW5kb21pemVyR0J9XG5cbmZsb2F0IHJhbmRvbUcodmVjMiBwKSB7XG4gIHZlYzIgdXYgPSBmbG9vcihwKSAvIDEwMC4gKyAuNTtcbiAgcmV0dXJuIHRleHR1cmUodV9ub2lzZVRleHR1cmUsIGZyYWN0KHV2KSkuZztcbn1cbmZsb2F0IHZhbHVlTm9pc2UodmVjMiBzdCkge1xuICB2ZWMyIGkgPSBmbG9vcihzdCk7XG4gIHZlYzIgZiA9IGZyYWN0KHN0KTtcbiAgZmxvYXQgYSA9IHJhbmRvbUcoaSk7XG4gIGZsb2F0IGIgPSByYW5kb21HKGkgKyB2ZWMyKDEuMCwgMC4wKSk7XG4gIGZsb2F0IGMgPSByYW5kb21HKGkgKyB2ZWMyKDAuMCwgMS4wKSk7XG4gIGZsb2F0IGQgPSByYW5kb21HKGkgKyB2ZWMyKDEuMCwgMS4wKSk7XG4gIHZlYzIgdSA9IGYgKiBmICogKDMuMCAtIDIuMCAqIGYpO1xuICBmbG9hdCB4MSA9IG1peChhLCBiLCB1LngpO1xuICBmbG9hdCB4MiA9IG1peChjLCBkLCB1LngpO1xuICByZXR1cm4gbWl4KHgxLCB4MiwgdS55KTtcbn1cblxudm9pZCBtYWluKCkge1xuICBjb25zdCBmbG9hdCBmaXJzdEZyYW1lT2Zmc2V0ID0gMTA5LjtcbiAgZmxvYXQgdCA9IDEuMiAqICh1X3RpbWUgKyBmaXJzdEZyYW1lT2Zmc2V0KTtcblxuICB2ZWMyIGJvcmRlclVWID0gdl9yZXNwb25zaXZlVVY7XG4gIGZsb2F0IHB1bHNlID0gdV9wdWxzZSAqIGJlYXQoLjE4ICogdV90aW1lKTtcblxuICBmbG9hdCBjYW52YXNSYXRpbyA9IHZfcmVzcG9uc2l2ZUJveEdpdmVuU2l6ZS54IC8gdl9yZXNwb25zaXZlQm94R2l2ZW5TaXplLnk7XG4gIHZlYzIgaGFsZlNpemUgPSB2ZWMyKC41KTtcbiAgYm9yZGVyVVYueCAqPSBtYXgoY2FudmFzUmF0aW8sIDEuKTtcbiAgYm9yZGVyVVYueSAvPSBtaW4oY2FudmFzUmF0aW8sIDEuKTtcbiAgaGFsZlNpemUueCAqPSBtYXgoY2FudmFzUmF0aW8sIDEuKTtcbiAgaGFsZlNpemUueSAvPSBtaW4oY2FudmFzUmF0aW8sIDEuKTtcblxuICBmbG9hdCBtTCA9IHVfbWFyZ2luTGVmdDtcbiAgZmxvYXQgbVIgPSB1X21hcmdpblJpZ2h0O1xuICBmbG9hdCBtVCA9IHVfbWFyZ2luVG9wO1xuICBmbG9hdCBtQiA9IHVfbWFyZ2luQm90dG9tO1xuICBmbG9hdCBtWCA9IG1MICsgbVI7XG4gIGZsb2F0IG1ZID0gbVQgKyBtQjtcblxuICBpZiAodV9hc3BlY3RSYXRpbyA+IDAuKSB7XG4gICAgZmxvYXQgc2hhcGVSYXRpbyA9IGNhbnZhc1JhdGlvICogKDEuIC0gbVgpIC8gbWF4KDEuIC0gbVksIDFlLTYpO1xuICAgIGZsb2F0IGZyZWVYID0gc2hhcGVSYXRpbyA+IDEuID8gKDEuIC0gbVgpICogKDEuIC0gMS4gLyBtYXgoYWJzKHNoYXBlUmF0aW8pLCAxZS02KSkgOiAwLjtcbiAgICBmbG9hdCBmcmVlWSA9IHNoYXBlUmF0aW8gPCAxLiA/ICgxLiAtIG1ZKSAqICgxLiAtIHNoYXBlUmF0aW8pIDogMC47XG4gICAgbUwgKz0gZnJlZVggKiAwLjU7XG4gICAgbVIgKz0gZnJlZVggKiAwLjU7XG4gICAgbVQgKz0gZnJlZVkgKiAwLjU7XG4gICAgbUIgKz0gZnJlZVkgKiAwLjU7XG4gICAgbVggPSBtTCArIG1SO1xuICAgIG1ZID0gbVQgKyBtQjtcbiAgfVxuXG4gIGZsb2F0IHRoaWNrbmVzcyA9IC41ICogdV90aGlja25lc3MgKiBtaW4oaGFsZlNpemUueCwgaGFsZlNpemUueSk7XG5cbiAgaGFsZlNpemUueCAqPSAoMS4gLSBtWCk7XG4gIGhhbGZTaXplLnkgKj0gKDEuIC0gbVkpO1xuXG4gIHZlYzIgY2VudGVyU2hpZnQgPSB2ZWMyKFxuICAgIChtTCAtIG1SKSAqIG1heChjYW52YXNSYXRpbywgMS4pICogMC41LFxuICAgIChtQiAtIG1UKSAvIG1pbihjYW52YXNSYXRpbywgMS4pICogMC41XG4gICk7XG5cbiAgYm9yZGVyVVYgLT0gY2VudGVyU2hpZnQ7XG4gIGhhbGZTaXplIC09IG1peCh0aGlja25lc3MsIDAuLCB1X3NvZnRuZXNzKTtcblxuICBmbG9hdCByYWRpdXMgPSBtaXgoMC4sIG1pbihoYWxmU2l6ZS54LCBoYWxmU2l6ZS55KSwgdV9yb3VuZG5lc3MpO1xuICB2ZWMyIGQgPSBhYnMoYm9yZGVyVVYpIC0gaGFsZlNpemUgKyByYWRpdXM7XG4gIGZsb2F0IG91dHNpZGVEaXN0YW5jZSA9IGxlbmd0aChtYXgoZCwgLjAwMDEpKSAtIHJhZGl1cztcbiAgZmxvYXQgaW5zaWRlRGlzdGFuY2UgPSBtaW4obWF4KGQueCwgZC55KSwgLjAwMDEpO1xuICBmbG9hdCBjb3JuZXJEaXN0YW5jZSA9IGFicyhtaW4obWF4KGQueCwgZC55KSAtIC40NSAqIHJhZGl1cywgLjApKTtcbiAgZmxvYXQgZGlzdGFuY2UgPSBvdXRzaWRlRGlzdGFuY2UgKyBpbnNpZGVEaXN0YW5jZTtcblxuICBmbG9hdCBib3JkZXJUaGlja25lc3MgPSBtaXgodGhpY2tuZXNzLCAzLiAqIHRoaWNrbmVzcywgdV9zb2Z0bmVzcyk7XG4gIGZsb2F0IGJvcmRlciA9IHJvdW5kZWRCb3goYm9yZGVyVVYsIGhhbGZTaXplLCBkaXN0YW5jZSwgY29ybmVyRGlzdGFuY2UsIGJvcmRlclRoaWNrbmVzcywgdV9zb2Z0bmVzcyk7XG4gIGJvcmRlciA9IHBvdyhib3JkZXIsIDEuICsgdV9zb2Z0bmVzcyk7XG5cbiAgdmVjMiBzbW9rZVVWID0gLjMgKiB1X3Ntb2tlU2l6ZSAqIHZfcGF0dGVyblVWO1xuICBmbG9hdCBzbW9rZSA9IGNsYW1wKDMuICogdmFsdWVOb2lzZSgyLjcgKiBzbW9rZVVWICsgLjUgKiB0KSwgMC4sIDEuKTtcbiAgc21va2UgLT0gdmFsdWVOb2lzZSgzLjQgKiBzbW9rZVVWIC0gLjUgKiB0KTtcbiAgZmxvYXQgc21va2VUaGlja25lc3MgPSB0aGlja25lc3MgKyAuMjtcbiAgc21va2VUaGlja25lc3MgPSBtaW4oLjQsIG1heChzbW9rZVRoaWNrbmVzcywgLjEpKTtcbiAgc21va2UgKj0gcm91bmRlZEJveChib3JkZXJVViwgaGFsZlNpemUsIGRpc3RhbmNlLCBjb3JuZXJEaXN0YW5jZSwgc21va2VUaGlja25lc3MsIDEuKTtcbiAgc21va2UgPSAzMC4gKiBzbW9rZSAqIHNtb2tlO1xuICBzbW9rZSAqPSBtaXgoMC4sIC41LCBwb3codV9zbW9rZSwgMi4pKTtcbiAgc21va2UgKj0gbWl4KDEuLCBwdWxzZSwgdV9wdWxzZSk7XG4gIHNtb2tlID0gY2xhbXAoc21va2UsIDAuLCAxLik7XG4gIGJvcmRlciArPSBzbW9rZTtcblxuICBib3JkZXIgPSBjbGFtcChib3JkZXIsIDAuLCAxLik7XG5cbiAgdmVjMyBibGVuZENvbG9yID0gdmVjMygwLik7XG4gIGZsb2F0IGJsZW5kQWxwaGEgPSAwLjtcbiAgdmVjMyBhZGRDb2xvciA9IHZlYzMoMC4pO1xuICBmbG9hdCBhZGRBbHBoYSA9IDAuO1xuXG4gIGZsb2F0IGJsb29tID0gNC4gKiB1X2Jsb29tO1xuICBmbG9hdCBpbnRlbnNpdHkgPSAxLiArICgxLiArIDQuICogdV9zb2Z0bmVzcykgKiB1X2ludGVuc2l0eTtcblxuICBmbG9hdCBhbmdsZSA9IGF0YW4oYm9yZGVyVVYueSwgYm9yZGVyVVYueCkgLyBUV09fUEk7XG5cbiAgZm9yIChpbnQgY29sb3JJZHggPSAwOyBjb2xvcklkeCA8ICR7cHVsc2luZ0JvcmRlck1ldGEubWF4Q29sb3JDb3VudH07IGNvbG9ySWR4KyspIHtcbiAgICBpZiAoY29sb3JJZHggPj0gaW50KHVfY29sb3JzQ291bnQpKSBicmVhaztcbiAgICBmbG9hdCBjb2xvcklkeEYgPSBmbG9hdChjb2xvcklkeCk7XG5cbiAgICB2ZWMzIGMgPSB1X2NvbG9yc1tjb2xvcklkeF0ucmdiICogdV9jb2xvcnNbY29sb3JJZHhdLmE7XG4gICAgZmxvYXQgYSA9IHVfY29sb3JzW2NvbG9ySWR4XS5hO1xuXG4gICAgZm9yIChpbnQgc3BvdElkeCA9IDA7IHNwb3RJZHggPCAke3B1bHNpbmdCb3JkZXJNZXRhLm1heFNwb3RzfTsgc3BvdElkeCsrKSB7XG4gICAgICBpZiAoc3BvdElkeCA+PSBpbnQodV9zcG90cykpIGJyZWFrO1xuICAgICAgZmxvYXQgc3BvdElkeEYgPSBmbG9hdChzcG90SWR4KTtcblxuICAgICAgdmVjMiByYW5kVmFsID0gcmFuZG9tR0IodmVjMihzcG90SWR4RiAqIDEwLiArIDIuLCA0MC4gKyBjb2xvcklkeEYpKTtcblxuICAgICAgZmxvYXQgdGltZSA9ICguMSArIC4xNSAqIGFicyhzaW4oc3BvdElkeEYgKiAoMi4gKyBjb2xvcklkeEYpKSAqIGNvcyhzcG90SWR4RiAqICgyLiArIDIuNSAqIGNvbG9ySWR4RikpKSkgKiB0ICsgcmFuZFZhbC54ICogMy47XG4gICAgICB0aW1lICo9IG1peCgxLiwgLTEuLCBzdGVwKC41LCByYW5kVmFsLnkpKTtcblxuICAgICAgZmxvYXQgbWFzayA9IC41ICsgLjUgKiBtaXgoXG4gICAgICAgIHNpbih0ICsgc3BvdElkeEYgKiAoNS4gLSAxLjUgKiBjb2xvcklkeEYpKSxcbiAgICAgICAgY29zKHQgKyBzcG90SWR4RiAqICgzLiArIDEuMyAqIGNvbG9ySWR4RikpLFxuICAgICAgICBzdGVwKG1vZChjb2xvcklkeEYsIDIuKSwgLjUpXG4gICAgICApO1xuXG4gICAgICBmbG9hdCBwID0gY2xhbXAoMi4gKiB1X3B1bHNlIC0gcmFuZFZhbC54LCAwLiwgMS4pO1xuICAgICAgbWFzayA9IG1peChtYXNrLCBwdWxzZSwgcCk7XG5cbiAgICAgIGZsb2F0IGF0ZzEgPSBmcmFjdChhbmdsZSArIHRpbWUpO1xuICAgICAgZmxvYXQgc3BvdFNpemUgPSAuMDUgKyAuNiAqIHBvdyh1X3Nwb3RTaXplLCAyLikgKyAuMDUgKiByYW5kVmFsLng7XG4gICAgICBzcG90U2l6ZSA9IG1peChzcG90U2l6ZSwgLjEsIHApO1xuICAgICAgZmxvYXQgc2VjdG9yID0gc3N0KC41IC0gc3BvdFNpemUsIC41LCBhdGcxKSAqICgxLiAtIHNzdCguNSwgLjUgKyBzcG90U2l6ZSwgYXRnMSkpO1xuXG4gICAgICBzZWN0b3IgKj0gbWFzaztcbiAgICAgIHNlY3RvciAqPSBib3JkZXI7XG4gICAgICBzZWN0b3IgKj0gaW50ZW5zaXR5O1xuICAgICAgc2VjdG9yID0gY2xhbXAoc2VjdG9yLCAwLiwgMS4pO1xuXG4gICAgICB2ZWMzIHNyY0NvbG9yID0gYyAqIHNlY3RvcjtcbiAgICAgIGZsb2F0IHNyY0FscGhhID0gYSAqIHNlY3RvcjtcblxuICAgICAgYmxlbmRDb2xvciArPSAoKDEuIC0gYmxlbmRBbHBoYSkgKiBzcmNDb2xvcik7XG4gICAgICBibGVuZEFscGhhID0gYmxlbmRBbHBoYSArICgxLiAtIGJsZW5kQWxwaGEpICogc3JjQWxwaGE7XG4gICAgICBhZGRDb2xvciArPSBzcmNDb2xvcjtcbiAgICAgIGFkZEFscGhhICs9IHNyY0FscGhhO1xuICAgIH1cbiAgfVxuXG4gIHZlYzMgYWNjdW1Db2xvciA9IG1peChibGVuZENvbG9yLCBhZGRDb2xvciwgYmxvb20pO1xuICBmbG9hdCBhY2N1bUFscGhhID0gbWl4KGJsZW5kQWxwaGEsIGFkZEFscGhhLCBibG9vbSk7XG4gIGFjY3VtQWxwaGEgPSBjbGFtcChhY2N1bUFscGhhLCAwLiwgMS4pO1xuXG4gIHZlYzMgYmdDb2xvciA9IHVfY29sb3JCYWNrLnJnYiAqIHVfY29sb3JCYWNrLmE7XG4gIHZlYzMgY29sb3IgPSBhY2N1bUNvbG9yICsgKDEuIC0gYWNjdW1BbHBoYSkgKiBiZ0NvbG9yO1xuICBmbG9hdCBvcGFjaXR5ID0gYWNjdW1BbHBoYSArICgxLiAtIGFjY3VtQWxwaGEpICogdV9jb2xvckJhY2suYTtcblxuICAke2NvbG9yQmFuZGluZ0ZpeH1cblxuICBmcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLCBvcGFjaXR5KTtcbn1gO1xuY29uc3QgUHVsc2luZ0JvcmRlckFzcGVjdFJhdGlvcyA9IHtcbiAgYXV0bzogMCxcbiAgc3F1YXJlOiAxXG59O1xuZXhwb3J0IHtcbiAgUHVsc2luZ0JvcmRlckFzcGVjdFJhdGlvcyxcbiAgcHVsc2luZ0JvcmRlckZyYWdtZW50U2hhZGVyLFxuICBwdWxzaW5nQm9yZGVyTWV0YVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXB1bHNpbmctYm9yZGVyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/shaders/pulsing-border.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/vertex-shader.js":
/*!******************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/vertex-shader.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   vertexShaderSource: () => (/* binding */ vertexShaderSource)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nconst vertexShaderSource = `#version 300 es\nprecision mediump float;\n\nlayout(location = 0) in vec4 a_position;\n\nuniform vec2 u_resolution;\nuniform float u_pixelRatio;\nuniform float u_imageAspectRatio;\n\nuniform float u_originX;\nuniform float u_originY;\nuniform float u_worldWidth;\nuniform float u_worldHeight;\nuniform float u_fit;\n\nuniform float u_scale;\nuniform float u_rotation;\nuniform float u_offsetX;\nuniform float u_offsetY;\n\nuniform float u_pxSize;\n\nout vec2 v_objectUV;\nout vec2 v_objectBoxSize;\nout vec2 v_objectHelperBox;\n\nout vec2 v_responsiveUV;\nout vec2 v_responsiveBoxSize;\nout vec2 v_responsiveHelperBox;\nout vec2 v_responsiveBoxGivenSize;\n\nout vec2 v_patternUV;\nout vec2 v_patternBoxSize;\nout vec2 v_patternHelperBox;\n\nout vec2 v_imageUV;\n\n// #define ADD_HELPERS\n\nvec3 getBoxSize(float boxRatio, vec2 givenBoxSize) {\n  vec2 box = vec2(0.);\n  // fit = none\n  box.x = boxRatio * min(givenBoxSize.x / boxRatio, givenBoxSize.y);\n  float noFitBoxWidth = box.x;\n  if (u_fit == 1.) { // fit = contain\n    box.x = boxRatio * min(u_resolution.x / boxRatio, u_resolution.y);\n  } else if (u_fit == 2.) { // fit = cover\n    box.x = boxRatio * max(u_resolution.x / boxRatio, u_resolution.y);\n  }\n  box.y = box.x / boxRatio;\n  return vec3(box, noFitBoxWidth);\n}\n\nvoid main() {\n  gl_Position = a_position;\n\n  vec2 uv = gl_Position.xy * .5;\n  vec2 boxOrigin = vec2(.5 - u_originX, u_originY - .5);\n  vec2 givenBoxSize = vec2(u_worldWidth, u_worldHeight);\n  givenBoxSize = max(givenBoxSize, vec2(1.)) * u_pixelRatio;\n  float r = u_rotation * 3.14159265358979323846 / 180.;\n  mat2 graphicRotation = mat2(cos(r), sin(r), -sin(r), cos(r));\n  vec2 graphicOffset = vec2(-u_offsetX, u_offsetY);\n\n\n  // ===================================================\n  // Sizing api for graphic objects with fixed ratio\n  // (currently supports only ratio = 1)\n\n  float fixedRatio = 1.;\n  vec2 fixedRatioBoxGivenSize = vec2(\n  (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n  (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n  );\n\n  v_objectBoxSize = getBoxSize(fixedRatio, fixedRatioBoxGivenSize).xy;\n  vec2 objectWorldScale = u_resolution.xy / v_objectBoxSize;\n\n  #ifdef ADD_HELPERS\n  v_objectHelperBox = uv;\n  v_objectHelperBox *= objectWorldScale;\n  v_objectHelperBox += boxOrigin * (objectWorldScale - 1.);\n  #endif\n\n  v_objectUV = uv;\n  v_objectUV *= objectWorldScale;\n  v_objectUV += boxOrigin * (objectWorldScale - 1.);\n  v_objectUV += graphicOffset;\n  v_objectUV /= u_scale;\n  v_objectUV = graphicRotation * v_objectUV;\n\n\n  // ===================================================\n\n\n  // ===================================================\n  // Sizing api for graphic objects with either givenBoxSize ratio or canvas ratio.\n  // Full-screen mode available with u_worldWidth = u_worldHeight = 0\n\n  v_responsiveBoxGivenSize = vec2(\n  (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n  (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n  );\n  float responsiveRatio = v_responsiveBoxGivenSize.x / v_responsiveBoxGivenSize.y;\n  v_responsiveBoxSize = getBoxSize(responsiveRatio, v_responsiveBoxGivenSize).xy;\n  vec2 responsiveBoxScale = u_resolution.xy / v_responsiveBoxSize;\n\n  #ifdef ADD_HELPERS\n  v_responsiveHelperBox = uv;\n  v_responsiveHelperBox *= responsiveBoxScale;\n  v_responsiveHelperBox += boxOrigin * (responsiveBoxScale - 1.);\n  #endif\n\n  v_responsiveUV = uv;\n  v_responsiveUV *= responsiveBoxScale;\n  v_responsiveUV += boxOrigin * (responsiveBoxScale - 1.);\n  v_responsiveUV += graphicOffset;\n  v_responsiveUV /= u_scale;\n  v_responsiveUV.x *= responsiveRatio;\n  v_responsiveUV = graphicRotation * v_responsiveUV;\n  v_responsiveUV.x /= responsiveRatio;\n\n  // ===================================================\n\n\n  // ===================================================\n  // Sizing api for patterns\n  // (treating graphics as a image u_worldWidth x u_worldHeight size)\n\n  float patternBoxRatio = givenBoxSize.x / givenBoxSize.y;\n  vec2 patternBoxGivenSize = vec2(\n  (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n  (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n  );\n  patternBoxRatio = patternBoxGivenSize.x / patternBoxGivenSize.y;\n\n  vec3 boxSizeData = getBoxSize(patternBoxRatio, patternBoxGivenSize);\n  v_patternBoxSize = boxSizeData.xy;\n  float patternBoxNoFitBoxWidth = boxSizeData.z;\n  vec2 patternBoxScale = u_resolution.xy / v_patternBoxSize;\n\n  #ifdef ADD_HELPERS\n  v_patternHelperBox = uv;\n  v_patternHelperBox *= patternBoxScale;\n  v_patternHelperBox += boxOrigin * (patternBoxScale - 1.);\n  #endif\n\n  v_patternUV = uv;\n  v_patternUV += graphicOffset / patternBoxScale;\n  v_patternUV += boxOrigin;\n  v_patternUV -= boxOrigin / patternBoxScale;\n  v_patternUV *= u_resolution.xy;\n  v_patternUV /= u_pixelRatio;\n  if (u_fit > 0.) {\n    v_patternUV *= (patternBoxNoFitBoxWidth / v_patternBoxSize.x);\n  }\n  v_patternUV /= u_scale;\n  v_patternUV = graphicRotation * v_patternUV;\n  v_patternUV += boxOrigin / patternBoxScale;\n  v_patternUV -= boxOrigin;\n  // x100 is a default multiplier between vertex and fragmant shaders\n  // we use it to avoid UV presision issues\n  v_patternUV *= .01;\n\n  // ===================================================\n\n\n  // ===================================================\n  // Sizing api for images\n\n  vec2 imageBoxSize;\n  if (u_fit == 1.) { // contain\n    imageBoxSize.x = min(u_resolution.x / u_imageAspectRatio, u_resolution.y) * u_imageAspectRatio;\n  } else if (u_fit == 2.) { // cover\n    imageBoxSize.x = max(u_resolution.x / u_imageAspectRatio, u_resolution.y) * u_imageAspectRatio;\n  } else {\n    imageBoxSize.x = min(10.0, 10.0 / u_imageAspectRatio * u_imageAspectRatio);\n  }\n  imageBoxSize.y = imageBoxSize.x / u_imageAspectRatio;\n  vec2 imageBoxScale = u_resolution.xy / imageBoxSize;\n\n  #ifdef ADD_HELPERS\n  vec2 imageHelperBox = uv;\n  imageHelperBox *= imageBoxScale;\n  imageHelperBox += boxOrigin * (imageBoxScale - 1.);\n  #endif\n\n  v_imageUV = uv;\n  v_imageUV *= imageBoxScale;\n  v_imageUV += boxOrigin * (imageBoxScale - 1.);\n  v_imageUV += graphicOffset;\n  v_imageUV /= u_scale;\n  v_imageUV.x *= u_imageAspectRatio;\n  v_imageUV = graphicRotation * v_imageUV;\n  v_imageUV.x /= u_imageAspectRatio;\n\n  v_imageUV += .5;\n  v_imageUV.y = 1. - v_imageUV.y;\n\n  // ===================================================\n\n}`;\n\n//# sourceMappingURL=vertex-shader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3QvdmVydGV4LXNoYWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxJQUFJLHdCQUF3QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxJQUFJLHdCQUF3QjtBQUM1QjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxDQUFDO0FBR0M7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3QvdmVydGV4LXNoYWRlci5qcz8yOGEwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiAgICAgICAgICAgICAgICAgICAgUGFwZXIgU2hhZGVycyAgICAgICAgICAgICAgICAgICAgKlxuICogICAgICAgaHR0cHM6Ly9naXRodWIuY29tL3BhcGVyLWRlc2lnbi9zaGFkZXJzICAgICAgICpcbiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqL1xuXG5jb25zdCB2ZXJ0ZXhTaGFkZXJTb3VyY2UgPSBgI3ZlcnNpb24gMzAwIGVzXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcblxubGF5b3V0KGxvY2F0aW9uID0gMCkgaW4gdmVjNCBhX3Bvc2l0aW9uO1xuXG51bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uO1xudW5pZm9ybSBmbG9hdCB1X3BpeGVsUmF0aW87XG51bmlmb3JtIGZsb2F0IHVfaW1hZ2VBc3BlY3RSYXRpbztcblxudW5pZm9ybSBmbG9hdCB1X29yaWdpblg7XG51bmlmb3JtIGZsb2F0IHVfb3JpZ2luWTtcbnVuaWZvcm0gZmxvYXQgdV93b3JsZFdpZHRoO1xudW5pZm9ybSBmbG9hdCB1X3dvcmxkSGVpZ2h0O1xudW5pZm9ybSBmbG9hdCB1X2ZpdDtcblxudW5pZm9ybSBmbG9hdCB1X3NjYWxlO1xudW5pZm9ybSBmbG9hdCB1X3JvdGF0aW9uO1xudW5pZm9ybSBmbG9hdCB1X29mZnNldFg7XG51bmlmb3JtIGZsb2F0IHVfb2Zmc2V0WTtcblxudW5pZm9ybSBmbG9hdCB1X3B4U2l6ZTtcblxub3V0IHZlYzIgdl9vYmplY3RVVjtcbm91dCB2ZWMyIHZfb2JqZWN0Qm94U2l6ZTtcbm91dCB2ZWMyIHZfb2JqZWN0SGVscGVyQm94O1xuXG5vdXQgdmVjMiB2X3Jlc3BvbnNpdmVVVjtcbm91dCB2ZWMyIHZfcmVzcG9uc2l2ZUJveFNpemU7XG5vdXQgdmVjMiB2X3Jlc3BvbnNpdmVIZWxwZXJCb3g7XG5vdXQgdmVjMiB2X3Jlc3BvbnNpdmVCb3hHaXZlblNpemU7XG5cbm91dCB2ZWMyIHZfcGF0dGVyblVWO1xub3V0IHZlYzIgdl9wYXR0ZXJuQm94U2l6ZTtcbm91dCB2ZWMyIHZfcGF0dGVybkhlbHBlckJveDtcblxub3V0IHZlYzIgdl9pbWFnZVVWO1xuXG4vLyAjZGVmaW5lIEFERF9IRUxQRVJTXG5cbnZlYzMgZ2V0Qm94U2l6ZShmbG9hdCBib3hSYXRpbywgdmVjMiBnaXZlbkJveFNpemUpIHtcbiAgdmVjMiBib3ggPSB2ZWMyKDAuKTtcbiAgLy8gZml0ID0gbm9uZVxuICBib3gueCA9IGJveFJhdGlvICogbWluKGdpdmVuQm94U2l6ZS54IC8gYm94UmF0aW8sIGdpdmVuQm94U2l6ZS55KTtcbiAgZmxvYXQgbm9GaXRCb3hXaWR0aCA9IGJveC54O1xuICBpZiAodV9maXQgPT0gMS4pIHsgLy8gZml0ID0gY29udGFpblxuICAgIGJveC54ID0gYm94UmF0aW8gKiBtaW4odV9yZXNvbHV0aW9uLnggLyBib3hSYXRpbywgdV9yZXNvbHV0aW9uLnkpO1xuICB9IGVsc2UgaWYgKHVfZml0ID09IDIuKSB7IC8vIGZpdCA9IGNvdmVyXG4gICAgYm94LnggPSBib3hSYXRpbyAqIG1heCh1X3Jlc29sdXRpb24ueCAvIGJveFJhdGlvLCB1X3Jlc29sdXRpb24ueSk7XG4gIH1cbiAgYm94LnkgPSBib3gueCAvIGJveFJhdGlvO1xuICByZXR1cm4gdmVjMyhib3gsIG5vRml0Qm94V2lkdGgpO1xufVxuXG52b2lkIG1haW4oKSB7XG4gIGdsX1Bvc2l0aW9uID0gYV9wb3NpdGlvbjtcblxuICB2ZWMyIHV2ID0gZ2xfUG9zaXRpb24ueHkgKiAuNTtcbiAgdmVjMiBib3hPcmlnaW4gPSB2ZWMyKC41IC0gdV9vcmlnaW5YLCB1X29yaWdpblkgLSAuNSk7XG4gIHZlYzIgZ2l2ZW5Cb3hTaXplID0gdmVjMih1X3dvcmxkV2lkdGgsIHVfd29ybGRIZWlnaHQpO1xuICBnaXZlbkJveFNpemUgPSBtYXgoZ2l2ZW5Cb3hTaXplLCB2ZWMyKDEuKSkgKiB1X3BpeGVsUmF0aW87XG4gIGZsb2F0IHIgPSB1X3JvdGF0aW9uICogMy4xNDE1OTI2NTM1ODk3OTMyMzg0NiAvIDE4MC47XG4gIG1hdDIgZ3JhcGhpY1JvdGF0aW9uID0gbWF0Mihjb3MociksIHNpbihyKSwgLXNpbihyKSwgY29zKHIpKTtcbiAgdmVjMiBncmFwaGljT2Zmc2V0ID0gdmVjMigtdV9vZmZzZXRYLCB1X29mZnNldFkpO1xuXG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFNpemluZyBhcGkgZm9yIGdyYXBoaWMgb2JqZWN0cyB3aXRoIGZpeGVkIHJhdGlvXG4gIC8vIChjdXJyZW50bHkgc3VwcG9ydHMgb25seSByYXRpbyA9IDEpXG5cbiAgZmxvYXQgZml4ZWRSYXRpbyA9IDEuO1xuICB2ZWMyIGZpeGVkUmF0aW9Cb3hHaXZlblNpemUgPSB2ZWMyKFxuICAodV93b3JsZFdpZHRoID09IDAuKSA/IHVfcmVzb2x1dGlvbi54IDogZ2l2ZW5Cb3hTaXplLngsXG4gICh1X3dvcmxkSGVpZ2h0ID09IDAuKSA/IHVfcmVzb2x1dGlvbi55IDogZ2l2ZW5Cb3hTaXplLnlcbiAgKTtcblxuICB2X29iamVjdEJveFNpemUgPSBnZXRCb3hTaXplKGZpeGVkUmF0aW8sIGZpeGVkUmF0aW9Cb3hHaXZlblNpemUpLnh5O1xuICB2ZWMyIG9iamVjdFdvcmxkU2NhbGUgPSB1X3Jlc29sdXRpb24ueHkgLyB2X29iamVjdEJveFNpemU7XG5cbiAgI2lmZGVmIEFERF9IRUxQRVJTXG4gIHZfb2JqZWN0SGVscGVyQm94ID0gdXY7XG4gIHZfb2JqZWN0SGVscGVyQm94ICo9IG9iamVjdFdvcmxkU2NhbGU7XG4gIHZfb2JqZWN0SGVscGVyQm94ICs9IGJveE9yaWdpbiAqIChvYmplY3RXb3JsZFNjYWxlIC0gMS4pO1xuICAjZW5kaWZcblxuICB2X29iamVjdFVWID0gdXY7XG4gIHZfb2JqZWN0VVYgKj0gb2JqZWN0V29ybGRTY2FsZTtcbiAgdl9vYmplY3RVViArPSBib3hPcmlnaW4gKiAob2JqZWN0V29ybGRTY2FsZSAtIDEuKTtcbiAgdl9vYmplY3RVViArPSBncmFwaGljT2Zmc2V0O1xuICB2X29iamVjdFVWIC89IHVfc2NhbGU7XG4gIHZfb2JqZWN0VVYgPSBncmFwaGljUm90YXRpb24gKiB2X29iamVjdFVWO1xuXG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gU2l6aW5nIGFwaSBmb3IgZ3JhcGhpYyBvYmplY3RzIHdpdGggZWl0aGVyIGdpdmVuQm94U2l6ZSByYXRpbyBvciBjYW52YXMgcmF0aW8uXG4gIC8vIEZ1bGwtc2NyZWVuIG1vZGUgYXZhaWxhYmxlIHdpdGggdV93b3JsZFdpZHRoID0gdV93b3JsZEhlaWdodCA9IDBcblxuICB2X3Jlc3BvbnNpdmVCb3hHaXZlblNpemUgPSB2ZWMyKFxuICAodV93b3JsZFdpZHRoID09IDAuKSA/IHVfcmVzb2x1dGlvbi54IDogZ2l2ZW5Cb3hTaXplLngsXG4gICh1X3dvcmxkSGVpZ2h0ID09IDAuKSA/IHVfcmVzb2x1dGlvbi55IDogZ2l2ZW5Cb3hTaXplLnlcbiAgKTtcbiAgZmxvYXQgcmVzcG9uc2l2ZVJhdGlvID0gdl9yZXNwb25zaXZlQm94R2l2ZW5TaXplLnggLyB2X3Jlc3BvbnNpdmVCb3hHaXZlblNpemUueTtcbiAgdl9yZXNwb25zaXZlQm94U2l6ZSA9IGdldEJveFNpemUocmVzcG9uc2l2ZVJhdGlvLCB2X3Jlc3BvbnNpdmVCb3hHaXZlblNpemUpLnh5O1xuICB2ZWMyIHJlc3BvbnNpdmVCb3hTY2FsZSA9IHVfcmVzb2x1dGlvbi54eSAvIHZfcmVzcG9uc2l2ZUJveFNpemU7XG5cbiAgI2lmZGVmIEFERF9IRUxQRVJTXG4gIHZfcmVzcG9uc2l2ZUhlbHBlckJveCA9IHV2O1xuICB2X3Jlc3BvbnNpdmVIZWxwZXJCb3ggKj0gcmVzcG9uc2l2ZUJveFNjYWxlO1xuICB2X3Jlc3BvbnNpdmVIZWxwZXJCb3ggKz0gYm94T3JpZ2luICogKHJlc3BvbnNpdmVCb3hTY2FsZSAtIDEuKTtcbiAgI2VuZGlmXG5cbiAgdl9yZXNwb25zaXZlVVYgPSB1djtcbiAgdl9yZXNwb25zaXZlVVYgKj0gcmVzcG9uc2l2ZUJveFNjYWxlO1xuICB2X3Jlc3BvbnNpdmVVViArPSBib3hPcmlnaW4gKiAocmVzcG9uc2l2ZUJveFNjYWxlIC0gMS4pO1xuICB2X3Jlc3BvbnNpdmVVViArPSBncmFwaGljT2Zmc2V0O1xuICB2X3Jlc3BvbnNpdmVVViAvPSB1X3NjYWxlO1xuICB2X3Jlc3BvbnNpdmVVVi54ICo9IHJlc3BvbnNpdmVSYXRpbztcbiAgdl9yZXNwb25zaXZlVVYgPSBncmFwaGljUm90YXRpb24gKiB2X3Jlc3BvbnNpdmVVVjtcbiAgdl9yZXNwb25zaXZlVVYueCAvPSByZXNwb25zaXZlUmF0aW87XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gU2l6aW5nIGFwaSBmb3IgcGF0dGVybnNcbiAgLy8gKHRyZWF0aW5nIGdyYXBoaWNzIGFzIGEgaW1hZ2UgdV93b3JsZFdpZHRoIHggdV93b3JsZEhlaWdodCBzaXplKVxuXG4gIGZsb2F0IHBhdHRlcm5Cb3hSYXRpbyA9IGdpdmVuQm94U2l6ZS54IC8gZ2l2ZW5Cb3hTaXplLnk7XG4gIHZlYzIgcGF0dGVybkJveEdpdmVuU2l6ZSA9IHZlYzIoXG4gICh1X3dvcmxkV2lkdGggPT0gMC4pID8gdV9yZXNvbHV0aW9uLnggOiBnaXZlbkJveFNpemUueCxcbiAgKHVfd29ybGRIZWlnaHQgPT0gMC4pID8gdV9yZXNvbHV0aW9uLnkgOiBnaXZlbkJveFNpemUueVxuICApO1xuICBwYXR0ZXJuQm94UmF0aW8gPSBwYXR0ZXJuQm94R2l2ZW5TaXplLnggLyBwYXR0ZXJuQm94R2l2ZW5TaXplLnk7XG5cbiAgdmVjMyBib3hTaXplRGF0YSA9IGdldEJveFNpemUocGF0dGVybkJveFJhdGlvLCBwYXR0ZXJuQm94R2l2ZW5TaXplKTtcbiAgdl9wYXR0ZXJuQm94U2l6ZSA9IGJveFNpemVEYXRhLnh5O1xuICBmbG9hdCBwYXR0ZXJuQm94Tm9GaXRCb3hXaWR0aCA9IGJveFNpemVEYXRhLno7XG4gIHZlYzIgcGF0dGVybkJveFNjYWxlID0gdV9yZXNvbHV0aW9uLnh5IC8gdl9wYXR0ZXJuQm94U2l6ZTtcblxuICAjaWZkZWYgQUREX0hFTFBFUlNcbiAgdl9wYXR0ZXJuSGVscGVyQm94ID0gdXY7XG4gIHZfcGF0dGVybkhlbHBlckJveCAqPSBwYXR0ZXJuQm94U2NhbGU7XG4gIHZfcGF0dGVybkhlbHBlckJveCArPSBib3hPcmlnaW4gKiAocGF0dGVybkJveFNjYWxlIC0gMS4pO1xuICAjZW5kaWZcblxuICB2X3BhdHRlcm5VViA9IHV2O1xuICB2X3BhdHRlcm5VViArPSBncmFwaGljT2Zmc2V0IC8gcGF0dGVybkJveFNjYWxlO1xuICB2X3BhdHRlcm5VViArPSBib3hPcmlnaW47XG4gIHZfcGF0dGVyblVWIC09IGJveE9yaWdpbiAvIHBhdHRlcm5Cb3hTY2FsZTtcbiAgdl9wYXR0ZXJuVVYgKj0gdV9yZXNvbHV0aW9uLnh5O1xuICB2X3BhdHRlcm5VViAvPSB1X3BpeGVsUmF0aW87XG4gIGlmICh1X2ZpdCA+IDAuKSB7XG4gICAgdl9wYXR0ZXJuVVYgKj0gKHBhdHRlcm5Cb3hOb0ZpdEJveFdpZHRoIC8gdl9wYXR0ZXJuQm94U2l6ZS54KTtcbiAgfVxuICB2X3BhdHRlcm5VViAvPSB1X3NjYWxlO1xuICB2X3BhdHRlcm5VViA9IGdyYXBoaWNSb3RhdGlvbiAqIHZfcGF0dGVyblVWO1xuICB2X3BhdHRlcm5VViArPSBib3hPcmlnaW4gLyBwYXR0ZXJuQm94U2NhbGU7XG4gIHZfcGF0dGVyblVWIC09IGJveE9yaWdpbjtcbiAgLy8geDEwMCBpcyBhIGRlZmF1bHQgbXVsdGlwbGllciBiZXR3ZWVuIHZlcnRleCBhbmQgZnJhZ21hbnQgc2hhZGVyc1xuICAvLyB3ZSB1c2UgaXQgdG8gYXZvaWQgVVYgcHJlc2lzaW9uIGlzc3Vlc1xuICB2X3BhdHRlcm5VViAqPSAuMDE7XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gU2l6aW5nIGFwaSBmb3IgaW1hZ2VzXG5cbiAgdmVjMiBpbWFnZUJveFNpemU7XG4gIGlmICh1X2ZpdCA9PSAxLikgeyAvLyBjb250YWluXG4gICAgaW1hZ2VCb3hTaXplLnggPSBtaW4odV9yZXNvbHV0aW9uLnggLyB1X2ltYWdlQXNwZWN0UmF0aW8sIHVfcmVzb2x1dGlvbi55KSAqIHVfaW1hZ2VBc3BlY3RSYXRpbztcbiAgfSBlbHNlIGlmICh1X2ZpdCA9PSAyLikgeyAvLyBjb3ZlclxuICAgIGltYWdlQm94U2l6ZS54ID0gbWF4KHVfcmVzb2x1dGlvbi54IC8gdV9pbWFnZUFzcGVjdFJhdGlvLCB1X3Jlc29sdXRpb24ueSkgKiB1X2ltYWdlQXNwZWN0UmF0aW87XG4gIH0gZWxzZSB7XG4gICAgaW1hZ2VCb3hTaXplLnggPSBtaW4oMTAuMCwgMTAuMCAvIHVfaW1hZ2VBc3BlY3RSYXRpbyAqIHVfaW1hZ2VBc3BlY3RSYXRpbyk7XG4gIH1cbiAgaW1hZ2VCb3hTaXplLnkgPSBpbWFnZUJveFNpemUueCAvIHVfaW1hZ2VBc3BlY3RSYXRpbztcbiAgdmVjMiBpbWFnZUJveFNjYWxlID0gdV9yZXNvbHV0aW9uLnh5IC8gaW1hZ2VCb3hTaXplO1xuXG4gICNpZmRlZiBBRERfSEVMUEVSU1xuICB2ZWMyIGltYWdlSGVscGVyQm94ID0gdXY7XG4gIGltYWdlSGVscGVyQm94ICo9IGltYWdlQm94U2NhbGU7XG4gIGltYWdlSGVscGVyQm94ICs9IGJveE9yaWdpbiAqIChpbWFnZUJveFNjYWxlIC0gMS4pO1xuICAjZW5kaWZcblxuICB2X2ltYWdlVVYgPSB1djtcbiAgdl9pbWFnZVVWICo9IGltYWdlQm94U2NhbGU7XG4gIHZfaW1hZ2VVViArPSBib3hPcmlnaW4gKiAoaW1hZ2VCb3hTY2FsZSAtIDEuKTtcbiAgdl9pbWFnZVVWICs9IGdyYXBoaWNPZmZzZXQ7XG4gIHZfaW1hZ2VVViAvPSB1X3NjYWxlO1xuICB2X2ltYWdlVVYueCAqPSB1X2ltYWdlQXNwZWN0UmF0aW87XG4gIHZfaW1hZ2VVViA9IGdyYXBoaWNSb3RhdGlvbiAqIHZfaW1hZ2VVVjtcbiAgdl9pbWFnZVVWLnggLz0gdV9pbWFnZUFzcGVjdFJhdGlvO1xuXG4gIHZfaW1hZ2VVViArPSAuNTtcbiAgdl9pbWFnZVVWLnkgPSAxLiAtIHZfaW1hZ2VVVi55O1xuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG59YDtcbmV4cG9ydCB7XG4gIHZlcnRleFNoYWRlclNvdXJjZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnRleC1zaGFkZXIuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/vertex-shader.js\n");

/***/ })

};
;
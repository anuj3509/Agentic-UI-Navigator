"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@paper-design";
exports.ids = ["vendor-chunks/@paper-design"];
exports.modules = {

/***/ "(ssr)/./node_modules/@paper-design/shaders-react/dist/shader-mount.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@paper-design/shaders-react/dist/shader-mount.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShaderMount: () => (/* binding */ ShaderMount)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @paper-design/shaders */ \"(ssr)/./node_modules/@paper-design/shaders/dist/get-empty-pixel.js\");\n/* harmony import */ var _paper_design_shaders__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @paper-design/shaders */ \"(ssr)/./node_modules/@paper-design/shaders/dist/shader-mount.js\");\n/* harmony import */ var _use_merge_refs_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./use-merge-refs.js */ \"(ssr)/./node_modules/@paper-design/shaders-react/dist/use-merge-refs.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */ /* __next_internal_client_entry_do_not_use__ ShaderMount auto */ \n\n\n\nasync function processUniforms(uniformsProp) {\n    const processedUniforms = {};\n    const imageLoadPromises = [];\n    const isValidUrl = (url)=>{\n        try {\n            if (url.startsWith(\"/\")) return true;\n            new URL(url);\n            return true;\n        } catch  {\n            return false;\n        }\n    };\n    const isExternalUrl = (url)=>{\n        try {\n            if (url.startsWith(\"/\")) return false;\n            const urlObject = new URL(url, window.location.origin);\n            return urlObject.origin !== window.location.origin;\n        } catch  {\n            return false;\n        }\n    };\n    Object.entries(uniformsProp).forEach(([key, value])=>{\n        if (typeof value === \"string\") {\n            if (!value) {\n                processedUniforms[key] = (0,_paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.getEmptyPixel)();\n                return;\n            }\n            if (!isValidUrl(value)) {\n                console.warn(`Uniform \"${key}\" has invalid URL \"${value}\". Skipping image loading.`);\n                return;\n            }\n            const imagePromise = new Promise((resolve, reject)=>{\n                const img = new Image();\n                if (isExternalUrl(value)) {\n                    img.crossOrigin = \"anonymous\";\n                }\n                img.onload = ()=>{\n                    processedUniforms[key] = img;\n                    resolve();\n                };\n                img.onerror = ()=>{\n                    console.error(`Could not set uniforms. Failed to load image at ${value}`);\n                    reject();\n                };\n                img.src = value;\n            });\n            imageLoadPromises.push(imagePromise);\n        } else {\n            processedUniforms[key] = value;\n        }\n    });\n    await Promise.all(imageLoadPromises);\n    return processedUniforms;\n}\nconst ShaderMount = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function ShaderMountImpl({ fragmentShader, uniforms: uniformsProp, webGlContextAttributes, speed = 0, frame = 0, width, height, minPixelRatio, maxPixelCount, mipmaps, style, ...divProps }, forwardedRef) {\n    const [isInitialized, setIsInitialized] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const divRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const shaderMountRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const webGlContextAttributesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(webGlContextAttributes);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const initShader = async ()=>{\n            const uniforms = await processUniforms(uniformsProp);\n            if (divRef.current && !shaderMountRef.current) {\n                shaderMountRef.current = new _paper_design_shaders__WEBPACK_IMPORTED_MODULE_3__.ShaderMount(divRef.current, fragmentShader, uniforms, webGlContextAttributesRef.current, speed, frame, minPixelRatio, maxPixelCount, mipmaps);\n                setIsInitialized(true);\n            }\n        };\n        initShader();\n        return ()=>{\n            shaderMountRef.current?.dispose();\n            shaderMountRef.current = null;\n        };\n    }, [\n        fragmentShader\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let isStale = false;\n        const updateUniforms = async ()=>{\n            const uniforms = await processUniforms(uniformsProp);\n            if (!isStale) {\n                shaderMountRef.current?.setUniforms(uniforms);\n            }\n        };\n        updateUniforms();\n        return ()=>{\n            isStale = true;\n        };\n    }, [\n        uniformsProp,\n        isInitialized\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        shaderMountRef.current?.setSpeed(speed);\n    }, [\n        speed,\n        isInitialized\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        shaderMountRef.current?.setMaxPixelCount(maxPixelCount);\n    }, [\n        maxPixelCount,\n        isInitialized\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        shaderMountRef.current?.setMinPixelRatio(minPixelRatio);\n    }, [\n        minPixelRatio,\n        isInitialized\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        shaderMountRef.current?.setFrame(frame);\n    }, [\n        frame,\n        isInitialized\n    ]);\n    const mergedRef = (0,_use_merge_refs_js__WEBPACK_IMPORTED_MODULE_4__.useMergeRefs)([\n        divRef,\n        forwardedRef\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n        ref: mergedRef,\n        style: width !== void 0 || height !== void 0 ? {\n            width: typeof width === \"string\" && isNaN(+width) === false ? +width : width,\n            height: typeof height === \"string\" && isNaN(+height) === false ? +height : height,\n            ...style\n        } : style,\n        ...divProps\n    });\n});\nShaderMount.displayName = \"ShaderMount\";\n //# sourceMappingURL=shader-mount.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzLXJlYWN0L2Rpc3Qvc2hhZGVyLW1vdW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OzsySEFFd0Q7QUFPakQ7QUFDc0I7QUE2TXZCO0FBcktOLGVBQWVTLGdCQUFnQkMsWUFBQTtJQUM3QixNQUFNQyxvQkFBb0IsQ0FBQztJQUMzQixNQUFNQyxvQkFBcUMsRUFBQztJQUU1QyxNQUFNQyxhQUFhLENBQUNDO1FBQ2xCLElBQUk7WUFFRixJQUFJQSxJQUFJQyxVQUFBLENBQVcsTUFBTSxPQUFPO1lBRWhDLElBQUlDLElBQUlGO1lBQ1IsT0FBTztRQUNULFNBQVE7WUFDTixPQUFPO1FBQ1Q7SUFDRjtJQUVBLE1BQU1HLGdCQUFnQixDQUFDSDtRQUNyQixJQUFJO1lBQ0YsSUFBSUEsSUFBSUMsVUFBQSxDQUFXLE1BQU0sT0FBTztZQUNoQyxNQUFNRyxZQUFZLElBQUlGLElBQUlGLEtBQUtLLE9BQU9DLFFBQUEsQ0FBU0MsTUFBTTtZQUNyRCxPQUFPSCxVQUFVRyxNQUFBLEtBQVdGLE9BQU9DLFFBQUEsQ0FBU0MsTUFBQTtRQUM5QyxTQUFRO1lBQ04sT0FBTztRQUNUO0lBQ0Y7SUFFQUMsT0FBT0MsT0FBQSxDQUFRYixjQUFjYyxPQUFBLENBQVEsQ0FBQyxDQUFDQyxLQUFLQyxNQUFLO1FBQy9DLElBQUksT0FBT0EsVUFBVSxVQUFVO1lBRTdCLElBQUksQ0FBQ0EsT0FBTztnQkFDVmYsaUJBQUEsQ0FBa0JjLElBQUcsR0FBSW5CLG9FQUFhQTtnQkFDdEM7WUFDRjtZQUdBLElBQUksQ0FBQ08sV0FBV2EsUUFBUTtnQkFDdEJDLFFBQVFDLElBQUEsQ0FBSyxZQUFZSCxJQUFHLHFCQUFzQkMsTUFBSywyQkFBNEI7Z0JBQ25GO1lBQ0Y7WUFFQSxNQUFNRyxlQUFlLElBQUlDLFFBQWMsQ0FBQ0MsU0FBU0M7Z0JBQy9DLE1BQU1DLE1BQU0sSUFBSUM7Z0JBQ2hCLElBQUlqQixjQUFjUyxRQUFRO29CQUN4Qk8sSUFBSUUsV0FBQSxHQUFjO2dCQUNwQjtnQkFDQUYsSUFBSUcsTUFBQSxHQUFTO29CQUNYekIsaUJBQUEsQ0FBa0JjLElBQUcsR0FBSVE7b0JBQ3pCRjtnQkFDRjtnQkFDQUUsSUFBSUksT0FBQSxHQUFVO29CQUNaVixRQUFRVyxLQUFBLENBQU0sbURBQW1EWixNQUFLLENBQUU7b0JBQ3hFTTtnQkFDRjtnQkFDQUMsSUFBSU0sR0FBQSxHQUFNYjtZQUNaO1lBQ0FkLGtCQUFrQjRCLElBQUEsQ0FBS1g7UUFDekIsT0FBTztZQUNMbEIsaUJBQUEsQ0FBa0JjLElBQUcsR0FBSUM7UUFDM0I7SUFDRjtJQUVBLE1BQU1JLFFBQVFXLEdBQUEsQ0FBSTdCO0lBQ2xCLE9BQU9EO0FBQ1Q7QUFNTyxNQUFNUCw0QkFBMENGLGlEQUFVQSxDQUMvRCxTQUFTd0MsZ0JBQ1AsRUFDRUMsY0FBQSxFQUNBQyxVQUFVbEMsWUFBQSxFQUNWbUMsc0JBQUEsRUFDQUMsUUFBUSxHQUNSQyxRQUFRLEdBQ1JDLEtBQUEsRUFDQUMsTUFBQSxFQUNBQyxhQUFBLEVBQ0FDLGFBQUEsRUFDQUMsT0FBQSxFQUNBQyxLQUFBLEVBQ0EsR0FBR0MsVUFDTCxFQUNBQyxZQUFBO0lBRUEsTUFBTSxDQUFDQyxlQUFlQyxpQkFBZ0IsR0FBSXRELCtDQUFRQSxDQUFDO0lBQ25ELE1BQU11RCxTQUFTekQsNkNBQU1BLENBQXFCO0lBQzFDLE1BQU0wRCxpQkFBNkQxRCw2Q0FBTUEsQ0FBcUI7SUFDOUYsTUFBTTJELDRCQUE0QjNELDZDQUFNQSxDQUFDNEM7SUFHekM3QyxnREFBU0EsQ0FBQztRQUNSLE1BQU02RCxhQUFhO1lBQ2pCLE1BQU1qQixXQUFXLE1BQU1uQyxnQkFBZ0JDO1lBRXZDLElBQUlnRCxPQUFPSSxPQUFBLElBQVcsQ0FBQ0gsZUFBZUcsT0FBQSxFQUFTO2dCQUM3Q0gsZUFBZUcsT0FBQSxHQUFVLElBQUl6RCw4REFBa0JBLENBQzdDcUQsT0FBT0ksT0FBQSxFQUNQbkIsZ0JBQ0FDLFVBQ0FnQiwwQkFBMEJFLE9BQUEsRUFDMUJoQixPQUNBQyxPQUNBRyxlQUNBQyxlQUNBQztnQkFHRkssaUJBQWlCO1lBQ25CO1FBQ0Y7UUFFQUk7UUFFQSxPQUFPO1lBQ0xGLGVBQWVHLE9BQUEsRUFBU0M7WUFDeEJKLGVBQWVHLE9BQUEsR0FBVTtRQUMzQjtJQUNGLEdBQUc7UUFBQ25CO0tBQWU7SUFHbkIzQyxnREFBU0EsQ0FBQztRQUNSLElBQUlnRSxVQUFVO1FBRWQsTUFBTUMsaUJBQWlCO1lBQ3JCLE1BQU1yQixXQUFXLE1BQU1uQyxnQkFBZ0JDO1lBRXZDLElBQUksQ0FBQ3NELFNBQVM7Z0JBR1pMLGVBQWVHLE9BQUEsRUFBU0ksWUFBWXRCO1lBQ3RDO1FBQ0Y7UUFFQXFCO1FBRUEsT0FBTztZQUNMRCxVQUFVO1FBQ1o7SUFDRixHQUFHO1FBQUN0RDtRQUFjOEM7S0FBYztJQUdoQ3hELGdEQUFTQSxDQUFDO1FBQ1IyRCxlQUFlRyxPQUFBLEVBQVNLLFNBQVNyQjtJQUNuQyxHQUFHO1FBQUNBO1FBQU9VO0tBQWM7SUFHekJ4RCxnREFBU0EsQ0FBQztRQUNSMkQsZUFBZUcsT0FBQSxFQUFTTSxpQkFBaUJqQjtJQUMzQyxHQUFHO1FBQUNBO1FBQWVLO0tBQWM7SUFHakN4RCxnREFBU0EsQ0FBQztRQUNSMkQsZUFBZUcsT0FBQSxFQUFTTyxpQkFBaUJuQjtJQUMzQyxHQUFHO1FBQUNBO1FBQWVNO0tBQWM7SUFHakN4RCxnREFBU0EsQ0FBQztRQUNSMkQsZUFBZUcsT0FBQSxFQUFTUSxTQUFTdkI7SUFDbkMsR0FBRztRQUFDQTtRQUFPUztLQUFjO0lBRXpCLE1BQU1lLFlBQVloRSxnRUFBWUEsQ0FBQztRQUFDbUQ7UUFBUUg7S0FBYTtJQUNyRCxPQUNFLGdCQUFBL0Msc0RBQUFBLENBQUM7UUFDQ2dFLEtBQUtEO1FBQ0xsQixPQUNFTCxVQUFVLFVBQWFDLFdBQVcsU0FDOUI7WUFDRUQsT0FBTyxPQUFPQSxVQUFVLFlBQVl5QixNQUFNLENBQUN6QixXQUFXLFFBQVEsQ0FBQ0EsUUFBUUE7WUFDdkVDLFFBQVEsT0FBT0EsV0FBVyxZQUFZd0IsTUFBTSxDQUFDeEIsWUFBWSxRQUFRLENBQUNBLFNBQVNBO1lBQzNFLEdBQUdJLEtBQUE7UUFDTCxJQUNBQTtRQUVMLEdBQUdDLFFBQUE7SUFBQTtBQUdWO0FBR0ZsRCxZQUFZc0UsV0FBQSxHQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uLi9zcmMvc2hhZGVyLW1vdW50LnRzeD80MDUzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIGZvcndhcmRSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHtcbiAgU2hhZGVyTW91bnQgYXMgU2hhZGVyTW91bnRWYW5pbGxhLFxuICBnZXRFbXB0eVBpeGVsLFxuICB0eXBlIFBhcGVyU2hhZGVyRWxlbWVudCxcbiAgdHlwZSBTaGFkZXJNb3Rpb25QYXJhbXMsXG4gIHR5cGUgU2hhZGVyTW91bnRVbmlmb3Jtcyxcbn0gZnJvbSAnQHBhcGVyLWRlc2lnbi9zaGFkZXJzJztcbmltcG9ydCB7IHVzZU1lcmdlUmVmcyB9IGZyb20gJy4vdXNlLW1lcmdlLXJlZnMuanMnO1xuXG4vKipcbiAqIFJlYWN0IFNoYWRlciBNb3VudCBjYW4gYWxzbyBhY2NlcHQgc3RyaW5ncyBhcyB1bmlmb3JtIHZhbHVlcywgd2hpY2ggd2lsbCBhc3N1bWVkIHRvIGJlIFVSTHMgYW5kIGxvYWRlZCBhcyBpbWFnZXNcbiAqXG4gKiBXZSBhY2NlcHQgdW5kZWZpbmVkIGFzIGEgY29udmVuaWVuY2UgZm9yIHNlcnZlciByZW5kZXJpbmcsIHdoZW4gc29tZSB0aGluZ3MgbWF5IGJlIHVuZGVmaW5lZFxuICogV2UganVzdCBza2lwIHNldHRpbmcgdGhlIHVuaWZvcm0gaWYgaXQncyB1bmRlZmluZWQuIFRoaXMgYWxsb3dzIHRoZSBzaGFkZXIgbW91bnQgdG8gc3RpbGwgdGFrZSB1cCBzcGFjZSBkdXJpbmcgc2VydmVyIHJlbmRlcmluZ1xuICovXG5pbnRlcmZhY2UgU2hhZGVyTW91bnRVbmlmb3Jtc1JlYWN0IHtcbiAgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgYm9vbGVhbiB8IG51bWJlciB8IG51bWJlcltdIHwgbnVtYmVyW11bXSB8IEhUTUxJbWFnZUVsZW1lbnQgfCB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2hhZGVyTW91bnRQcm9wcyBleHRlbmRzIE9taXQ8UmVhY3QuQ29tcG9uZW50UHJvcHM8J2Rpdic+LCAnY29sb3InIHwgJ3JlZic+LCBTaGFkZXJNb3Rpb25QYXJhbXMge1xuICByZWY/OiBSZWFjdC5SZWY8UGFwZXJTaGFkZXJFbGVtZW50PjtcbiAgZnJhZ21lbnRTaGFkZXI6IHN0cmluZztcbiAgdW5pZm9ybXM6IFNoYWRlck1vdW50VW5pZm9ybXNSZWFjdDtcbiAgbWlwbWFwcz86IHN0cmluZ1tdO1xuICBtaW5QaXhlbFJhdGlvPzogbnVtYmVyO1xuICBtYXhQaXhlbENvdW50PzogbnVtYmVyO1xuICB3ZWJHbENvbnRleHRBdHRyaWJ1dGVzPzogV2ViR0xDb250ZXh0QXR0cmlidXRlcztcblxuICAvKiogSW5saW5lIENTUyB3aWR0aCBzdHlsZSAqL1xuICB3aWR0aD86IHN0cmluZyB8IG51bWJlcjtcbiAgLyoqIElubGluZSBDU1MgaGVpZ2h0IHN0eWxlICovXG4gIGhlaWdodD86IHN0cmluZyB8IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTaGFkZXJDb21wb25lbnRQcm9wcyBleHRlbmRzIE9taXQ8UmVhY3QuQ29tcG9uZW50UHJvcHM8J2Rpdic+LCAnY29sb3InIHwgJ3JlZic+IHtcbiAgcmVmPzogUmVhY3QuUmVmPFBhcGVyU2hhZGVyRWxlbWVudD47XG4gIG1pblBpeGVsUmF0aW8/OiBudW1iZXI7XG4gIG1heFBpeGVsQ291bnQ/OiBudW1iZXI7XG4gIHdlYkdsQ29udGV4dEF0dHJpYnV0ZXM/OiBXZWJHTENvbnRleHRBdHRyaWJ1dGVzO1xuXG4gIC8qKiBJbmxpbmUgQ1NTIHdpZHRoIHN0eWxlICovXG4gIHdpZHRoPzogc3RyaW5nIHwgbnVtYmVyO1xuICAvKiogSW5saW5lIENTUyBoZWlnaHQgc3R5bGUgKi9cbiAgaGVpZ2h0Pzogc3RyaW5nIHwgbnVtYmVyO1xufVxuXG4vKiogUGFyc2UgdGhlIHByb3ZpZGVkIHVuaWZvcm1zLCB0dXJuaW5nIFVSTCBzdHJpbmdzIGludG8gbG9hZGVkIGltYWdlcyAqL1xuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1VuaWZvcm1zKHVuaWZvcm1zUHJvcDogU2hhZGVyTW91bnRVbmlmb3Jtc1JlYWN0KTogUHJvbWlzZTxTaGFkZXJNb3VudFVuaWZvcm1zPiB7XG4gIGNvbnN0IHByb2Nlc3NlZFVuaWZvcm1zID0ge30gYXMgU2hhZGVyTW91bnRVbmlmb3JtcztcbiAgY29uc3QgaW1hZ2VMb2FkUHJvbWlzZXM6IFByb21pc2U8dm9pZD5bXSA9IFtdO1xuXG4gIGNvbnN0IGlzVmFsaWRVcmwgPSAodXJsOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gSGFuZGxlIGFic29sdXRlIHBhdGhzXG4gICAgICBpZiAodXJsLnN0YXJ0c1dpdGgoJy8nKSkgcmV0dXJuIHRydWU7XG4gICAgICAvLyBDaGVjayBpZiBpdCdzIGEgdmFsaWQgVVJMXG4gICAgICBuZXcgVVJMKHVybCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgaXNFeHRlcm5hbFVybCA9ICh1cmw6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAodXJsLnN0YXJ0c1dpdGgoJy8nKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgY29uc3QgdXJsT2JqZWN0ID0gbmV3IFVSTCh1cmwsIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pO1xuICAgICAgcmV0dXJuIHVybE9iamVjdC5vcmlnaW4gIT09IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW47XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIE9iamVjdC5lbnRyaWVzKHVuaWZvcm1zUHJvcCkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFVzZSBhIHRyYW5zcGFyZW50IHBpeGVsIGZvciBlbXB0eSBzdHJpbmdzXG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHByb2Nlc3NlZFVuaWZvcm1zW2tleV0gPSBnZXRFbXB0eVBpeGVsKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gTWFrZSBzdXJlIHRoZSBwcm92aWRlZCBzdHJpbmcgaXMgYSB2YWxpZCBVUkwgb3IganVzdCBza2lwIHRyeWluZyB0byBzZXQgdGhpcyB1bmlmb3JtIGVudGlyZWx5XG4gICAgICBpZiAoIWlzVmFsaWRVcmwodmFsdWUpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgVW5pZm9ybSBcIiR7a2V5fVwiIGhhcyBpbnZhbGlkIFVSTCBcIiR7dmFsdWV9XCIuIFNraXBwaW5nIGltYWdlIGxvYWRpbmcuYCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaW1hZ2VQcm9taXNlID0gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgaWYgKGlzRXh0ZXJuYWxVcmwodmFsdWUpKSB7XG4gICAgICAgICAgaW1nLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cyc7XG4gICAgICAgIH1cbiAgICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICBwcm9jZXNzZWRVbmlmb3Jtc1trZXldID0gaW1nO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaW1nLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgQ291bGQgbm90IHNldCB1bmlmb3Jtcy4gRmFpbGVkIHRvIGxvYWQgaW1hZ2UgYXQgJHt2YWx1ZX1gKTtcbiAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaW1nLnNyYyA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgICBpbWFnZUxvYWRQcm9taXNlcy5wdXNoKGltYWdlUHJvbWlzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3NlZFVuaWZvcm1zW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIGF3YWl0IFByb21pc2UuYWxsKGltYWdlTG9hZFByb21pc2VzKTtcbiAgcmV0dXJuIHByb2Nlc3NlZFVuaWZvcm1zO1xufVxuXG4vKipcbiAqIEEgUmVhY3QgY29tcG9uZW50IHRoYXQgbW91bnRzIGEgc2hhZGVyIGFuZCB1cGRhdGVzIGl0cyB1bmlmb3JtcyBhcyB0aGUgY29tcG9uZW50J3MgcHJvcHMgY2hhbmdlXG4gKiBJZiB5b3UgcGFzcyBhIHN0cmluZyBhcyBhIHVuaWZvcm0gdmFsdWUsIGl0IHdpbGwgYmUgYXNzdW1lZCB0byBiZSBhIFVSTCBhbmQgYXR0ZW1wdGVkIHRvIGJlIGxvYWRlZCBhcyBhbiBpbWFnZVxuICovXG5leHBvcnQgY29uc3QgU2hhZGVyTW91bnQ6IFJlYWN0LkZDPFNoYWRlck1vdW50UHJvcHM+ID0gZm9yd2FyZFJlZjxQYXBlclNoYWRlckVsZW1lbnQsIFNoYWRlck1vdW50UHJvcHM+KFxuICBmdW5jdGlvbiBTaGFkZXJNb3VudEltcGwoXG4gICAge1xuICAgICAgZnJhZ21lbnRTaGFkZXIsXG4gICAgICB1bmlmb3JtczogdW5pZm9ybXNQcm9wLFxuICAgICAgd2ViR2xDb250ZXh0QXR0cmlidXRlcyxcbiAgICAgIHNwZWVkID0gMCxcbiAgICAgIGZyYW1lID0gMCxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgbWluUGl4ZWxSYXRpbyxcbiAgICAgIG1heFBpeGVsQ291bnQsXG4gICAgICBtaXBtYXBzLFxuICAgICAgc3R5bGUsXG4gICAgICAuLi5kaXZQcm9wc1xuICAgIH0sXG4gICAgZm9yd2FyZGVkUmVmXG4gICkge1xuICAgIGNvbnN0IFtpc0luaXRpYWxpemVkLCBzZXRJc0luaXRpYWxpemVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBkaXZSZWYgPSB1c2VSZWY8UGFwZXJTaGFkZXJFbGVtZW50PihudWxsKTtcbiAgICBjb25zdCBzaGFkZXJNb3VudFJlZjogUmVhY3QuUmVmT2JqZWN0PFNoYWRlck1vdW50VmFuaWxsYSB8IG51bGw+ID0gdXNlUmVmPFNoYWRlck1vdW50VmFuaWxsYT4obnVsbCk7XG4gICAgY29uc3Qgd2ViR2xDb250ZXh0QXR0cmlidXRlc1JlZiA9IHVzZVJlZih3ZWJHbENvbnRleHRBdHRyaWJ1dGVzKTtcblxuICAgIC8vIEluaXRpYWxpemUgdGhlIFNoYWRlck1vdW50VmFuaWxsYVxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBjb25zdCBpbml0U2hhZGVyID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCB1bmlmb3JtcyA9IGF3YWl0IHByb2Nlc3NVbmlmb3Jtcyh1bmlmb3Jtc1Byb3ApO1xuXG4gICAgICAgIGlmIChkaXZSZWYuY3VycmVudCAmJiAhc2hhZGVyTW91bnRSZWYuY3VycmVudCkge1xuICAgICAgICAgIHNoYWRlck1vdW50UmVmLmN1cnJlbnQgPSBuZXcgU2hhZGVyTW91bnRWYW5pbGxhKFxuICAgICAgICAgICAgZGl2UmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBmcmFnbWVudFNoYWRlcixcbiAgICAgICAgICAgIHVuaWZvcm1zLFxuICAgICAgICAgICAgd2ViR2xDb250ZXh0QXR0cmlidXRlc1JlZi5jdXJyZW50LFxuICAgICAgICAgICAgc3BlZWQsXG4gICAgICAgICAgICBmcmFtZSxcbiAgICAgICAgICAgIG1pblBpeGVsUmF0aW8sXG4gICAgICAgICAgICBtYXhQaXhlbENvdW50LFxuICAgICAgICAgICAgbWlwbWFwc1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICBzZXRJc0luaXRpYWxpemVkKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpbml0U2hhZGVyKCk7XG5cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHNoYWRlck1vdW50UmVmLmN1cnJlbnQ/LmRpc3Bvc2UoKTtcbiAgICAgICAgc2hhZGVyTW91bnRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9O1xuICAgIH0sIFtmcmFnbWVudFNoYWRlcl0pO1xuXG4gICAgLy8gVW5pZm9ybXNcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgbGV0IGlzU3RhbGUgPSBmYWxzZTtcblxuICAgICAgY29uc3QgdXBkYXRlVW5pZm9ybXMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHVuaWZvcm1zID0gYXdhaXQgcHJvY2Vzc1VuaWZvcm1zKHVuaWZvcm1zUHJvcCk7XG5cbiAgICAgICAgaWYgKCFpc1N0YWxlKSB7XG4gICAgICAgICAgLy8gV2Ugb25seSB1c2UgdGhlIGZyZXNoZXN0IHVuaWZvcm1zIG90aGVyd2lzZSB3ZSBjYW4gZ2V0IGludG8gcmFjZSBjb25kaXRpb25zXG4gICAgICAgICAgLy8gaWYgc29tZSB1bmlmb3JtcyAoaW1hZ2VzISkgdGFrZSBsb25nZXIgdG8gbG9hZCBpbiBzdWJzZXF1ZW50IGVmZmVjdCBydW5zLlxuICAgICAgICAgIHNoYWRlck1vdW50UmVmLmN1cnJlbnQ/LnNldFVuaWZvcm1zKHVuaWZvcm1zKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdXBkYXRlVW5pZm9ybXMoKTtcblxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaXNTdGFsZSA9IHRydWU7XG4gICAgICB9O1xuICAgIH0sIFt1bmlmb3Jtc1Byb3AsIGlzSW5pdGlhbGl6ZWRdKTtcblxuICAgIC8vIFNwZWVkXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIHNoYWRlck1vdW50UmVmLmN1cnJlbnQ/LnNldFNwZWVkKHNwZWVkKTtcbiAgICB9LCBbc3BlZWQsIGlzSW5pdGlhbGl6ZWRdKTtcblxuICAgIC8vIE1heCBQaXhlbCBDb3VudFxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBzaGFkZXJNb3VudFJlZi5jdXJyZW50Py5zZXRNYXhQaXhlbENvdW50KG1heFBpeGVsQ291bnQpO1xuICAgIH0sIFttYXhQaXhlbENvdW50LCBpc0luaXRpYWxpemVkXSk7XG5cbiAgICAvLyBNaW4gUGl4ZWwgUmF0aW9cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgc2hhZGVyTW91bnRSZWYuY3VycmVudD8uc2V0TWluUGl4ZWxSYXRpbyhtaW5QaXhlbFJhdGlvKTtcbiAgICB9LCBbbWluUGl4ZWxSYXRpbywgaXNJbml0aWFsaXplZF0pO1xuXG4gICAgLy8gRnJhbWVcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgc2hhZGVyTW91bnRSZWYuY3VycmVudD8uc2V0RnJhbWUoZnJhbWUpO1xuICAgIH0sIFtmcmFtZSwgaXNJbml0aWFsaXplZF0pO1xuXG4gICAgY29uc3QgbWVyZ2VkUmVmID0gdXNlTWVyZ2VSZWZzKFtkaXZSZWYsIGZvcndhcmRlZFJlZl0pIGFzIHVua25vd24gYXMgUmVhY3QuUmVmT2JqZWN0PEhUTUxEaXZFbGVtZW50PjtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdlxuICAgICAgICByZWY9e21lcmdlZFJlZn1cbiAgICAgICAgc3R5bGU9e1xuICAgICAgICAgIHdpZHRoICE9PSB1bmRlZmluZWQgfHwgaGVpZ2h0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiB0eXBlb2Ygd2lkdGggPT09ICdzdHJpbmcnICYmIGlzTmFOKCt3aWR0aCkgPT09IGZhbHNlID8gK3dpZHRoIDogd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0eXBlb2YgaGVpZ2h0ID09PSAnc3RyaW5nJyAmJiBpc05hTigraGVpZ2h0KSA9PT0gZmFsc2UgPyAraGVpZ2h0IDogaGVpZ2h0LFxuICAgICAgICAgICAgICAgIC4uLnN0eWxlLFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHN0eWxlXG4gICAgICAgIH1cbiAgICAgICAgey4uLmRpdlByb3BzfVxuICAgICAgLz5cbiAgICApO1xuICB9XG4pO1xuXG5TaGFkZXJNb3VudC5kaXNwbGF5TmFtZSA9ICdTaGFkZXJNb3VudCc7XG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwiZm9yd2FyZFJlZiIsInVzZVN0YXRlIiwiU2hhZGVyTW91bnQiLCJTaGFkZXJNb3VudFZhbmlsbGEiLCJnZXRFbXB0eVBpeGVsIiwidXNlTWVyZ2VSZWZzIiwianN4IiwicHJvY2Vzc1VuaWZvcm1zIiwidW5pZm9ybXNQcm9wIiwicHJvY2Vzc2VkVW5pZm9ybXMiLCJpbWFnZUxvYWRQcm9taXNlcyIsImlzVmFsaWRVcmwiLCJ1cmwiLCJzdGFydHNXaXRoIiwiVVJMIiwiaXNFeHRlcm5hbFVybCIsInVybE9iamVjdCIsIndpbmRvdyIsImxvY2F0aW9uIiwib3JpZ2luIiwiT2JqZWN0IiwiZW50cmllcyIsImZvckVhY2giLCJrZXkiLCJ2YWx1ZSIsImNvbnNvbGUiLCJ3YXJuIiwiaW1hZ2VQcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJpbWciLCJJbWFnZSIsImNyb3NzT3JpZ2luIiwib25sb2FkIiwib25lcnJvciIsImVycm9yIiwic3JjIiwicHVzaCIsImFsbCIsIlNoYWRlck1vdW50SW1wbCIsImZyYWdtZW50U2hhZGVyIiwidW5pZm9ybXMiLCJ3ZWJHbENvbnRleHRBdHRyaWJ1dGVzIiwic3BlZWQiLCJmcmFtZSIsIndpZHRoIiwiaGVpZ2h0IiwibWluUGl4ZWxSYXRpbyIsIm1heFBpeGVsQ291bnQiLCJtaXBtYXBzIiwic3R5bGUiLCJkaXZQcm9wcyIsImZvcndhcmRlZFJlZiIsImlzSW5pdGlhbGl6ZWQiLCJzZXRJc0luaXRpYWxpemVkIiwiZGl2UmVmIiwic2hhZGVyTW91bnRSZWYiLCJ3ZWJHbENvbnRleHRBdHRyaWJ1dGVzUmVmIiwiaW5pdFNoYWRlciIsImN1cnJlbnQiLCJkaXNwb3NlIiwiaXNTdGFsZSIsInVwZGF0ZVVuaWZvcm1zIiwic2V0VW5pZm9ybXMiLCJzZXRTcGVlZCIsInNldE1heFBpeGVsQ291bnQiLCJzZXRNaW5QaXhlbFJhdGlvIiwic2V0RnJhbWUiLCJtZXJnZWRSZWYiLCJyZWYiLCJpc05hTiIsImRpc3BsYXlOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders-react/dist/shader-mount.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders-react/dist/shaders/liquid-metal.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@paper-design/shaders-react/dist/shaders/liquid-metal.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LiquidMetal: () => (/* binding */ LiquidMetal),\n/* harmony export */   defaultPreset: () => (/* binding */ defaultPreset),\n/* harmony export */   fullScreenPreset: () => (/* binding */ fullScreenPreset),\n/* harmony export */   liquidMetalPresets: () => (/* binding */ liquidMetalPresets),\n/* harmony export */   noirPreset: () => (/* binding */ noirPreset),\n/* harmony export */   stripesPreset: () => (/* binding */ stripesPreset)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _shader_mount_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../shader-mount.js */ \"(ssr)/./node_modules/@paper-design/shaders-react/dist/shader-mount.js\");\n/* harmony import */ var _paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @paper-design/shaders */ \"(ssr)/./node_modules/@paper-design/shaders/dist/shader-sizing.js\");\n/* harmony import */ var _paper_design_shaders__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @paper-design/shaders */ \"(ssr)/./node_modules/@paper-design/shaders/dist/shaders/liquid-metal.js\");\n/* harmony import */ var _paper_design_shaders__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @paper-design/shaders */ \"(ssr)/./node_modules/@paper-design/shaders/dist/get-shader-color-from-string.js\");\n/* harmony import */ var _transparent_pixel_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../transparent-pixel.js */ \"(ssr)/./node_modules/@paper-design/shaders-react/dist/transparent-pixel.js\");\n/* harmony import */ var _suspend_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../suspend.js */ \"(ssr)/./node_modules/@paper-design/shaders-react/dist/suspend.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\n\n\n\n\n\nconst defaultPreset = {\n  name: \"Default\",\n  params: {\n    ..._paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.defaultObjectSizing,\n    scale: 0.6,\n    speed: 1,\n    frame: 0,\n    colorBack: \"#AAAAAC\",\n    colorTint: \"#ffffff\",\n    distortion: 0.07,\n    repetition: 2,\n    shiftRed: 0.3,\n    shiftBlue: 0.3,\n    contour: 0.4,\n    softness: 0.1,\n    angle: 70,\n    shape: \"diamond\"\n  }\n};\nconst noirPreset = {\n  name: \"Noir\",\n  params: {\n    ..._paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.defaultObjectSizing,\n    scale: 0.6,\n    speed: 1,\n    frame: 0,\n    colorBack: \"#000000\",\n    colorTint: \"#606060\",\n    softness: 0.45,\n    repetition: 1.5,\n    shiftRed: 0,\n    shiftBlue: 0,\n    distortion: 0,\n    contour: 0,\n    angle: 90,\n    shape: \"diamond\"\n  }\n};\nconst fullScreenPreset = {\n  name: \"Backdrop\",\n  params: {\n    ..._paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.defaultObjectSizing,\n    speed: 1,\n    frame: 0,\n    scale: 1.5,\n    colorBack: \"#AAAAAC\",\n    colorTint: \"#ffffff\",\n    softness: 0.05,\n    repetition: 1.5,\n    shiftRed: 0.3,\n    shiftBlue: 0.3,\n    distortion: 0.1,\n    contour: 0.4,\n    shape: \"none\",\n    angle: 90,\n    worldWidth: 0,\n    worldHeight: 0\n  }\n};\nconst stripesPreset = {\n  name: \"Stripes\",\n  params: {\n    ..._paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.defaultObjectSizing,\n    speed: 1,\n    frame: 0,\n    scale: 0.6,\n    colorBack: \"#000000\",\n    colorTint: \"#2c5d72\",\n    softness: 0.8,\n    repetition: 6,\n    shiftRed: 1,\n    shiftBlue: -1,\n    distortion: 0.4,\n    contour: 0.4,\n    shape: \"circle\",\n    angle: 0\n  }\n};\nconst liquidMetalPresets = [defaultPreset, noirPreset, fullScreenPreset, stripesPreset];\nconst LiquidMetal = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(function LiquidMetalImpl({\n  // Own props\n  colorBack = defaultPreset.params.colorBack,\n  colorTint = defaultPreset.params.colorTint,\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  image = \"\",\n  contour = defaultPreset.params.contour,\n  distortion = defaultPreset.params.distortion,\n  softness = defaultPreset.params.softness,\n  repetition = defaultPreset.params.repetition,\n  shiftRed = defaultPreset.params.shiftRed,\n  shiftBlue = defaultPreset.params.shiftBlue,\n  angle = defaultPreset.params.angle,\n  shape = defaultPreset.params.shape,\n  suspendWhenProcessingImage = false,\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  scale = defaultPreset.params.scale,\n  rotation = defaultPreset.params.rotation,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}) {\n  const imageUrl = typeof image === \"string\" ? image : image.src;\n  const [processedStateImage, setProcessedStateImage] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(_transparent_pixel_js__WEBPACK_IMPORTED_MODULE_3__.transparentPixel);\n  let processedImage;\n  if (suspendWhenProcessingImage && typeof window !== \"undefined\" && imageUrl) {\n    processedImage = (0,_suspend_js__WEBPACK_IMPORTED_MODULE_4__.suspend)(\n      () => (0,_paper_design_shaders__WEBPACK_IMPORTED_MODULE_5__.toProcessedLiquidMetal)(imageUrl).then((result) => URL.createObjectURL(result.pngBlob)),\n      [imageUrl, \"liquid-metal\"]\n    );\n  } else {\n    processedImage = processedStateImage;\n  }\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n    if (suspendWhenProcessingImage) {\n      return;\n    }\n    if (!imageUrl) {\n      setProcessedStateImage(_transparent_pixel_js__WEBPACK_IMPORTED_MODULE_3__.transparentPixel);\n      return;\n    }\n    let url;\n    let current = true;\n    (0,_paper_design_shaders__WEBPACK_IMPORTED_MODULE_5__.toProcessedLiquidMetal)(imageUrl).then((result) => {\n      if (current) {\n        url = URL.createObjectURL(result.pngBlob);\n        setProcessedStateImage(url);\n      }\n    });\n    return () => {\n      current = false;\n    };\n  }, [imageUrl, suspendWhenProcessingImage]);\n  const uniforms = {\n    // Own uniforms\n    u_colorBack: (0,_paper_design_shaders__WEBPACK_IMPORTED_MODULE_6__.getShaderColorFromString)(colorBack),\n    u_colorTint: (0,_paper_design_shaders__WEBPACK_IMPORTED_MODULE_6__.getShaderColorFromString)(colorTint),\n    u_image: processedImage,\n    u_contour: contour,\n    u_distortion: distortion,\n    u_softness: softness,\n    u_repetition: repetition,\n    u_shiftRed: shiftRed,\n    u_shiftBlue: shiftBlue,\n    u_angle: angle,\n    u_isImage: Boolean(image),\n    u_shape: _paper_design_shaders__WEBPACK_IMPORTED_MODULE_5__.LiquidMetalShapes[shape],\n    // Sizing uniforms\n    u_fit: _paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.ShaderFitOptions[fit],\n    u_scale: scale,\n    u_rotation: rotation,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight\n  };\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    _shader_mount_js__WEBPACK_IMPORTED_MODULE_7__.ShaderMount,\n    {\n      ...props,\n      speed,\n      frame,\n      fragmentShader: _paper_design_shaders__WEBPACK_IMPORTED_MODULE_5__.liquidMetalFragmentShader,\n      mipmaps: [\"u_image\"],\n      uniforms\n    }\n  );\n});\n\n//# sourceMappingURL=liquid-metal.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzLXJlYWN0L2Rpc3Qvc2hhZGVycy9saXF1aWQtbWV0YWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFd0Q7QUFDUDtBQVFsQjtBQUM0QjtBQUNuQjtBQUNBO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLE9BQU8sc0VBQW1CO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sc0VBQW1CO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sc0VBQW1CO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLHNFQUFtQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQ0FBSTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esd0RBQXdELCtDQUFRLENBQUMsbUVBQWdCO0FBQ2pGO0FBQ0E7QUFDQSxxQkFBcUIsb0RBQU87QUFDNUIsWUFBWSw2RUFBc0I7QUFDbEM7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsRUFBRSxzREFBZTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtRUFBZ0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDZFQUFzQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGlCQUFpQiwrRUFBd0I7QUFDekMsaUJBQWlCLCtFQUF3QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9FQUFpQjtBQUM5QjtBQUNBLFdBQVcsbUVBQWdCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixzREFBRztBQUM1QixJQUFJLHlEQUFXO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNEVBQXlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQVFDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0BwYXBlci1kZXNpZ24vc2hhZGVycy1yZWFjdC9kaXN0L3NoYWRlcnMvbGlxdWlkLW1ldGFsLmpzP2ViOGQiXSwic291cmNlc0NvbnRlbnQiOlsiLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqICAgICAgICAgICAgICAgICAgICBQYXBlciBTaGFkZXJzICAgICAgICAgICAgICAgICAgICAqXG4gKiAgICAgICBodHRwczovL2dpdGh1Yi5jb20vcGFwZXItZGVzaWduL3NoYWRlcnMgICAgICAgKlxuICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICovXG5cbmltcG9ydCB7IG1lbW8sIHVzZUxheW91dEVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IFNoYWRlck1vdW50IH0gZnJvbSBcIi4uL3NoYWRlci1tb3VudC5qc1wiO1xuaW1wb3J0IHtcbiAgbGlxdWlkTWV0YWxGcmFnbWVudFNoYWRlcixcbiAgU2hhZGVyRml0T3B0aW9ucyxcbiAgZGVmYXVsdE9iamVjdFNpemluZyxcbiAgdG9Qcm9jZXNzZWRMaXF1aWRNZXRhbCxcbiAgZ2V0U2hhZGVyQ29sb3JGcm9tU3RyaW5nLFxuICBMaXF1aWRNZXRhbFNoYXBlc1xufSBmcm9tIFwiQHBhcGVyLWRlc2lnbi9zaGFkZXJzXCI7XG5pbXBvcnQgeyB0cmFuc3BhcmVudFBpeGVsIH0gZnJvbSBcIi4uL3RyYW5zcGFyZW50LXBpeGVsLmpzXCI7XG5pbXBvcnQgeyBzdXNwZW5kIH0gZnJvbSBcIi4uL3N1c3BlbmQuanNcIjtcbmltcG9ydCB7IGpzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuY29uc3QgZGVmYXVsdFByZXNldCA9IHtcbiAgbmFtZTogXCJEZWZhdWx0XCIsXG4gIHBhcmFtczoge1xuICAgIC4uLmRlZmF1bHRPYmplY3RTaXppbmcsXG4gICAgc2NhbGU6IDAuNixcbiAgICBzcGVlZDogMSxcbiAgICBmcmFtZTogMCxcbiAgICBjb2xvckJhY2s6IFwiI0FBQUFBQ1wiLFxuICAgIGNvbG9yVGludDogXCIjZmZmZmZmXCIsXG4gICAgZGlzdG9ydGlvbjogMC4wNyxcbiAgICByZXBldGl0aW9uOiAyLFxuICAgIHNoaWZ0UmVkOiAwLjMsXG4gICAgc2hpZnRCbHVlOiAwLjMsXG4gICAgY29udG91cjogMC40LFxuICAgIHNvZnRuZXNzOiAwLjEsXG4gICAgYW5nbGU6IDcwLFxuICAgIHNoYXBlOiBcImRpYW1vbmRcIlxuICB9XG59O1xuY29uc3Qgbm9pclByZXNldCA9IHtcbiAgbmFtZTogXCJOb2lyXCIsXG4gIHBhcmFtczoge1xuICAgIC4uLmRlZmF1bHRPYmplY3RTaXppbmcsXG4gICAgc2NhbGU6IDAuNixcbiAgICBzcGVlZDogMSxcbiAgICBmcmFtZTogMCxcbiAgICBjb2xvckJhY2s6IFwiIzAwMDAwMFwiLFxuICAgIGNvbG9yVGludDogXCIjNjA2MDYwXCIsXG4gICAgc29mdG5lc3M6IDAuNDUsXG4gICAgcmVwZXRpdGlvbjogMS41LFxuICAgIHNoaWZ0UmVkOiAwLFxuICAgIHNoaWZ0Qmx1ZTogMCxcbiAgICBkaXN0b3J0aW9uOiAwLFxuICAgIGNvbnRvdXI6IDAsXG4gICAgYW5nbGU6IDkwLFxuICAgIHNoYXBlOiBcImRpYW1vbmRcIlxuICB9XG59O1xuY29uc3QgZnVsbFNjcmVlblByZXNldCA9IHtcbiAgbmFtZTogXCJCYWNrZHJvcFwiLFxuICBwYXJhbXM6IHtcbiAgICAuLi5kZWZhdWx0T2JqZWN0U2l6aW5nLFxuICAgIHNwZWVkOiAxLFxuICAgIGZyYW1lOiAwLFxuICAgIHNjYWxlOiAxLjUsXG4gICAgY29sb3JCYWNrOiBcIiNBQUFBQUNcIixcbiAgICBjb2xvclRpbnQ6IFwiI2ZmZmZmZlwiLFxuICAgIHNvZnRuZXNzOiAwLjA1LFxuICAgIHJlcGV0aXRpb246IDEuNSxcbiAgICBzaGlmdFJlZDogMC4zLFxuICAgIHNoaWZ0Qmx1ZTogMC4zLFxuICAgIGRpc3RvcnRpb246IDAuMSxcbiAgICBjb250b3VyOiAwLjQsXG4gICAgc2hhcGU6IFwibm9uZVwiLFxuICAgIGFuZ2xlOiA5MCxcbiAgICB3b3JsZFdpZHRoOiAwLFxuICAgIHdvcmxkSGVpZ2h0OiAwXG4gIH1cbn07XG5jb25zdCBzdHJpcGVzUHJlc2V0ID0ge1xuICBuYW1lOiBcIlN0cmlwZXNcIixcbiAgcGFyYW1zOiB7XG4gICAgLi4uZGVmYXVsdE9iamVjdFNpemluZyxcbiAgICBzcGVlZDogMSxcbiAgICBmcmFtZTogMCxcbiAgICBzY2FsZTogMC42LFxuICAgIGNvbG9yQmFjazogXCIjMDAwMDAwXCIsXG4gICAgY29sb3JUaW50OiBcIiMyYzVkNzJcIixcbiAgICBzb2Z0bmVzczogMC44LFxuICAgIHJlcGV0aXRpb246IDYsXG4gICAgc2hpZnRSZWQ6IDEsXG4gICAgc2hpZnRCbHVlOiAtMSxcbiAgICBkaXN0b3J0aW9uOiAwLjQsXG4gICAgY29udG91cjogMC40LFxuICAgIHNoYXBlOiBcImNpcmNsZVwiLFxuICAgIGFuZ2xlOiAwXG4gIH1cbn07XG5jb25zdCBsaXF1aWRNZXRhbFByZXNldHMgPSBbZGVmYXVsdFByZXNldCwgbm9pclByZXNldCwgZnVsbFNjcmVlblByZXNldCwgc3RyaXBlc1ByZXNldF07XG5jb25zdCBMaXF1aWRNZXRhbCA9IG1lbW8oZnVuY3Rpb24gTGlxdWlkTWV0YWxJbXBsKHtcbiAgLy8gT3duIHByb3BzXG4gIGNvbG9yQmFjayA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLmNvbG9yQmFjayxcbiAgY29sb3JUaW50ID0gZGVmYXVsdFByZXNldC5wYXJhbXMuY29sb3JUaW50LFxuICBzcGVlZCA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLnNwZWVkLFxuICBmcmFtZSA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLmZyYW1lLFxuICBpbWFnZSA9IFwiXCIsXG4gIGNvbnRvdXIgPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5jb250b3VyLFxuICBkaXN0b3J0aW9uID0gZGVmYXVsdFByZXNldC5wYXJhbXMuZGlzdG9ydGlvbixcbiAgc29mdG5lc3MgPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5zb2Z0bmVzcyxcbiAgcmVwZXRpdGlvbiA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLnJlcGV0aXRpb24sXG4gIHNoaWZ0UmVkID0gZGVmYXVsdFByZXNldC5wYXJhbXMuc2hpZnRSZWQsXG4gIHNoaWZ0Qmx1ZSA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLnNoaWZ0Qmx1ZSxcbiAgYW5nbGUgPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5hbmdsZSxcbiAgc2hhcGUgPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5zaGFwZSxcbiAgc3VzcGVuZFdoZW5Qcm9jZXNzaW5nSW1hZ2UgPSBmYWxzZSxcbiAgLy8gU2l6aW5nIHByb3BzXG4gIGZpdCA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLmZpdCxcbiAgc2NhbGUgPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5zY2FsZSxcbiAgcm90YXRpb24gPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5yb3RhdGlvbixcbiAgb3JpZ2luWCA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLm9yaWdpblgsXG4gIG9yaWdpblkgPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5vcmlnaW5ZLFxuICBvZmZzZXRYID0gZGVmYXVsdFByZXNldC5wYXJhbXMub2Zmc2V0WCxcbiAgb2Zmc2V0WSA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLm9mZnNldFksXG4gIHdvcmxkV2lkdGggPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy53b3JsZFdpZHRoLFxuICB3b3JsZEhlaWdodCA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLndvcmxkSGVpZ2h0LFxuICAuLi5wcm9wc1xufSkge1xuICBjb25zdCBpbWFnZVVybCA9IHR5cGVvZiBpbWFnZSA9PT0gXCJzdHJpbmdcIiA/IGltYWdlIDogaW1hZ2Uuc3JjO1xuICBjb25zdCBbcHJvY2Vzc2VkU3RhdGVJbWFnZSwgc2V0UHJvY2Vzc2VkU3RhdGVJbWFnZV0gPSB1c2VTdGF0ZSh0cmFuc3BhcmVudFBpeGVsKTtcbiAgbGV0IHByb2Nlc3NlZEltYWdlO1xuICBpZiAoc3VzcGVuZFdoZW5Qcm9jZXNzaW5nSW1hZ2UgJiYgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpbWFnZVVybCkge1xuICAgIHByb2Nlc3NlZEltYWdlID0gc3VzcGVuZChcbiAgICAgICgpID0+IHRvUHJvY2Vzc2VkTGlxdWlkTWV0YWwoaW1hZ2VVcmwpLnRoZW4oKHJlc3VsdCkgPT4gVVJMLmNyZWF0ZU9iamVjdFVSTChyZXN1bHQucG5nQmxvYikpLFxuICAgICAgW2ltYWdlVXJsLCBcImxpcXVpZC1tZXRhbFwiXVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgcHJvY2Vzc2VkSW1hZ2UgPSBwcm9jZXNzZWRTdGF0ZUltYWdlO1xuICB9XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHN1c3BlbmRXaGVuUHJvY2Vzc2luZ0ltYWdlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghaW1hZ2VVcmwpIHtcbiAgICAgIHNldFByb2Nlc3NlZFN0YXRlSW1hZ2UodHJhbnNwYXJlbnRQaXhlbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCB1cmw7XG4gICAgbGV0IGN1cnJlbnQgPSB0cnVlO1xuICAgIHRvUHJvY2Vzc2VkTGlxdWlkTWV0YWwoaW1hZ2VVcmwpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChyZXN1bHQucG5nQmxvYik7XG4gICAgICAgIHNldFByb2Nlc3NlZFN0YXRlSW1hZ2UodXJsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY3VycmVudCA9IGZhbHNlO1xuICAgIH07XG4gIH0sIFtpbWFnZVVybCwgc3VzcGVuZFdoZW5Qcm9jZXNzaW5nSW1hZ2VdKTtcbiAgY29uc3QgdW5pZm9ybXMgPSB7XG4gICAgLy8gT3duIHVuaWZvcm1zXG4gICAgdV9jb2xvckJhY2s6IGdldFNoYWRlckNvbG9yRnJvbVN0cmluZyhjb2xvckJhY2spLFxuICAgIHVfY29sb3JUaW50OiBnZXRTaGFkZXJDb2xvckZyb21TdHJpbmcoY29sb3JUaW50KSxcbiAgICB1X2ltYWdlOiBwcm9jZXNzZWRJbWFnZSxcbiAgICB1X2NvbnRvdXI6IGNvbnRvdXIsXG4gICAgdV9kaXN0b3J0aW9uOiBkaXN0b3J0aW9uLFxuICAgIHVfc29mdG5lc3M6IHNvZnRuZXNzLFxuICAgIHVfcmVwZXRpdGlvbjogcmVwZXRpdGlvbixcbiAgICB1X3NoaWZ0UmVkOiBzaGlmdFJlZCxcbiAgICB1X3NoaWZ0Qmx1ZTogc2hpZnRCbHVlLFxuICAgIHVfYW5nbGU6IGFuZ2xlLFxuICAgIHVfaXNJbWFnZTogQm9vbGVhbihpbWFnZSksXG4gICAgdV9zaGFwZTogTGlxdWlkTWV0YWxTaGFwZXNbc2hhcGVdLFxuICAgIC8vIFNpemluZyB1bmlmb3Jtc1xuICAgIHVfZml0OiBTaGFkZXJGaXRPcHRpb25zW2ZpdF0sXG4gICAgdV9zY2FsZTogc2NhbGUsXG4gICAgdV9yb3RhdGlvbjogcm90YXRpb24sXG4gICAgdV9vZmZzZXRYOiBvZmZzZXRYLFxuICAgIHVfb2Zmc2V0WTogb2Zmc2V0WSxcbiAgICB1X29yaWdpblg6IG9yaWdpblgsXG4gICAgdV9vcmlnaW5ZOiBvcmlnaW5ZLFxuICAgIHVfd29ybGRXaWR0aDogd29ybGRXaWR0aCxcbiAgICB1X3dvcmxkSGVpZ2h0OiB3b3JsZEhlaWdodFxuICB9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChcbiAgICBTaGFkZXJNb3VudCxcbiAgICB7XG4gICAgICAuLi5wcm9wcyxcbiAgICAgIHNwZWVkLFxuICAgICAgZnJhbWUsXG4gICAgICBmcmFnbWVudFNoYWRlcjogbGlxdWlkTWV0YWxGcmFnbWVudFNoYWRlcixcbiAgICAgIG1pcG1hcHM6IFtcInVfaW1hZ2VcIl0sXG4gICAgICB1bmlmb3Jtc1xuICAgIH1cbiAgKTtcbn0pO1xuZXhwb3J0IHtcbiAgTGlxdWlkTWV0YWwsXG4gIGRlZmF1bHRQcmVzZXQsXG4gIGZ1bGxTY3JlZW5QcmVzZXQsXG4gIGxpcXVpZE1ldGFsUHJlc2V0cyxcbiAgbm9pclByZXNldCxcbiAgc3RyaXBlc1ByZXNldFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpcXVpZC1tZXRhbC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders-react/dist/shaders/liquid-metal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders-react/dist/suspend.js":
/*!******************************************************************!*\
  !*** ./node_modules/@paper-design/shaders-react/dist/suspend.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   suspend: () => (/* binding */ suspend)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nconst isPromise = (promise) => typeof promise === \"object\" && typeof promise.then === \"function\";\nconst globalCache = [];\nfunction shallowEqualArrays(arrA, arrB) {\n  if (arrA === arrB) return true;\n  if (!arrA || !arrB) return false;\n  const len = arrA.length;\n  if (arrB.length !== len) return false;\n  for (let i = 0; i < len; i++) if (arrA[i] !== arrB[i]) return false;\n  return true;\n}\nfunction query(fn, keys = null) {\n  if (keys === null) keys = [fn];\n  for (const entry2 of globalCache) {\n    if (shallowEqualArrays(keys, entry2.keys)) {\n      if (Object.prototype.hasOwnProperty.call(entry2, \"error\")) throw entry2.error;\n      if (Object.prototype.hasOwnProperty.call(entry2, \"response\")) {\n        return entry2.response;\n      }\n      throw entry2.promise;\n    }\n  }\n  const entry = {\n    keys,\n    promise: (\n      // Execute the promise\n      (isPromise(fn) ? fn : fn(...keys)).then((response) => {\n        entry.response = response;\n      }).catch((error) => entry.error = error)\n    )\n  };\n  globalCache.push(entry);\n  throw entry.promise;\n}\nconst suspend = (fn, keys) => query(fn, keys);\n\n//# sourceMappingURL=suspend.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzLXJlYWN0L2Rpc3Qvc3VzcGVuZC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9AcGFwZXItZGVzaWduL3NoYWRlcnMtcmVhY3QvZGlzdC9zdXNwZW5kLmpzP2VjYjciXSwic291cmNlc0NvbnRlbnQiOlsiLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqICAgICAgICAgICAgICAgICAgICBQYXBlciBTaGFkZXJzICAgICAgICAgICAgICAgICAgICAqXG4gKiAgICAgICBodHRwczovL2dpdGh1Yi5jb20vcGFwZXItZGVzaWduL3NoYWRlcnMgICAgICAgKlxuICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICovXG5cbmNvbnN0IGlzUHJvbWlzZSA9IChwcm9taXNlKSA9PiB0eXBlb2YgcHJvbWlzZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcHJvbWlzZS50aGVuID09PSBcImZ1bmN0aW9uXCI7XG5jb25zdCBnbG9iYWxDYWNoZSA9IFtdO1xuZnVuY3Rpb24gc2hhbGxvd0VxdWFsQXJyYXlzKGFyckEsIGFyckIpIHtcbiAgaWYgKGFyckEgPT09IGFyckIpIHJldHVybiB0cnVlO1xuICBpZiAoIWFyckEgfHwgIWFyckIpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgbGVuID0gYXJyQS5sZW5ndGg7XG4gIGlmIChhcnJCLmxlbmd0aCAhPT0gbGVuKSByZXR1cm4gZmFsc2U7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIGlmIChhcnJBW2ldICE9PSBhcnJCW2ldKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gcXVlcnkoZm4sIGtleXMgPSBudWxsKSB7XG4gIGlmIChrZXlzID09PSBudWxsKSBrZXlzID0gW2ZuXTtcbiAgZm9yIChjb25zdCBlbnRyeTIgb2YgZ2xvYmFsQ2FjaGUpIHtcbiAgICBpZiAoc2hhbGxvd0VxdWFsQXJyYXlzKGtleXMsIGVudHJ5Mi5rZXlzKSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlbnRyeTIsIFwiZXJyb3JcIikpIHRocm93IGVudHJ5Mi5lcnJvcjtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZW50cnkyLCBcInJlc3BvbnNlXCIpKSB7XG4gICAgICAgIHJldHVybiBlbnRyeTIucmVzcG9uc2U7XG4gICAgICB9XG4gICAgICB0aHJvdyBlbnRyeTIucHJvbWlzZTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZW50cnkgPSB7XG4gICAga2V5cyxcbiAgICBwcm9taXNlOiAoXG4gICAgICAvLyBFeGVjdXRlIHRoZSBwcm9taXNlXG4gICAgICAoaXNQcm9taXNlKGZuKSA/IGZuIDogZm4oLi4ua2V5cykpLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGVudHJ5LnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IGVudHJ5LmVycm9yID0gZXJyb3IpXG4gICAgKVxuICB9O1xuICBnbG9iYWxDYWNoZS5wdXNoKGVudHJ5KTtcbiAgdGhyb3cgZW50cnkucHJvbWlzZTtcbn1cbmNvbnN0IHN1c3BlbmQgPSAoZm4sIGtleXMpID0+IHF1ZXJ5KGZuLCBrZXlzKTtcbmV4cG9ydCB7XG4gIHN1c3BlbmRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdXNwZW5kLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders-react/dist/suspend.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders-react/dist/transparent-pixel.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@paper-design/shaders-react/dist/transparent-pixel.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   transparentPixel: () => (/* binding */ transparentPixel)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nconst transparentPixel = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n\n//# sourceMappingURL=transparent-pixel.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzLXJlYWN0L2Rpc3QvdHJhbnNwYXJlbnQtcGl4ZWwuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QztBQUd2QztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9AcGFwZXItZGVzaWduL3NoYWRlcnMtcmVhY3QvZGlzdC90cmFuc3BhcmVudC1waXhlbC5qcz85N2VlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiAgICAgICAgICAgICAgICAgICAgUGFwZXIgU2hhZGVycyAgICAgICAgICAgICAgICAgICAgKlxuICogICAgICAgaHR0cHM6Ly9naXRodWIuY29tL3BhcGVyLWRlc2lnbi9zaGFkZXJzICAgICAgICpcbiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqL1xuXG5jb25zdCB0cmFuc3BhcmVudFBpeGVsID0gXCJkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUFBQUFDSDVCQUVLQUFFQUxBQUFBQUFCQUFFQUFBSUNUQUVBT3c9PVwiO1xuZXhwb3J0IHtcbiAgdHJhbnNwYXJlbnRQaXhlbFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zcGFyZW50LXBpeGVsLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders-react/dist/transparent-pixel.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders-react/dist/use-merge-refs.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@paper-design/shaders-react/dist/use-merge-refs.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useMergeRefs: () => (/* binding */ useMergeRefs)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\nfunction useMergeRefs(refs) {\n  const cleanupRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(void 0);\n  const refEffect = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((instance) => {\n    const cleanups = refs.map((ref) => {\n      if (ref == null) {\n        return;\n      }\n      if (typeof ref === \"function\") {\n        const refCallback = ref;\n        const refCleanup = refCallback(instance);\n        return typeof refCleanup === \"function\" ? refCleanup : () => {\n          refCallback(null);\n        };\n      }\n      ref.current = instance;\n      return () => {\n        ref.current = null;\n      };\n    });\n    return () => {\n      cleanups.forEach((refCleanup) => refCleanup?.());\n    };\n  }, refs);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (refs.every((ref) => ref == null)) {\n      return null;\n    }\n    return (value) => {\n      if (cleanupRef.current) {\n        cleanupRef.current();\n        cleanupRef.current = void 0;\n      }\n      if (value != null) {\n        cleanupRef.current = refEffect(value);\n      }\n    };\n  }, refs);\n}\n\n//# sourceMappingURL=use-merge-refs.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzLXJlYWN0L2Rpc3QvdXNlLW1lcmdlLXJlZnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0I7QUFDL0I7QUFDQSxxQkFBcUIseUNBQVk7QUFDakMsb0JBQW9CLDhDQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFNBQVMsMENBQWE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBR0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzLXJlYWN0L2Rpc3QvdXNlLW1lcmdlLXJlZnMuanM/MWNiYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuICogICAgICAgICAgICAgICAgICAgIFBhcGVyIFNoYWRlcnMgICAgICAgICAgICAgICAgICAgICpcbiAqICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXBlci1kZXNpZ24vc2hhZGVycyAgICAgICAqXG4gKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKi9cblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiB1c2VNZXJnZVJlZnMocmVmcykge1xuICBjb25zdCBjbGVhbnVwUmVmID0gUmVhY3QudXNlUmVmKHZvaWQgMCk7XG4gIGNvbnN0IHJlZkVmZmVjdCA9IFJlYWN0LnVzZUNhbGxiYWNrKChpbnN0YW5jZSkgPT4ge1xuICAgIGNvbnN0IGNsZWFudXBzID0gcmVmcy5tYXAoKHJlZikgPT4ge1xuICAgICAgaWYgKHJlZiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcmVmID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3QgcmVmQ2FsbGJhY2sgPSByZWY7XG4gICAgICAgIGNvbnN0IHJlZkNsZWFudXAgPSByZWZDYWxsYmFjayhpbnN0YW5jZSk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcmVmQ2xlYW51cCA9PT0gXCJmdW5jdGlvblwiID8gcmVmQ2xlYW51cCA6ICgpID0+IHtcbiAgICAgICAgICByZWZDYWxsYmFjayhudWxsKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJlZi5jdXJyZW50ID0gaW5zdGFuY2U7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjbGVhbnVwcy5mb3JFYWNoKChyZWZDbGVhbnVwKSA9PiByZWZDbGVhbnVwPy4oKSk7XG4gICAgfTtcbiAgfSwgcmVmcyk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAocmVmcy5ldmVyeSgocmVmKSA9PiByZWYgPT0gbnVsbCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKHZhbHVlKSA9PiB7XG4gICAgICBpZiAoY2xlYW51cFJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNsZWFudXBSZWYuY3VycmVudCgpO1xuICAgICAgICBjbGVhbnVwUmVmLmN1cnJlbnQgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBjbGVhbnVwUmVmLmN1cnJlbnQgPSByZWZFZmZlY3QodmFsdWUpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIHJlZnMpO1xufVxuZXhwb3J0IHtcbiAgdXNlTWVyZ2VSZWZzXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLW1lcmdlLXJlZnMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders-react/dist/use-merge-refs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/get-empty-pixel.js":
/*!********************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/get-empty-pixel.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getEmptyPixel: () => (/* binding */ getEmptyPixel)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nfunction getEmptyPixel() {\n  if (typeof window === \"undefined\") {\n    console.warn(\"Paper Shaders: can\\u2019t create an image on the server\");\n    return void 0;\n  }\n  const img = new Image();\n  img.src = emptyPixel;\n  return img;\n}\nconst emptyPixel = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n\n//# sourceMappingURL=get-empty-pixel.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3QvZ2V0LWVtcHR5LXBpeGVsLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFHakM7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3QvZ2V0LWVtcHR5LXBpeGVsLmpzPzc0MTgiXSwic291cmNlc0NvbnRlbnQiOlsiLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqICAgICAgICAgICAgICAgICAgICBQYXBlciBTaGFkZXJzICAgICAgICAgICAgICAgICAgICAqXG4gKiAgICAgICBodHRwczovL2dpdGh1Yi5jb20vcGFwZXItZGVzaWduL3NoYWRlcnMgICAgICAgKlxuICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICovXG5cbmZ1bmN0aW9uIGdldEVtcHR5UGl4ZWwoKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY29uc29sZS53YXJuKFwiUGFwZXIgU2hhZGVyczogY2FuXFx1MjAxOXQgY3JlYXRlIGFuIGltYWdlIG9uIHRoZSBzZXJ2ZXJcIik7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgaW1nLnNyYyA9IGVtcHR5UGl4ZWw7XG4gIHJldHVybiBpbWc7XG59XG5jb25zdCBlbXB0eVBpeGVsID0gXCJkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUFBQUFDSDVCQUVLQUFFQUxBQUFBQUFCQUFFQUFBSUNUQUVBT3c9PVwiO1xuZXhwb3J0IHtcbiAgZ2V0RW1wdHlQaXhlbFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC1lbXB0eS1waXhlbC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/get-empty-pixel.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/get-shader-color-from-string.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/get-shader-color-from-string.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   getShaderColorFromString: () => (/* binding */ getShaderColorFromString)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nfunction getShaderColorFromString(colorString) {\n  if (Array.isArray(colorString)) {\n    if (colorString.length === 4) return colorString;\n    if (colorString.length === 3) return [...colorString, 1];\n    return fallbackColor;\n  }\n  if (typeof colorString !== \"string\") {\n    return fallbackColor;\n  }\n  let r, g, b, a = 1;\n  if (colorString.startsWith(\"#\")) {\n    [r, g, b, a] = hexToRgba(colorString);\n  } else if (colorString.startsWith(\"rgb\")) {\n    [r, g, b, a] = parseRgba(colorString);\n  } else if (colorString.startsWith(\"hsl\")) {\n    [r, g, b, a] = hslaToRgba(parseHsla(colorString));\n  } else {\n    console.error(\"Unsupported color format\", colorString);\n    return fallbackColor;\n  }\n  return [clamp(r, 0, 1), clamp(g, 0, 1), clamp(b, 0, 1), clamp(a, 0, 1)];\n}\nfunction hexToRgba(hex) {\n  hex = hex.replace(/^#/, \"\");\n  if (hex.length === 3) {\n    hex = hex.split(\"\").map((char) => char + char).join(\"\");\n  }\n  if (hex.length === 6) {\n    hex = hex + \"ff\";\n  }\n  const r = parseInt(hex.slice(0, 2), 16) / 255;\n  const g = parseInt(hex.slice(2, 4), 16) / 255;\n  const b = parseInt(hex.slice(4, 6), 16) / 255;\n  const a = parseInt(hex.slice(6, 8), 16) / 255;\n  return [r, g, b, a];\n}\nfunction parseRgba(rgba) {\n  const match = rgba.match(/^rgba?\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*([0-9.]+))?\\s*\\)$/i);\n  if (!match) return [0, 0, 0, 1];\n  return [\n    parseInt(match[1] ?? \"0\") / 255,\n    parseInt(match[2] ?? \"0\") / 255,\n    parseInt(match[3] ?? \"0\") / 255,\n    match[4] === void 0 ? 1 : parseFloat(match[4])\n  ];\n}\nfunction parseHsla(hsla) {\n  const match = hsla.match(/^hsla?\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*(?:,\\s*([0-9.]+))?\\s*\\)$/i);\n  if (!match) return [0, 0, 0, 1];\n  return [\n    parseInt(match[1] ?? \"0\"),\n    parseInt(match[2] ?? \"0\"),\n    parseInt(match[3] ?? \"0\"),\n    match[4] === void 0 ? 1 : parseFloat(match[4])\n  ];\n}\nfunction hslaToRgba(hsla) {\n  const [h, s, l, a] = hsla;\n  const hDecimal = h / 360;\n  const sDecimal = s / 100;\n  const lDecimal = l / 100;\n  let r, g, b;\n  if (s === 0) {\n    r = g = b = lDecimal;\n  } else {\n    const hue2rgb = (p2, q2, t) => {\n      if (t < 0) t += 1;\n      if (t > 1) t -= 1;\n      if (t < 1 / 6) return p2 + (q2 - p2) * 6 * t;\n      if (t < 1 / 2) return q2;\n      if (t < 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t) * 6;\n      return p2;\n    };\n    const q = lDecimal < 0.5 ? lDecimal * (1 + sDecimal) : lDecimal + sDecimal - lDecimal * sDecimal;\n    const p = 2 * lDecimal - q;\n    r = hue2rgb(p, q, hDecimal + 1 / 3);\n    g = hue2rgb(p, q, hDecimal);\n    b = hue2rgb(p, q, hDecimal - 1 / 3);\n  }\n  return [r, g, b, a];\n}\nconst clamp = (n, min, max) => Math.min(Math.max(n, min), max);\nconst fallbackColor = [0, 0, 0, 1];\n\n//# sourceMappingURL=get-shader-color-from-string.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3QvZ2V0LXNoYWRlci1jb2xvci1mcm9tLXN0cmluZy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0BwYXBlci1kZXNpZ24vc2hhZGVycy9kaXN0L2dldC1zaGFkZXItY29sb3ItZnJvbS1zdHJpbmcuanM/OTE2MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuICogICAgICAgICAgICAgICAgICAgIFBhcGVyIFNoYWRlcnMgICAgICAgICAgICAgICAgICAgICpcbiAqICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXBlci1kZXNpZ24vc2hhZGVycyAgICAgICAqXG4gKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKi9cblxuZnVuY3Rpb24gZ2V0U2hhZGVyQ29sb3JGcm9tU3RyaW5nKGNvbG9yU3RyaW5nKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNvbG9yU3RyaW5nKSkge1xuICAgIGlmIChjb2xvclN0cmluZy5sZW5ndGggPT09IDQpIHJldHVybiBjb2xvclN0cmluZztcbiAgICBpZiAoY29sb3JTdHJpbmcubGVuZ3RoID09PSAzKSByZXR1cm4gWy4uLmNvbG9yU3RyaW5nLCAxXTtcbiAgICByZXR1cm4gZmFsbGJhY2tDb2xvcjtcbiAgfVxuICBpZiAodHlwZW9mIGNvbG9yU3RyaW5nICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGZhbGxiYWNrQ29sb3I7XG4gIH1cbiAgbGV0IHIsIGcsIGIsIGEgPSAxO1xuICBpZiAoY29sb3JTdHJpbmcuc3RhcnRzV2l0aChcIiNcIikpIHtcbiAgICBbciwgZywgYiwgYV0gPSBoZXhUb1JnYmEoY29sb3JTdHJpbmcpO1xuICB9IGVsc2UgaWYgKGNvbG9yU3RyaW5nLnN0YXJ0c1dpdGgoXCJyZ2JcIikpIHtcbiAgICBbciwgZywgYiwgYV0gPSBwYXJzZVJnYmEoY29sb3JTdHJpbmcpO1xuICB9IGVsc2UgaWYgKGNvbG9yU3RyaW5nLnN0YXJ0c1dpdGgoXCJoc2xcIikpIHtcbiAgICBbciwgZywgYiwgYV0gPSBoc2xhVG9SZ2JhKHBhcnNlSHNsYShjb2xvclN0cmluZykpO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJVbnN1cHBvcnRlZCBjb2xvciBmb3JtYXRcIiwgY29sb3JTdHJpbmcpO1xuICAgIHJldHVybiBmYWxsYmFja0NvbG9yO1xuICB9XG4gIHJldHVybiBbY2xhbXAociwgMCwgMSksIGNsYW1wKGcsIDAsIDEpLCBjbGFtcChiLCAwLCAxKSwgY2xhbXAoYSwgMCwgMSldO1xufVxuZnVuY3Rpb24gaGV4VG9SZ2JhKGhleCkge1xuICBoZXggPSBoZXgucmVwbGFjZSgvXiMvLCBcIlwiKTtcbiAgaWYgKGhleC5sZW5ndGggPT09IDMpIHtcbiAgICBoZXggPSBoZXguc3BsaXQoXCJcIikubWFwKChjaGFyKSA9PiBjaGFyICsgY2hhcikuam9pbihcIlwiKTtcbiAgfVxuICBpZiAoaGV4Lmxlbmd0aCA9PT0gNikge1xuICAgIGhleCA9IGhleCArIFwiZmZcIjtcbiAgfVxuICBjb25zdCByID0gcGFyc2VJbnQoaGV4LnNsaWNlKDAsIDIpLCAxNikgLyAyNTU7XG4gIGNvbnN0IGcgPSBwYXJzZUludChoZXguc2xpY2UoMiwgNCksIDE2KSAvIDI1NTtcbiAgY29uc3QgYiA9IHBhcnNlSW50KGhleC5zbGljZSg0LCA2KSwgMTYpIC8gMjU1O1xuICBjb25zdCBhID0gcGFyc2VJbnQoaGV4LnNsaWNlKDYsIDgpLCAxNikgLyAyNTU7XG4gIHJldHVybiBbciwgZywgYiwgYV07XG59XG5mdW5jdGlvbiBwYXJzZVJnYmEocmdiYSkge1xuICBjb25zdCBtYXRjaCA9IHJnYmEubWF0Y2goL15yZ2JhP1xccypcXChcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKig/OixcXHMqKFswLTkuXSspKT9cXHMqXFwpJC9pKTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuIFswLCAwLCAwLCAxXTtcbiAgcmV0dXJuIFtcbiAgICBwYXJzZUludChtYXRjaFsxXSA/PyBcIjBcIikgLyAyNTUsXG4gICAgcGFyc2VJbnQobWF0Y2hbMl0gPz8gXCIwXCIpIC8gMjU1LFxuICAgIHBhcnNlSW50KG1hdGNoWzNdID8/IFwiMFwiKSAvIDI1NSxcbiAgICBtYXRjaFs0XSA9PT0gdm9pZCAwID8gMSA6IHBhcnNlRmxvYXQobWF0Y2hbNF0pXG4gIF07XG59XG5mdW5jdGlvbiBwYXJzZUhzbGEoaHNsYSkge1xuICBjb25zdCBtYXRjaCA9IGhzbGEubWF0Y2goL15oc2xhP1xccypcXChcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspJVxccyosXFxzKihcXGQrKSVcXHMqKD86LFxccyooWzAtOS5dKykpP1xccypcXCkkL2kpO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gWzAsIDAsIDAsIDFdO1xuICByZXR1cm4gW1xuICAgIHBhcnNlSW50KG1hdGNoWzFdID8/IFwiMFwiKSxcbiAgICBwYXJzZUludChtYXRjaFsyXSA/PyBcIjBcIiksXG4gICAgcGFyc2VJbnQobWF0Y2hbM10gPz8gXCIwXCIpLFxuICAgIG1hdGNoWzRdID09PSB2b2lkIDAgPyAxIDogcGFyc2VGbG9hdChtYXRjaFs0XSlcbiAgXTtcbn1cbmZ1bmN0aW9uIGhzbGFUb1JnYmEoaHNsYSkge1xuICBjb25zdCBbaCwgcywgbCwgYV0gPSBoc2xhO1xuICBjb25zdCBoRGVjaW1hbCA9IGggLyAzNjA7XG4gIGNvbnN0IHNEZWNpbWFsID0gcyAvIDEwMDtcbiAgY29uc3QgbERlY2ltYWwgPSBsIC8gMTAwO1xuICBsZXQgciwgZywgYjtcbiAgaWYgKHMgPT09IDApIHtcbiAgICByID0gZyA9IGIgPSBsRGVjaW1hbDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBodWUycmdiID0gKHAyLCBxMiwgdCkgPT4ge1xuICAgICAgaWYgKHQgPCAwKSB0ICs9IDE7XG4gICAgICBpZiAodCA+IDEpIHQgLT0gMTtcbiAgICAgIGlmICh0IDwgMSAvIDYpIHJldHVybiBwMiArIChxMiAtIHAyKSAqIDYgKiB0O1xuICAgICAgaWYgKHQgPCAxIC8gMikgcmV0dXJuIHEyO1xuICAgICAgaWYgKHQgPCAyIC8gMykgcmV0dXJuIHAyICsgKHEyIC0gcDIpICogKDIgLyAzIC0gdCkgKiA2O1xuICAgICAgcmV0dXJuIHAyO1xuICAgIH07XG4gICAgY29uc3QgcSA9IGxEZWNpbWFsIDwgMC41ID8gbERlY2ltYWwgKiAoMSArIHNEZWNpbWFsKSA6IGxEZWNpbWFsICsgc0RlY2ltYWwgLSBsRGVjaW1hbCAqIHNEZWNpbWFsO1xuICAgIGNvbnN0IHAgPSAyICogbERlY2ltYWwgLSBxO1xuICAgIHIgPSBodWUycmdiKHAsIHEsIGhEZWNpbWFsICsgMSAvIDMpO1xuICAgIGcgPSBodWUycmdiKHAsIHEsIGhEZWNpbWFsKTtcbiAgICBiID0gaHVlMnJnYihwLCBxLCBoRGVjaW1hbCAtIDEgLyAzKTtcbiAgfVxuICByZXR1cm4gW3IsIGcsIGIsIGFdO1xufVxuY29uc3QgY2xhbXAgPSAobiwgbWluLCBtYXgpID0+IE1hdGgubWluKE1hdGgubWF4KG4sIG1pbiksIG1heCk7XG5jb25zdCBmYWxsYmFja0NvbG9yID0gWzAsIDAsIDAsIDFdO1xuZXhwb3J0IHtcbiAgY2xhbXAsXG4gIGdldFNoYWRlckNvbG9yRnJvbVN0cmluZ1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC1zaGFkZXItY29sb3ItZnJvbS1zdHJpbmcuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/get-shader-color-from-string.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/shader-mount.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/shader-mount.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShaderMount: () => (/* binding */ ShaderMount),\n/* harmony export */   isPaperShaderElement: () => (/* binding */ isPaperShaderElement)\n/* harmony export */ });\n/* harmony import */ var _vertex_shader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vertex-shader.js */ \"(ssr)/./node_modules/@paper-design/shaders/dist/vertex-shader.js\");\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\nconst DEFAULT_MAX_PIXEL_COUNT = 1920 * 1080 * 4;\nclass ShaderMount {\n  parentElement;\n  canvasElement;\n  gl;\n  program = null;\n  uniformLocations = {};\n  /** The fragment shader that we are using */\n  fragmentShader;\n  /** Stores the RAF for the render loop */\n  rafId = null;\n  /** Time of the last rendered frame */\n  lastRenderTime = 0;\n  /** Total time that we have played any animation, passed as a uniform to the shader for time-based VFX */\n  currentFrame = 0;\n  /** The speed that we progress through animation time (multiplies by delta time every update). Allows negatives to play in reverse. If set to 0, rAF will stop entirely so static shaders have no recurring performance costs */\n  speed = 0;\n  /** Actual speed used that accounts for document visibility (we pause the shader if the tab is hidden) */\n  currentSpeed = 0;\n  /** Uniforms that are provided by the user for the specific shader being mounted (not including uniforms that this Mount adds, like time and resolution) */\n  providedUniforms;\n  /** Names of the uniforms that should have mipmaps generated for them */\n  mipmaps = [];\n  /** Just a sanity check to make sure frames don't run after we're disposed */\n  hasBeenDisposed = false;\n  /** If the resolution of the canvas has changed since the last render */\n  resolutionChanged = true;\n  /** Store textures that are provided by the user */\n  textures = /* @__PURE__ */ new Map();\n  minPixelRatio;\n  maxPixelCount;\n  isSafari = isSafari();\n  uniformCache = {};\n  textureUnitMap = /* @__PURE__ */ new Map();\n  constructor(parentElement, fragmentShader, uniforms, webGlContextAttributes, speed = 0, frame = 0, minPixelRatio = 2, maxPixelCount = DEFAULT_MAX_PIXEL_COUNT, mipmaps = []) {\n    if (parentElement instanceof HTMLElement) {\n      this.parentElement = parentElement;\n    } else {\n      throw new Error(\"Paper Shaders: parent element must be an HTMLElement\");\n    }\n    if (!document.querySelector(\"style[data-paper-shader]\")) {\n      const styleElement = document.createElement(\"style\");\n      styleElement.innerHTML = defaultStyle;\n      styleElement.setAttribute(\"data-paper-shader\", \"\");\n      document.head.prepend(styleElement);\n    }\n    const canvasElement = document.createElement(\"canvas\");\n    this.canvasElement = canvasElement;\n    this.parentElement.prepend(canvasElement);\n    this.fragmentShader = fragmentShader;\n    this.providedUniforms = uniforms;\n    this.mipmaps = mipmaps;\n    this.currentFrame = frame;\n    this.minPixelRatio = minPixelRatio;\n    this.maxPixelCount = maxPixelCount;\n    const gl = canvasElement.getContext(\"webgl2\", webGlContextAttributes);\n    if (!gl) {\n      throw new Error(\"Paper Shaders: WebGL is not supported in this browser\");\n    }\n    this.gl = gl;\n    this.initProgram();\n    this.setupPositionAttribute();\n    this.setupUniforms();\n    this.setUniformValues(this.providedUniforms);\n    this.setupResizeObserver();\n    visualViewport?.addEventListener(\"resize\", this.handleVisualViewportChange);\n    this.setSpeed(speed);\n    this.parentElement.setAttribute(\"data-paper-shader\", \"\");\n    this.parentElement.paperShaderMount = this;\n    document.addEventListener(\"visibilitychange\", this.handleDocumentVisibilityChange);\n  }\n  initProgram = () => {\n    const program = createProgram(this.gl, _vertex_shader_js__WEBPACK_IMPORTED_MODULE_0__.vertexShaderSource, this.fragmentShader);\n    if (!program) return;\n    this.program = program;\n  };\n  setupPositionAttribute = () => {\n    const positionAttributeLocation = this.gl.getAttribLocation(this.program, \"a_position\");\n    const positionBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, positionBuffer);\n    const positions = [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1];\n    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(positions), this.gl.STATIC_DRAW);\n    this.gl.enableVertexAttribArray(positionAttributeLocation);\n    this.gl.vertexAttribPointer(positionAttributeLocation, 2, this.gl.FLOAT, false, 0, 0);\n  };\n  setupUniforms = () => {\n    const uniformLocations = {\n      u_time: this.gl.getUniformLocation(this.program, \"u_time\"),\n      u_pixelRatio: this.gl.getUniformLocation(this.program, \"u_pixelRatio\"),\n      u_resolution: this.gl.getUniformLocation(this.program, \"u_resolution\")\n    };\n    Object.entries(this.providedUniforms).forEach(([key, value]) => {\n      uniformLocations[key] = this.gl.getUniformLocation(this.program, key);\n      if (value instanceof HTMLImageElement) {\n        const aspectRatioUniformName = `${key}AspectRatio`;\n        uniformLocations[aspectRatioUniformName] = this.gl.getUniformLocation(this.program, aspectRatioUniformName);\n      }\n    });\n    this.uniformLocations = uniformLocations;\n  };\n  /**\n   * The scale that we should render at.\n   * - Used to target 2x rendering even on 1x screens for better antialiasing\n   * - Prevents the virtual resolution from going beyond the maximum resolution\n   * - Accounts for the page zoom level so we render in physical device pixels rather than CSS pixels\n   */\n  renderScale = 1;\n  parentWidth = 0;\n  parentHeight = 0;\n  parentDevicePixelWidth = 0;\n  parentDevicePixelHeight = 0;\n  devicePixelsSupported = false;\n  resizeObserver = null;\n  setupResizeObserver = () => {\n    this.resizeObserver = new ResizeObserver(([entry]) => {\n      if (entry?.borderBoxSize[0]) {\n        const physicalPixelSize = entry.devicePixelContentBoxSize?.[0];\n        if (physicalPixelSize !== void 0) {\n          this.devicePixelsSupported = true;\n          this.parentDevicePixelWidth = physicalPixelSize.inlineSize;\n          this.parentDevicePixelHeight = physicalPixelSize.blockSize;\n        }\n        this.parentWidth = entry.borderBoxSize[0].inlineSize;\n        this.parentHeight = entry.borderBoxSize[0].blockSize;\n      }\n      this.handleResize();\n    });\n    this.resizeObserver.observe(this.parentElement);\n  };\n  // Visual viewport resize handler, mainly used to react to browser zoom changes.\n  // Resize observer by itself does not react to pinch zoom, and although it usually\n  // reacts to classic browser zoom, it's not guaranteed in edge cases.\n  // Since timing between visual viewport changes and resize observer is complex\n  // and because we'd like to know the device pixel sizes of elements, we just restart\n  // the observer to get a guaranteed fresh callback regardless if it would have triggered or not.\n  handleVisualViewportChange = () => {\n    this.resizeObserver?.disconnect();\n    this.setupResizeObserver();\n  };\n  /** Resize handler for when the container div changes size or the max pixel count changes and we want to resize our canvas to match */\n  handleResize = () => {\n    let targetPixelWidth = 0;\n    let targetPixelHeight = 0;\n    const dpr = Math.max(1, window.devicePixelRatio);\n    const pinchZoom = visualViewport?.scale ?? 1;\n    if (this.devicePixelsSupported) {\n      const scaleToMeetMinPixelRatio = Math.max(1, this.minPixelRatio / dpr);\n      targetPixelWidth = this.parentDevicePixelWidth * scaleToMeetMinPixelRatio * pinchZoom;\n      targetPixelHeight = this.parentDevicePixelHeight * scaleToMeetMinPixelRatio * pinchZoom;\n    } else {\n      let targetRenderScale = Math.max(dpr, this.minPixelRatio) * pinchZoom;\n      if (this.isSafari) {\n        const zoomLevel = bestGuessBrowserZoom();\n        targetRenderScale *= Math.max(1, zoomLevel);\n      }\n      targetPixelWidth = Math.round(this.parentWidth) * targetRenderScale;\n      targetPixelHeight = Math.round(this.parentHeight) * targetRenderScale;\n    }\n    const maxPixelCountHeadroom = Math.sqrt(this.maxPixelCount) / Math.sqrt(targetPixelWidth * targetPixelHeight);\n    const scaleToMeetMaxPixelCount = Math.min(1, maxPixelCountHeadroom);\n    const newWidth = Math.round(targetPixelWidth * scaleToMeetMaxPixelCount);\n    const newHeight = Math.round(targetPixelHeight * scaleToMeetMaxPixelCount);\n    const newRenderScale = newWidth / Math.round(this.parentWidth);\n    if (this.canvasElement.width !== newWidth || this.canvasElement.height !== newHeight || this.renderScale !== newRenderScale) {\n      this.renderScale = newRenderScale;\n      this.canvasElement.width = newWidth;\n      this.canvasElement.height = newHeight;\n      this.resolutionChanged = true;\n      this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);\n      this.render(performance.now());\n    }\n  };\n  render = (currentTime) => {\n    if (this.hasBeenDisposed) return;\n    if (this.program === null) {\n      console.warn(\"Tried to render before program or gl was initialized\");\n      return;\n    }\n    const dt = currentTime - this.lastRenderTime;\n    this.lastRenderTime = currentTime;\n    if (this.currentSpeed !== 0) {\n      this.currentFrame += dt * this.currentSpeed;\n    }\n    this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n    this.gl.useProgram(this.program);\n    this.gl.uniform1f(this.uniformLocations.u_time, this.currentFrame * 1e-3);\n    if (this.resolutionChanged) {\n      this.gl.uniform2f(this.uniformLocations.u_resolution, this.gl.canvas.width, this.gl.canvas.height);\n      this.gl.uniform1f(this.uniformLocations.u_pixelRatio, this.renderScale);\n      this.resolutionChanged = false;\n    }\n    this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);\n    if (this.currentSpeed !== 0) {\n      this.requestRender();\n    } else {\n      this.rafId = null;\n    }\n  };\n  requestRender = () => {\n    if (this.rafId !== null) {\n      cancelAnimationFrame(this.rafId);\n    }\n    this.rafId = requestAnimationFrame(this.render);\n  };\n  /** Creates a texture from an image and sets it into a uniform value */\n  setTextureUniform = (uniformName, image) => {\n    if (!image.complete || image.naturalWidth === 0) {\n      throw new Error(`Paper Shaders: image for uniform ${uniformName} must be fully loaded`);\n    }\n    const existingTexture = this.textures.get(uniformName);\n    if (existingTexture) {\n      this.gl.deleteTexture(existingTexture);\n    }\n    if (!this.textureUnitMap.has(uniformName)) {\n      this.textureUnitMap.set(uniformName, this.textureUnitMap.size);\n    }\n    const textureUnit = this.textureUnitMap.get(uniformName);\n    this.gl.activeTexture(this.gl.TEXTURE0 + textureUnit);\n    const texture = this.gl.createTexture();\n    this.gl.bindTexture(this.gl.TEXTURE_2D, texture);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);\n    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, image);\n    if (this.mipmaps.includes(uniformName)) {\n      this.gl.generateMipmap(this.gl.TEXTURE_2D);\n      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR_MIPMAP_LINEAR);\n    }\n    const error = this.gl.getError();\n    if (error !== this.gl.NO_ERROR || texture === null) {\n      console.error(\"Paper Shaders: WebGL error when uploading texture:\", error);\n      return;\n    }\n    this.textures.set(uniformName, texture);\n    const location = this.uniformLocations[uniformName];\n    if (location) {\n      this.gl.uniform1i(location, textureUnit);\n      const aspectRatioUniformName = `${uniformName}AspectRatio`;\n      const aspectRatioLocation = this.uniformLocations[aspectRatioUniformName];\n      if (aspectRatioLocation) {\n        const aspectRatio = image.naturalWidth / image.naturalHeight;\n        this.gl.uniform1f(aspectRatioLocation, aspectRatio);\n      }\n    }\n  };\n  /** Utility: recursive equality test for all the uniforms */\n  areUniformValuesEqual = (a, b) => {\n    if (a === b) return true;\n    if (Array.isArray(a) && Array.isArray(b) && a.length === b.length) {\n      return a.every((val, i) => this.areUniformValuesEqual(val, b[i]));\n    }\n    return false;\n  };\n  /** Sets the provided uniform values into the WebGL program, can be a partial list of uniforms that have changed */\n  setUniformValues = (updatedUniforms) => {\n    this.gl.useProgram(this.program);\n    Object.entries(updatedUniforms).forEach(([key, value]) => {\n      let cacheValue = value;\n      if (value instanceof HTMLImageElement) {\n        cacheValue = `${value.src.slice(0, 200)}|${value.naturalWidth}x${value.naturalHeight}`;\n      }\n      if (this.areUniformValuesEqual(this.uniformCache[key], cacheValue)) return;\n      this.uniformCache[key] = cacheValue;\n      const location = this.uniformLocations[key];\n      if (!location) {\n        console.warn(`Uniform location for ${key} not found`);\n        return;\n      }\n      if (value instanceof HTMLImageElement) {\n        this.setTextureUniform(key, value);\n      } else if (Array.isArray(value)) {\n        let flatArray = null;\n        let valueLength = null;\n        if (value[0] !== void 0 && Array.isArray(value[0])) {\n          const firstChildLength = value[0].length;\n          if (value.every((arr) => arr.length === firstChildLength)) {\n            flatArray = value.flat();\n            valueLength = firstChildLength;\n          } else {\n            console.warn(`All child arrays must be the same length for ${key}`);\n            return;\n          }\n        } else {\n          flatArray = value;\n          valueLength = flatArray.length;\n        }\n        switch (valueLength) {\n          case 2:\n            this.gl.uniform2fv(location, flatArray);\n            break;\n          case 3:\n            this.gl.uniform3fv(location, flatArray);\n            break;\n          case 4:\n            this.gl.uniform4fv(location, flatArray);\n            break;\n          case 9:\n            this.gl.uniformMatrix3fv(location, false, flatArray);\n            break;\n          case 16:\n            this.gl.uniformMatrix4fv(location, false, flatArray);\n            break;\n          default:\n            console.warn(`Unsupported uniform array length: ${valueLength}`);\n        }\n      } else if (typeof value === \"number\") {\n        this.gl.uniform1f(location, value);\n      } else if (typeof value === \"boolean\") {\n        this.gl.uniform1i(location, value ? 1 : 0);\n      } else {\n        console.warn(`Unsupported uniform type for ${key}: ${typeof value}`);\n      }\n    });\n  };\n  /** Gets the current total animation time from 0ms */\n  getCurrentFrame = () => {\n    return this.currentFrame;\n  };\n  /** Set a frame to get a deterministic result, frames are literally just milliseconds from zero since the animation started */\n  setFrame = (newFrame) => {\n    this.currentFrame = newFrame;\n    this.lastRenderTime = performance.now();\n    this.render(performance.now());\n  };\n  /** Set an animation speed (or 0 to stop animation) */\n  setSpeed = (newSpeed = 1) => {\n    this.speed = newSpeed;\n    this.setCurrentSpeed(document.hidden ? 0 : newSpeed);\n  };\n  setCurrentSpeed = (newSpeed) => {\n    this.currentSpeed = newSpeed;\n    if (this.rafId === null && newSpeed !== 0) {\n      this.lastRenderTime = performance.now();\n      this.rafId = requestAnimationFrame(this.render);\n    }\n    if (this.rafId !== null && newSpeed === 0) {\n      cancelAnimationFrame(this.rafId);\n      this.rafId = null;\n    }\n  };\n  /** Set the maximum pixel count for the shader, this will limit the number of pixels that will be rendered */\n  setMaxPixelCount = (newMaxPixelCount = DEFAULT_MAX_PIXEL_COUNT) => {\n    this.maxPixelCount = newMaxPixelCount;\n    this.handleResize();\n  };\n  /** Set the minimum pixel ratio for the shader */\n  setMinPixelRatio = (newMinPixelRatio = 2) => {\n    this.minPixelRatio = newMinPixelRatio;\n    this.handleResize();\n  };\n  /** Update the uniforms that are provided by the outside shader, can be a partial set with only the uniforms that have changed */\n  setUniforms = (newUniforms) => {\n    this.setUniformValues(newUniforms);\n    this.providedUniforms = { ...this.providedUniforms, ...newUniforms };\n    this.render(performance.now());\n  };\n  handleDocumentVisibilityChange = () => {\n    this.setCurrentSpeed(document.hidden ? 0 : this.speed);\n  };\n  /** Dispose of the shader mount, cleaning up all of the WebGL resources */\n  dispose = () => {\n    this.hasBeenDisposed = true;\n    if (this.rafId !== null) {\n      cancelAnimationFrame(this.rafId);\n      this.rafId = null;\n    }\n    if (this.gl && this.program) {\n      this.textures.forEach((texture) => {\n        this.gl.deleteTexture(texture);\n      });\n      this.textures.clear();\n      this.gl.deleteProgram(this.program);\n      this.program = null;\n      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\n      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\n      this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, null);\n      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);\n      this.gl.getError();\n    }\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n      this.resizeObserver = null;\n    }\n    visualViewport?.removeEventListener(\"resize\", this.handleVisualViewportChange);\n    document.removeEventListener(\"visibilitychange\", this.handleDocumentVisibilityChange);\n    this.uniformLocations = {};\n    this.canvasElement.remove();\n    delete this.parentElement.paperShaderMount;\n  };\n}\nfunction createShader(gl, type, source) {\n  const shader = gl.createShader(type);\n  if (!shader) return null;\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    console.error(\"An error occurred compiling the shaders: \" + gl.getShaderInfoLog(shader));\n    gl.deleteShader(shader);\n    return null;\n  }\n  return shader;\n}\nfunction createProgram(gl, vertexShaderSource2, fragmentShaderSource) {\n  const format = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT);\n  const precision = format ? format.precision : null;\n  if (precision && precision < 23) {\n    vertexShaderSource2 = vertexShaderSource2.replace(/precision\\s+(lowp|mediump)\\s+float;/g, \"precision highp float;\");\n    fragmentShaderSource = fragmentShaderSource.replace(/precision\\s+(lowp|mediump)\\s+float/g, \"precision highp float\").replace(/\\b(uniform|varying|attribute)\\s+(lowp|mediump)\\s+(\\w+)/g, \"$1 highp $3\");\n  }\n  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource2);\n  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n  if (!vertexShader || !fragmentShader) return null;\n  const program = gl.createProgram();\n  if (!program) return null;\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    console.error(\"Unable to initialize the shader program: \" + gl.getProgramInfoLog(program));\n    gl.deleteProgram(program);\n    gl.deleteShader(vertexShader);\n    gl.deleteShader(fragmentShader);\n    return null;\n  }\n  gl.detachShader(program, vertexShader);\n  gl.detachShader(program, fragmentShader);\n  gl.deleteShader(vertexShader);\n  gl.deleteShader(fragmentShader);\n  return program;\n}\nconst defaultStyle = `@layer paper-shaders {\n  :where([data-paper-shader]) {\n    isolation: isolate;\n    position: relative;\n\n    & canvas {\n      contain: strict;\n      display: block;\n      position: absolute;\n      inset: 0;\n      z-index: -1;\n      width: 100%;\n      height: 100%;\n      border-radius: inherit;\n      corner-shape: inherit;\n    }\n  }\n}`;\nfunction isPaperShaderElement(element) {\n  return \"paperShaderMount\" in element;\n}\nfunction isSafari() {\n  const ua = navigator.userAgent.toLowerCase();\n  return ua.includes(\"safari\") && !ua.includes(\"chrome\") && !ua.includes(\"android\");\n}\nfunction bestGuessBrowserZoom() {\n  const viewportScale = visualViewport?.scale ?? 1;\n  const viewportWidth = visualViewport?.width ?? window.innerWidth;\n  const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;\n  const innerWidth = viewportScale * viewportWidth + scrollbarWidth;\n  const ratio = outerWidth / innerWidth;\n  const zoomPercentageRounded = Math.round(100 * ratio);\n  if (zoomPercentageRounded % 5 === 0) {\n    return zoomPercentageRounded / 100;\n  }\n  if (zoomPercentageRounded === 33) {\n    return 1 / 3;\n  }\n  if (zoomPercentageRounded === 67) {\n    return 2 / 3;\n  }\n  if (zoomPercentageRounded === 133) {\n    return 4 / 3;\n  }\n  return ratio;\n}\n\n//# sourceMappingURL=shader-mount.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVyLW1vdW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUV3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxpRUFBa0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLElBQUk7QUFDOUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxhQUFhO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxZQUFZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0IsR0FBRyxtQkFBbUIsR0FBRyxvQkFBb0I7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxLQUFLO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLHlFQUF5RSxJQUFJO0FBQzdFO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxZQUFZO0FBQzFFO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSLHFEQUFxRCxJQUFJLElBQUksYUFBYTtBQUMxRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLDJCQUEyQjtBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVyLW1vdW50LmpzPzg0MTciXSwic291cmNlc0NvbnRlbnQiOlsiLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqICAgICAgICAgICAgICAgICAgICBQYXBlciBTaGFkZXJzICAgICAgICAgICAgICAgICAgICAqXG4gKiAgICAgICBodHRwczovL2dpdGh1Yi5jb20vcGFwZXItZGVzaWduL3NoYWRlcnMgICAgICAgKlxuICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICovXG5cbmltcG9ydCB7IHZlcnRleFNoYWRlclNvdXJjZSB9IGZyb20gXCIuL3ZlcnRleC1zaGFkZXIuanNcIjtcbmNvbnN0IERFRkFVTFRfTUFYX1BJWEVMX0NPVU5UID0gMTkyMCAqIDEwODAgKiA0O1xuY2xhc3MgU2hhZGVyTW91bnQge1xuICBwYXJlbnRFbGVtZW50O1xuICBjYW52YXNFbGVtZW50O1xuICBnbDtcbiAgcHJvZ3JhbSA9IG51bGw7XG4gIHVuaWZvcm1Mb2NhdGlvbnMgPSB7fTtcbiAgLyoqIFRoZSBmcmFnbWVudCBzaGFkZXIgdGhhdCB3ZSBhcmUgdXNpbmcgKi9cbiAgZnJhZ21lbnRTaGFkZXI7XG4gIC8qKiBTdG9yZXMgdGhlIFJBRiBmb3IgdGhlIHJlbmRlciBsb29wICovXG4gIHJhZklkID0gbnVsbDtcbiAgLyoqIFRpbWUgb2YgdGhlIGxhc3QgcmVuZGVyZWQgZnJhbWUgKi9cbiAgbGFzdFJlbmRlclRpbWUgPSAwO1xuICAvKiogVG90YWwgdGltZSB0aGF0IHdlIGhhdmUgcGxheWVkIGFueSBhbmltYXRpb24sIHBhc3NlZCBhcyBhIHVuaWZvcm0gdG8gdGhlIHNoYWRlciBmb3IgdGltZS1iYXNlZCBWRlggKi9cbiAgY3VycmVudEZyYW1lID0gMDtcbiAgLyoqIFRoZSBzcGVlZCB0aGF0IHdlIHByb2dyZXNzIHRocm91Z2ggYW5pbWF0aW9uIHRpbWUgKG11bHRpcGxpZXMgYnkgZGVsdGEgdGltZSBldmVyeSB1cGRhdGUpLiBBbGxvd3MgbmVnYXRpdmVzIHRvIHBsYXkgaW4gcmV2ZXJzZS4gSWYgc2V0IHRvIDAsIHJBRiB3aWxsIHN0b3AgZW50aXJlbHkgc28gc3RhdGljIHNoYWRlcnMgaGF2ZSBubyByZWN1cnJpbmcgcGVyZm9ybWFuY2UgY29zdHMgKi9cbiAgc3BlZWQgPSAwO1xuICAvKiogQWN0dWFsIHNwZWVkIHVzZWQgdGhhdCBhY2NvdW50cyBmb3IgZG9jdW1lbnQgdmlzaWJpbGl0eSAod2UgcGF1c2UgdGhlIHNoYWRlciBpZiB0aGUgdGFiIGlzIGhpZGRlbikgKi9cbiAgY3VycmVudFNwZWVkID0gMDtcbiAgLyoqIFVuaWZvcm1zIHRoYXQgYXJlIHByb3ZpZGVkIGJ5IHRoZSB1c2VyIGZvciB0aGUgc3BlY2lmaWMgc2hhZGVyIGJlaW5nIG1vdW50ZWQgKG5vdCBpbmNsdWRpbmcgdW5pZm9ybXMgdGhhdCB0aGlzIE1vdW50IGFkZHMsIGxpa2UgdGltZSBhbmQgcmVzb2x1dGlvbikgKi9cbiAgcHJvdmlkZWRVbmlmb3JtcztcbiAgLyoqIE5hbWVzIG9mIHRoZSB1bmlmb3JtcyB0aGF0IHNob3VsZCBoYXZlIG1pcG1hcHMgZ2VuZXJhdGVkIGZvciB0aGVtICovXG4gIG1pcG1hcHMgPSBbXTtcbiAgLyoqIEp1c3QgYSBzYW5pdHkgY2hlY2sgdG8gbWFrZSBzdXJlIGZyYW1lcyBkb24ndCBydW4gYWZ0ZXIgd2UncmUgZGlzcG9zZWQgKi9cbiAgaGFzQmVlbkRpc3Bvc2VkID0gZmFsc2U7XG4gIC8qKiBJZiB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgY2FudmFzIGhhcyBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IHJlbmRlciAqL1xuICByZXNvbHV0aW9uQ2hhbmdlZCA9IHRydWU7XG4gIC8qKiBTdG9yZSB0ZXh0dXJlcyB0aGF0IGFyZSBwcm92aWRlZCBieSB0aGUgdXNlciAqL1xuICB0ZXh0dXJlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIG1pblBpeGVsUmF0aW87XG4gIG1heFBpeGVsQ291bnQ7XG4gIGlzU2FmYXJpID0gaXNTYWZhcmkoKTtcbiAgdW5pZm9ybUNhY2hlID0ge307XG4gIHRleHR1cmVVbml0TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3RydWN0b3IocGFyZW50RWxlbWVudCwgZnJhZ21lbnRTaGFkZXIsIHVuaWZvcm1zLCB3ZWJHbENvbnRleHRBdHRyaWJ1dGVzLCBzcGVlZCA9IDAsIGZyYW1lID0gMCwgbWluUGl4ZWxSYXRpbyA9IDIsIG1heFBpeGVsQ291bnQgPSBERUZBVUxUX01BWF9QSVhFTF9DT1VOVCwgbWlwbWFwcyA9IFtdKSB7XG4gICAgaWYgKHBhcmVudEVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgdGhpcy5wYXJlbnRFbGVtZW50ID0gcGFyZW50RWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFwZXIgU2hhZGVyczogcGFyZW50IGVsZW1lbnQgbXVzdCBiZSBhbiBIVE1MRWxlbWVudFwiKTtcbiAgICB9XG4gICAgaWYgKCFkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwic3R5bGVbZGF0YS1wYXBlci1zaGFkZXJdXCIpKSB7XG4gICAgICBjb25zdCBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICBzdHlsZUVsZW1lbnQuaW5uZXJIVE1MID0gZGVmYXVsdFN0eWxlO1xuICAgICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtcGFwZXItc2hhZGVyXCIsIFwiXCIpO1xuICAgICAgZG9jdW1lbnQuaGVhZC5wcmVwZW5kKHN0eWxlRWxlbWVudCk7XG4gICAgfVxuICAgIGNvbnN0IGNhbnZhc0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIHRoaXMuY2FudmFzRWxlbWVudCA9IGNhbnZhc0VsZW1lbnQ7XG4gICAgdGhpcy5wYXJlbnRFbGVtZW50LnByZXBlbmQoY2FudmFzRWxlbWVudCk7XG4gICAgdGhpcy5mcmFnbWVudFNoYWRlciA9IGZyYWdtZW50U2hhZGVyO1xuICAgIHRoaXMucHJvdmlkZWRVbmlmb3JtcyA9IHVuaWZvcm1zO1xuICAgIHRoaXMubWlwbWFwcyA9IG1pcG1hcHM7XG4gICAgdGhpcy5jdXJyZW50RnJhbWUgPSBmcmFtZTtcbiAgICB0aGlzLm1pblBpeGVsUmF0aW8gPSBtaW5QaXhlbFJhdGlvO1xuICAgIHRoaXMubWF4UGl4ZWxDb3VudCA9IG1heFBpeGVsQ291bnQ7XG4gICAgY29uc3QgZ2wgPSBjYW52YXNFbGVtZW50LmdldENvbnRleHQoXCJ3ZWJnbDJcIiwgd2ViR2xDb250ZXh0QXR0cmlidXRlcyk7XG4gICAgaWYgKCFnbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFwZXIgU2hhZGVyczogV2ViR0wgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXJcIik7XG4gICAgfVxuICAgIHRoaXMuZ2wgPSBnbDtcbiAgICB0aGlzLmluaXRQcm9ncmFtKCk7XG4gICAgdGhpcy5zZXR1cFBvc2l0aW9uQXR0cmlidXRlKCk7XG4gICAgdGhpcy5zZXR1cFVuaWZvcm1zKCk7XG4gICAgdGhpcy5zZXRVbmlmb3JtVmFsdWVzKHRoaXMucHJvdmlkZWRVbmlmb3Jtcyk7XG4gICAgdGhpcy5zZXR1cFJlc2l6ZU9ic2VydmVyKCk7XG4gICAgdmlzdWFsVmlld3BvcnQ/LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5oYW5kbGVWaXN1YWxWaWV3cG9ydENoYW5nZSk7XG4gICAgdGhpcy5zZXRTcGVlZChzcGVlZCk7XG4gICAgdGhpcy5wYXJlbnRFbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtcGFwZXItc2hhZGVyXCIsIFwiXCIpO1xuICAgIHRoaXMucGFyZW50RWxlbWVudC5wYXBlclNoYWRlck1vdW50ID0gdGhpcztcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCB0aGlzLmhhbmRsZURvY3VtZW50VmlzaWJpbGl0eUNoYW5nZSk7XG4gIH1cbiAgaW5pdFByb2dyYW0gPSAoKSA9PiB7XG4gICAgY29uc3QgcHJvZ3JhbSA9IGNyZWF0ZVByb2dyYW0odGhpcy5nbCwgdmVydGV4U2hhZGVyU291cmNlLCB0aGlzLmZyYWdtZW50U2hhZGVyKTtcbiAgICBpZiAoIXByb2dyYW0pIHJldHVybjtcbiAgICB0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xuICB9O1xuICBzZXR1cFBvc2l0aW9uQXR0cmlidXRlID0gKCkgPT4ge1xuICAgIGNvbnN0IHBvc2l0aW9uQXR0cmlidXRlTG9jYXRpb24gPSB0aGlzLmdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgXCJhX3Bvc2l0aW9uXCIpO1xuICAgIGNvbnN0IHBvc2l0aW9uQnVmZmVyID0gdGhpcy5nbC5jcmVhdGVCdWZmZXIoKTtcbiAgICB0aGlzLmdsLmJpbmRCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsIHBvc2l0aW9uQnVmZmVyKTtcbiAgICBjb25zdCBwb3NpdGlvbnMgPSBbLTEsIC0xLCAxLCAtMSwgLTEsIDEsIC0xLCAxLCAxLCAtMSwgMSwgMV07XG4gICAgdGhpcy5nbC5idWZmZXJEYXRhKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KHBvc2l0aW9ucyksIHRoaXMuZ2wuU1RBVElDX0RSQVcpO1xuICAgIHRoaXMuZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb25BdHRyaWJ1dGVMb2NhdGlvbik7XG4gICAgdGhpcy5nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBvc2l0aW9uQXR0cmlidXRlTG9jYXRpb24sIDIsIHRoaXMuZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgfTtcbiAgc2V0dXBVbmlmb3JtcyA9ICgpID0+IHtcbiAgICBjb25zdCB1bmlmb3JtTG9jYXRpb25zID0ge1xuICAgICAgdV90aW1lOiB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIFwidV90aW1lXCIpLFxuICAgICAgdV9waXhlbFJhdGlvOiB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIFwidV9waXhlbFJhdGlvXCIpLFxuICAgICAgdV9yZXNvbHV0aW9uOiB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIFwidV9yZXNvbHV0aW9uXCIpXG4gICAgfTtcbiAgICBPYmplY3QuZW50cmllcyh0aGlzLnByb3ZpZGVkVW5pZm9ybXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgdW5pZm9ybUxvY2F0aW9uc1trZXldID0gdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBrZXkpO1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkge1xuICAgICAgICBjb25zdCBhc3BlY3RSYXRpb1VuaWZvcm1OYW1lID0gYCR7a2V5fUFzcGVjdFJhdGlvYDtcbiAgICAgICAgdW5pZm9ybUxvY2F0aW9uc1thc3BlY3RSYXRpb1VuaWZvcm1OYW1lXSA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgYXNwZWN0UmF0aW9Vbmlmb3JtTmFtZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy51bmlmb3JtTG9jYXRpb25zID0gdW5pZm9ybUxvY2F0aW9ucztcbiAgfTtcbiAgLyoqXG4gICAqIFRoZSBzY2FsZSB0aGF0IHdlIHNob3VsZCByZW5kZXIgYXQuXG4gICAqIC0gVXNlZCB0byB0YXJnZXQgMnggcmVuZGVyaW5nIGV2ZW4gb24gMXggc2NyZWVucyBmb3IgYmV0dGVyIGFudGlhbGlhc2luZ1xuICAgKiAtIFByZXZlbnRzIHRoZSB2aXJ0dWFsIHJlc29sdXRpb24gZnJvbSBnb2luZyBiZXlvbmQgdGhlIG1heGltdW0gcmVzb2x1dGlvblxuICAgKiAtIEFjY291bnRzIGZvciB0aGUgcGFnZSB6b29tIGxldmVsIHNvIHdlIHJlbmRlciBpbiBwaHlzaWNhbCBkZXZpY2UgcGl4ZWxzIHJhdGhlciB0aGFuIENTUyBwaXhlbHNcbiAgICovXG4gIHJlbmRlclNjYWxlID0gMTtcbiAgcGFyZW50V2lkdGggPSAwO1xuICBwYXJlbnRIZWlnaHQgPSAwO1xuICBwYXJlbnREZXZpY2VQaXhlbFdpZHRoID0gMDtcbiAgcGFyZW50RGV2aWNlUGl4ZWxIZWlnaHQgPSAwO1xuICBkZXZpY2VQaXhlbHNTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgcmVzaXplT2JzZXJ2ZXIgPSBudWxsO1xuICBzZXR1cFJlc2l6ZU9ic2VydmVyID0gKCkgPT4ge1xuICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKFtlbnRyeV0pID0+IHtcbiAgICAgIGlmIChlbnRyeT8uYm9yZGVyQm94U2l6ZVswXSkge1xuICAgICAgICBjb25zdCBwaHlzaWNhbFBpeGVsU2l6ZSA9IGVudHJ5LmRldmljZVBpeGVsQ29udGVudEJveFNpemU/LlswXTtcbiAgICAgICAgaWYgKHBoeXNpY2FsUGl4ZWxTaXplICE9PSB2b2lkIDApIHtcbiAgICAgICAgICB0aGlzLmRldmljZVBpeGVsc1N1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5wYXJlbnREZXZpY2VQaXhlbFdpZHRoID0gcGh5c2ljYWxQaXhlbFNpemUuaW5saW5lU2l6ZTtcbiAgICAgICAgICB0aGlzLnBhcmVudERldmljZVBpeGVsSGVpZ2h0ID0gcGh5c2ljYWxQaXhlbFNpemUuYmxvY2tTaXplO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFyZW50V2lkdGggPSBlbnRyeS5ib3JkZXJCb3hTaXplWzBdLmlubGluZVNpemU7XG4gICAgICAgIHRoaXMucGFyZW50SGVpZ2h0ID0gZW50cnkuYm9yZGVyQm94U2l6ZVswXS5ibG9ja1NpemU7XG4gICAgICB9XG4gICAgICB0aGlzLmhhbmRsZVJlc2l6ZSgpO1xuICAgIH0pO1xuICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLnBhcmVudEVsZW1lbnQpO1xuICB9O1xuICAvLyBWaXN1YWwgdmlld3BvcnQgcmVzaXplIGhhbmRsZXIsIG1haW5seSB1c2VkIHRvIHJlYWN0IHRvIGJyb3dzZXIgem9vbSBjaGFuZ2VzLlxuICAvLyBSZXNpemUgb2JzZXJ2ZXIgYnkgaXRzZWxmIGRvZXMgbm90IHJlYWN0IHRvIHBpbmNoIHpvb20sIGFuZCBhbHRob3VnaCBpdCB1c3VhbGx5XG4gIC8vIHJlYWN0cyB0byBjbGFzc2ljIGJyb3dzZXIgem9vbSwgaXQncyBub3QgZ3VhcmFudGVlZCBpbiBlZGdlIGNhc2VzLlxuICAvLyBTaW5jZSB0aW1pbmcgYmV0d2VlbiB2aXN1YWwgdmlld3BvcnQgY2hhbmdlcyBhbmQgcmVzaXplIG9ic2VydmVyIGlzIGNvbXBsZXhcbiAgLy8gYW5kIGJlY2F1c2Ugd2UnZCBsaWtlIHRvIGtub3cgdGhlIGRldmljZSBwaXhlbCBzaXplcyBvZiBlbGVtZW50cywgd2UganVzdCByZXN0YXJ0XG4gIC8vIHRoZSBvYnNlcnZlciB0byBnZXQgYSBndWFyYW50ZWVkIGZyZXNoIGNhbGxiYWNrIHJlZ2FyZGxlc3MgaWYgaXQgd291bGQgaGF2ZSB0cmlnZ2VyZWQgb3Igbm90LlxuICBoYW5kbGVWaXN1YWxWaWV3cG9ydENoYW5nZSA9ICgpID0+IHtcbiAgICB0aGlzLnJlc2l6ZU9ic2VydmVyPy5kaXNjb25uZWN0KCk7XG4gICAgdGhpcy5zZXR1cFJlc2l6ZU9ic2VydmVyKCk7XG4gIH07XG4gIC8qKiBSZXNpemUgaGFuZGxlciBmb3Igd2hlbiB0aGUgY29udGFpbmVyIGRpdiBjaGFuZ2VzIHNpemUgb3IgdGhlIG1heCBwaXhlbCBjb3VudCBjaGFuZ2VzIGFuZCB3ZSB3YW50IHRvIHJlc2l6ZSBvdXIgY2FudmFzIHRvIG1hdGNoICovXG4gIGhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcbiAgICBsZXQgdGFyZ2V0UGl4ZWxXaWR0aCA9IDA7XG4gICAgbGV0IHRhcmdldFBpeGVsSGVpZ2h0ID0gMDtcbiAgICBjb25zdCBkcHIgPSBNYXRoLm1heCgxLCB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgY29uc3QgcGluY2hab29tID0gdmlzdWFsVmlld3BvcnQ/LnNjYWxlID8/IDE7XG4gICAgaWYgKHRoaXMuZGV2aWNlUGl4ZWxzU3VwcG9ydGVkKSB7XG4gICAgICBjb25zdCBzY2FsZVRvTWVldE1pblBpeGVsUmF0aW8gPSBNYXRoLm1heCgxLCB0aGlzLm1pblBpeGVsUmF0aW8gLyBkcHIpO1xuICAgICAgdGFyZ2V0UGl4ZWxXaWR0aCA9IHRoaXMucGFyZW50RGV2aWNlUGl4ZWxXaWR0aCAqIHNjYWxlVG9NZWV0TWluUGl4ZWxSYXRpbyAqIHBpbmNoWm9vbTtcbiAgICAgIHRhcmdldFBpeGVsSGVpZ2h0ID0gdGhpcy5wYXJlbnREZXZpY2VQaXhlbEhlaWdodCAqIHNjYWxlVG9NZWV0TWluUGl4ZWxSYXRpbyAqIHBpbmNoWm9vbTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHRhcmdldFJlbmRlclNjYWxlID0gTWF0aC5tYXgoZHByLCB0aGlzLm1pblBpeGVsUmF0aW8pICogcGluY2hab29tO1xuICAgICAgaWYgKHRoaXMuaXNTYWZhcmkpIHtcbiAgICAgICAgY29uc3Qgem9vbUxldmVsID0gYmVzdEd1ZXNzQnJvd3Nlclpvb20oKTtcbiAgICAgICAgdGFyZ2V0UmVuZGVyU2NhbGUgKj0gTWF0aC5tYXgoMSwgem9vbUxldmVsKTtcbiAgICAgIH1cbiAgICAgIHRhcmdldFBpeGVsV2lkdGggPSBNYXRoLnJvdW5kKHRoaXMucGFyZW50V2lkdGgpICogdGFyZ2V0UmVuZGVyU2NhbGU7XG4gICAgICB0YXJnZXRQaXhlbEhlaWdodCA9IE1hdGgucm91bmQodGhpcy5wYXJlbnRIZWlnaHQpICogdGFyZ2V0UmVuZGVyU2NhbGU7XG4gICAgfVxuICAgIGNvbnN0IG1heFBpeGVsQ291bnRIZWFkcm9vbSA9IE1hdGguc3FydCh0aGlzLm1heFBpeGVsQ291bnQpIC8gTWF0aC5zcXJ0KHRhcmdldFBpeGVsV2lkdGggKiB0YXJnZXRQaXhlbEhlaWdodCk7XG4gICAgY29uc3Qgc2NhbGVUb01lZXRNYXhQaXhlbENvdW50ID0gTWF0aC5taW4oMSwgbWF4UGl4ZWxDb3VudEhlYWRyb29tKTtcbiAgICBjb25zdCBuZXdXaWR0aCA9IE1hdGgucm91bmQodGFyZ2V0UGl4ZWxXaWR0aCAqIHNjYWxlVG9NZWV0TWF4UGl4ZWxDb3VudCk7XG4gICAgY29uc3QgbmV3SGVpZ2h0ID0gTWF0aC5yb3VuZCh0YXJnZXRQaXhlbEhlaWdodCAqIHNjYWxlVG9NZWV0TWF4UGl4ZWxDb3VudCk7XG4gICAgY29uc3QgbmV3UmVuZGVyU2NhbGUgPSBuZXdXaWR0aCAvIE1hdGgucm91bmQodGhpcy5wYXJlbnRXaWR0aCk7XG4gICAgaWYgKHRoaXMuY2FudmFzRWxlbWVudC53aWR0aCAhPT0gbmV3V2lkdGggfHwgdGhpcy5jYW52YXNFbGVtZW50LmhlaWdodCAhPT0gbmV3SGVpZ2h0IHx8IHRoaXMucmVuZGVyU2NhbGUgIT09IG5ld1JlbmRlclNjYWxlKSB7XG4gICAgICB0aGlzLnJlbmRlclNjYWxlID0gbmV3UmVuZGVyU2NhbGU7XG4gICAgICB0aGlzLmNhbnZhc0VsZW1lbnQud2lkdGggPSBuZXdXaWR0aDtcbiAgICAgIHRoaXMuY2FudmFzRWxlbWVudC5oZWlnaHQgPSBuZXdIZWlnaHQ7XG4gICAgICB0aGlzLnJlc29sdXRpb25DaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMuZ2wudmlld3BvcnQoMCwgMCwgdGhpcy5nbC5jYW52YXMud2lkdGgsIHRoaXMuZ2wuY2FudmFzLmhlaWdodCk7XG4gICAgICB0aGlzLnJlbmRlcihwZXJmb3JtYW5jZS5ub3coKSk7XG4gICAgfVxuICB9O1xuICByZW5kZXIgPSAoY3VycmVudFRpbWUpID0+IHtcbiAgICBpZiAodGhpcy5oYXNCZWVuRGlzcG9zZWQpIHJldHVybjtcbiAgICBpZiAodGhpcy5wcm9ncmFtID09PSBudWxsKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJUcmllZCB0byByZW5kZXIgYmVmb3JlIHByb2dyYW0gb3IgZ2wgd2FzIGluaXRpYWxpemVkXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkdCA9IGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0UmVuZGVyVGltZTtcbiAgICB0aGlzLmxhc3RSZW5kZXJUaW1lID0gY3VycmVudFRpbWU7XG4gICAgaWYgKHRoaXMuY3VycmVudFNwZWVkICE9PSAwKSB7XG4gICAgICB0aGlzLmN1cnJlbnRGcmFtZSArPSBkdCAqIHRoaXMuY3VycmVudFNwZWVkO1xuICAgIH1cbiAgICB0aGlzLmdsLmNsZWFyKHRoaXMuZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgdGhpcy5nbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XG4gICAgdGhpcy5nbC51bmlmb3JtMWYodGhpcy51bmlmb3JtTG9jYXRpb25zLnVfdGltZSwgdGhpcy5jdXJyZW50RnJhbWUgKiAxZS0zKTtcbiAgICBpZiAodGhpcy5yZXNvbHV0aW9uQ2hhbmdlZCkge1xuICAgICAgdGhpcy5nbC51bmlmb3JtMmYodGhpcy51bmlmb3JtTG9jYXRpb25zLnVfcmVzb2x1dGlvbiwgdGhpcy5nbC5jYW52YXMud2lkdGgsIHRoaXMuZ2wuY2FudmFzLmhlaWdodCk7XG4gICAgICB0aGlzLmdsLnVuaWZvcm0xZih0aGlzLnVuaWZvcm1Mb2NhdGlvbnMudV9waXhlbFJhdGlvLCB0aGlzLnJlbmRlclNjYWxlKTtcbiAgICAgIHRoaXMucmVzb2x1dGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5nbC5kcmF3QXJyYXlzKHRoaXMuZ2wuVFJJQU5HTEVTLCAwLCA2KTtcbiAgICBpZiAodGhpcy5jdXJyZW50U3BlZWQgIT09IDApIHtcbiAgICAgIHRoaXMucmVxdWVzdFJlbmRlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJhZklkID0gbnVsbDtcbiAgICB9XG4gIH07XG4gIHJlcXVlc3RSZW5kZXIgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMucmFmSWQgIT09IG51bGwpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmFmSWQpO1xuICAgIH1cbiAgICB0aGlzLnJhZklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMucmVuZGVyKTtcbiAgfTtcbiAgLyoqIENyZWF0ZXMgYSB0ZXh0dXJlIGZyb20gYW4gaW1hZ2UgYW5kIHNldHMgaXQgaW50byBhIHVuaWZvcm0gdmFsdWUgKi9cbiAgc2V0VGV4dHVyZVVuaWZvcm0gPSAodW5pZm9ybU5hbWUsIGltYWdlKSA9PiB7XG4gICAgaWYgKCFpbWFnZS5jb21wbGV0ZSB8fCBpbWFnZS5uYXR1cmFsV2lkdGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUGFwZXIgU2hhZGVyczogaW1hZ2UgZm9yIHVuaWZvcm0gJHt1bmlmb3JtTmFtZX0gbXVzdCBiZSBmdWxseSBsb2FkZWRgKTtcbiAgICB9XG4gICAgY29uc3QgZXhpc3RpbmdUZXh0dXJlID0gdGhpcy50ZXh0dXJlcy5nZXQodW5pZm9ybU5hbWUpO1xuICAgIGlmIChleGlzdGluZ1RleHR1cmUpIHtcbiAgICAgIHRoaXMuZ2wuZGVsZXRlVGV4dHVyZShleGlzdGluZ1RleHR1cmUpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMudGV4dHVyZVVuaXRNYXAuaGFzKHVuaWZvcm1OYW1lKSkge1xuICAgICAgdGhpcy50ZXh0dXJlVW5pdE1hcC5zZXQodW5pZm9ybU5hbWUsIHRoaXMudGV4dHVyZVVuaXRNYXAuc2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IHRleHR1cmVVbml0ID0gdGhpcy50ZXh0dXJlVW5pdE1hcC5nZXQodW5pZm9ybU5hbWUpO1xuICAgIHRoaXMuZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkUwICsgdGV4dHVyZVVuaXQpO1xuICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLmdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICB0aGlzLmdsLmJpbmRUZXh0dXJlKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgdGhpcy5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGhpcy5nbC5URVhUVVJFX1dSQVBfUywgdGhpcy5nbC5DTEFNUF9UT19FREdFKTtcbiAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLmdsLlRFWFRVUkVfV1JBUF9ULCB0aGlzLmdsLkNMQU1QX1RPX0VER0UpO1xuICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMuZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB0aGlzLmdsLkxJTkVBUik7XG4gICAgdGhpcy5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGhpcy5nbC5URVhUVVJFX01BR19GSUxURVIsIHRoaXMuZ2wuTElORUFSKTtcbiAgICB0aGlzLmdsLnRleEltYWdlMkQodGhpcy5nbC5URVhUVVJFXzJELCAwLCB0aGlzLmdsLlJHQkEsIHRoaXMuZ2wuUkdCQSwgdGhpcy5nbC5VTlNJR05FRF9CWVRFLCBpbWFnZSk7XG4gICAgaWYgKHRoaXMubWlwbWFwcy5pbmNsdWRlcyh1bmlmb3JtTmFtZSkpIHtcbiAgICAgIHRoaXMuZ2wuZ2VuZXJhdGVNaXBtYXAodGhpcy5nbC5URVhUVVJFXzJEKTtcbiAgICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMuZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB0aGlzLmdsLkxJTkVBUl9NSVBNQVBfTElORUFSKTtcbiAgICB9XG4gICAgY29uc3QgZXJyb3IgPSB0aGlzLmdsLmdldEVycm9yKCk7XG4gICAgaWYgKGVycm9yICE9PSB0aGlzLmdsLk5PX0VSUk9SIHx8IHRleHR1cmUgPT09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJQYXBlciBTaGFkZXJzOiBXZWJHTCBlcnJvciB3aGVuIHVwbG9hZGluZyB0ZXh0dXJlOlwiLCBlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudGV4dHVyZXMuc2V0KHVuaWZvcm1OYW1lLCB0ZXh0dXJlKTtcbiAgICBjb25zdCBsb2NhdGlvbiA9IHRoaXMudW5pZm9ybUxvY2F0aW9uc1t1bmlmb3JtTmFtZV07XG4gICAgaWYgKGxvY2F0aW9uKSB7XG4gICAgICB0aGlzLmdsLnVuaWZvcm0xaShsb2NhdGlvbiwgdGV4dHVyZVVuaXQpO1xuICAgICAgY29uc3QgYXNwZWN0UmF0aW9Vbmlmb3JtTmFtZSA9IGAke3VuaWZvcm1OYW1lfUFzcGVjdFJhdGlvYDtcbiAgICAgIGNvbnN0IGFzcGVjdFJhdGlvTG9jYXRpb24gPSB0aGlzLnVuaWZvcm1Mb2NhdGlvbnNbYXNwZWN0UmF0aW9Vbmlmb3JtTmFtZV07XG4gICAgICBpZiAoYXNwZWN0UmF0aW9Mb2NhdGlvbikge1xuICAgICAgICBjb25zdCBhc3BlY3RSYXRpbyA9IGltYWdlLm5hdHVyYWxXaWR0aCAvIGltYWdlLm5hdHVyYWxIZWlnaHQ7XG4gICAgICAgIHRoaXMuZ2wudW5pZm9ybTFmKGFzcGVjdFJhdGlvTG9jYXRpb24sIGFzcGVjdFJhdGlvKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qKiBVdGlsaXR5OiByZWN1cnNpdmUgZXF1YWxpdHkgdGVzdCBmb3IgYWxsIHRoZSB1bmlmb3JtcyAqL1xuICBhcmVVbmlmb3JtVmFsdWVzRXF1YWwgPSAoYSwgYikgPT4ge1xuICAgIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSAmJiBBcnJheS5pc0FycmF5KGIpICYmIGEubGVuZ3RoID09PSBiLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGEuZXZlcnkoKHZhbCwgaSkgPT4gdGhpcy5hcmVVbmlmb3JtVmFsdWVzRXF1YWwodmFsLCBiW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgLyoqIFNldHMgdGhlIHByb3ZpZGVkIHVuaWZvcm0gdmFsdWVzIGludG8gdGhlIFdlYkdMIHByb2dyYW0sIGNhbiBiZSBhIHBhcnRpYWwgbGlzdCBvZiB1bmlmb3JtcyB0aGF0IGhhdmUgY2hhbmdlZCAqL1xuICBzZXRVbmlmb3JtVmFsdWVzID0gKHVwZGF0ZWRVbmlmb3JtcykgPT4ge1xuICAgIHRoaXMuZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xuICAgIE9iamVjdC5lbnRyaWVzKHVwZGF0ZWRVbmlmb3JtcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBsZXQgY2FjaGVWYWx1ZSA9IHZhbHVlO1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkge1xuICAgICAgICBjYWNoZVZhbHVlID0gYCR7dmFsdWUuc3JjLnNsaWNlKDAsIDIwMCl9fCR7dmFsdWUubmF0dXJhbFdpZHRofXgke3ZhbHVlLm5hdHVyYWxIZWlnaHR9YDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmFyZVVuaWZvcm1WYWx1ZXNFcXVhbCh0aGlzLnVuaWZvcm1DYWNoZVtrZXldLCBjYWNoZVZhbHVlKSkgcmV0dXJuO1xuICAgICAgdGhpcy51bmlmb3JtQ2FjaGVba2V5XSA9IGNhY2hlVmFsdWU7XG4gICAgICBjb25zdCBsb2NhdGlvbiA9IHRoaXMudW5pZm9ybUxvY2F0aW9uc1trZXldO1xuICAgICAgaWYgKCFsb2NhdGlvbikge1xuICAgICAgICBjb25zb2xlLndhcm4oYFVuaWZvcm0gbG9jYXRpb24gZm9yICR7a2V5fSBub3QgZm91bmRgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkge1xuICAgICAgICB0aGlzLnNldFRleHR1cmVVbmlmb3JtKGtleSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBsZXQgZmxhdEFycmF5ID0gbnVsbDtcbiAgICAgICAgbGV0IHZhbHVlTGVuZ3RoID0gbnVsbDtcbiAgICAgICAgaWYgKHZhbHVlWzBdICE9PSB2b2lkIDAgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZVswXSkpIHtcbiAgICAgICAgICBjb25zdCBmaXJzdENoaWxkTGVuZ3RoID0gdmFsdWVbMF0ubGVuZ3RoO1xuICAgICAgICAgIGlmICh2YWx1ZS5ldmVyeSgoYXJyKSA9PiBhcnIubGVuZ3RoID09PSBmaXJzdENoaWxkTGVuZ3RoKSkge1xuICAgICAgICAgICAgZmxhdEFycmF5ID0gdmFsdWUuZmxhdCgpO1xuICAgICAgICAgICAgdmFsdWVMZW5ndGggPSBmaXJzdENoaWxkTGVuZ3RoO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYEFsbCBjaGlsZCBhcnJheXMgbXVzdCBiZSB0aGUgc2FtZSBsZW5ndGggZm9yICR7a2V5fWApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmbGF0QXJyYXkgPSB2YWx1ZTtcbiAgICAgICAgICB2YWx1ZUxlbmd0aCA9IGZsYXRBcnJheS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh2YWx1ZUxlbmd0aCkge1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHRoaXMuZ2wudW5pZm9ybTJmdihsb2NhdGlvbiwgZmxhdEFycmF5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHRoaXMuZ2wudW5pZm9ybTNmdihsb2NhdGlvbiwgZmxhdEFycmF5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHRoaXMuZ2wudW5pZm9ybTRmdihsb2NhdGlvbiwgZmxhdEFycmF5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHRoaXMuZ2wudW5pZm9ybU1hdHJpeDNmdihsb2NhdGlvbiwgZmFsc2UsIGZsYXRBcnJheSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgdGhpcy5nbC51bmlmb3JtTWF0cml4NGZ2KGxvY2F0aW9uLCBmYWxzZSwgZmxhdEFycmF5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFVuc3VwcG9ydGVkIHVuaWZvcm0gYXJyYXkgbGVuZ3RoOiAke3ZhbHVlTGVuZ3RofWApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICB0aGlzLmdsLnVuaWZvcm0xZihsb2NhdGlvbiwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIHRoaXMuZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCB2YWx1ZSA/IDEgOiAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgVW5zdXBwb3J0ZWQgdW5pZm9ybSB0eXBlIGZvciAke2tleX06ICR7dHlwZW9mIHZhbHVlfWApO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICAvKiogR2V0cyB0aGUgY3VycmVudCB0b3RhbCBhbmltYXRpb24gdGltZSBmcm9tIDBtcyAqL1xuICBnZXRDdXJyZW50RnJhbWUgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudEZyYW1lO1xuICB9O1xuICAvKiogU2V0IGEgZnJhbWUgdG8gZ2V0IGEgZGV0ZXJtaW5pc3RpYyByZXN1bHQsIGZyYW1lcyBhcmUgbGl0ZXJhbGx5IGp1c3QgbWlsbGlzZWNvbmRzIGZyb20gemVybyBzaW5jZSB0aGUgYW5pbWF0aW9uIHN0YXJ0ZWQgKi9cbiAgc2V0RnJhbWUgPSAobmV3RnJhbWUpID0+IHtcbiAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IG5ld0ZyYW1lO1xuICAgIHRoaXMubGFzdFJlbmRlclRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB0aGlzLnJlbmRlcihwZXJmb3JtYW5jZS5ub3coKSk7XG4gIH07XG4gIC8qKiBTZXQgYW4gYW5pbWF0aW9uIHNwZWVkIChvciAwIHRvIHN0b3AgYW5pbWF0aW9uKSAqL1xuICBzZXRTcGVlZCA9IChuZXdTcGVlZCA9IDEpID0+IHtcbiAgICB0aGlzLnNwZWVkID0gbmV3U3BlZWQ7XG4gICAgdGhpcy5zZXRDdXJyZW50U3BlZWQoZG9jdW1lbnQuaGlkZGVuID8gMCA6IG5ld1NwZWVkKTtcbiAgfTtcbiAgc2V0Q3VycmVudFNwZWVkID0gKG5ld1NwZWVkKSA9PiB7XG4gICAgdGhpcy5jdXJyZW50U3BlZWQgPSBuZXdTcGVlZDtcbiAgICBpZiAodGhpcy5yYWZJZCA9PT0gbnVsbCAmJiBuZXdTcGVlZCAhPT0gMCkge1xuICAgICAgdGhpcy5sYXN0UmVuZGVyVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgdGhpcy5yYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnJlbmRlcik7XG4gICAgfVxuICAgIGlmICh0aGlzLnJhZklkICE9PSBudWxsICYmIG5ld1NwZWVkID09PSAwKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJhZklkKTtcbiAgICAgIHRoaXMucmFmSWQgPSBudWxsO1xuICAgIH1cbiAgfTtcbiAgLyoqIFNldCB0aGUgbWF4aW11bSBwaXhlbCBjb3VudCBmb3IgdGhlIHNoYWRlciwgdGhpcyB3aWxsIGxpbWl0IHRoZSBudW1iZXIgb2YgcGl4ZWxzIHRoYXQgd2lsbCBiZSByZW5kZXJlZCAqL1xuICBzZXRNYXhQaXhlbENvdW50ID0gKG5ld01heFBpeGVsQ291bnQgPSBERUZBVUxUX01BWF9QSVhFTF9DT1VOVCkgPT4ge1xuICAgIHRoaXMubWF4UGl4ZWxDb3VudCA9IG5ld01heFBpeGVsQ291bnQ7XG4gICAgdGhpcy5oYW5kbGVSZXNpemUoKTtcbiAgfTtcbiAgLyoqIFNldCB0aGUgbWluaW11bSBwaXhlbCByYXRpbyBmb3IgdGhlIHNoYWRlciAqL1xuICBzZXRNaW5QaXhlbFJhdGlvID0gKG5ld01pblBpeGVsUmF0aW8gPSAyKSA9PiB7XG4gICAgdGhpcy5taW5QaXhlbFJhdGlvID0gbmV3TWluUGl4ZWxSYXRpbztcbiAgICB0aGlzLmhhbmRsZVJlc2l6ZSgpO1xuICB9O1xuICAvKiogVXBkYXRlIHRoZSB1bmlmb3JtcyB0aGF0IGFyZSBwcm92aWRlZCBieSB0aGUgb3V0c2lkZSBzaGFkZXIsIGNhbiBiZSBhIHBhcnRpYWwgc2V0IHdpdGggb25seSB0aGUgdW5pZm9ybXMgdGhhdCBoYXZlIGNoYW5nZWQgKi9cbiAgc2V0VW5pZm9ybXMgPSAobmV3VW5pZm9ybXMpID0+IHtcbiAgICB0aGlzLnNldFVuaWZvcm1WYWx1ZXMobmV3VW5pZm9ybXMpO1xuICAgIHRoaXMucHJvdmlkZWRVbmlmb3JtcyA9IHsgLi4udGhpcy5wcm92aWRlZFVuaWZvcm1zLCAuLi5uZXdVbmlmb3JtcyB9O1xuICAgIHRoaXMucmVuZGVyKHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgfTtcbiAgaGFuZGxlRG9jdW1lbnRWaXNpYmlsaXR5Q2hhbmdlID0gKCkgPT4ge1xuICAgIHRoaXMuc2V0Q3VycmVudFNwZWVkKGRvY3VtZW50LmhpZGRlbiA/IDAgOiB0aGlzLnNwZWVkKTtcbiAgfTtcbiAgLyoqIERpc3Bvc2Ugb2YgdGhlIHNoYWRlciBtb3VudCwgY2xlYW5pbmcgdXAgYWxsIG9mIHRoZSBXZWJHTCByZXNvdXJjZXMgKi9cbiAgZGlzcG9zZSA9ICgpID0+IHtcbiAgICB0aGlzLmhhc0JlZW5EaXNwb3NlZCA9IHRydWU7XG4gICAgaWYgKHRoaXMucmFmSWQgIT09IG51bGwpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmFmSWQpO1xuICAgICAgdGhpcy5yYWZJZCA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmdsICYmIHRoaXMucHJvZ3JhbSkge1xuICAgICAgdGhpcy50ZXh0dXJlcy5mb3JFYWNoKCh0ZXh0dXJlKSA9PiB7XG4gICAgICAgIHRoaXMuZ2wuZGVsZXRlVGV4dHVyZSh0ZXh0dXJlKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy50ZXh0dXJlcy5jbGVhcigpO1xuICAgICAgdGhpcy5nbC5kZWxldGVQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XG4gICAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xuICAgICAgdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLCBudWxsKTtcbiAgICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLmdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBudWxsKTtcbiAgICAgIHRoaXMuZ2wuYmluZFJlbmRlcmJ1ZmZlcih0aGlzLmdsLlJFTkRFUkJVRkZFUiwgbnVsbCk7XG4gICAgICB0aGlzLmdsLmJpbmRGcmFtZWJ1ZmZlcih0aGlzLmdsLkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgICAgIHRoaXMuZ2wuZ2V0RXJyb3IoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IG51bGw7XG4gICAgfVxuICAgIHZpc3VhbFZpZXdwb3J0Py5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMuaGFuZGxlVmlzdWFsVmlld3BvcnRDaGFuZ2UpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIHRoaXMuaGFuZGxlRG9jdW1lbnRWaXNpYmlsaXR5Q2hhbmdlKTtcbiAgICB0aGlzLnVuaWZvcm1Mb2NhdGlvbnMgPSB7fTtcbiAgICB0aGlzLmNhbnZhc0VsZW1lbnQucmVtb3ZlKCk7XG4gICAgZGVsZXRlIHRoaXMucGFyZW50RWxlbWVudC5wYXBlclNoYWRlck1vdW50O1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU2hhZGVyKGdsLCB0eXBlLCBzb3VyY2UpIHtcbiAgY29uc3Qgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHR5cGUpO1xuICBpZiAoIXNoYWRlcikgcmV0dXJuIG51bGw7XG4gIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNvdXJjZSk7XG4gIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcbiAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiQW4gZXJyb3Igb2NjdXJyZWQgY29tcGlsaW5nIHRoZSBzaGFkZXJzOiBcIiArIGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKSk7XG4gICAgZ2wuZGVsZXRlU2hhZGVyKHNoYWRlcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHNoYWRlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVByb2dyYW0oZ2wsIHZlcnRleFNoYWRlclNvdXJjZTIsIGZyYWdtZW50U2hhZGVyU291cmNlKSB7XG4gIGNvbnN0IGZvcm1hdCA9IGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5GUkFHTUVOVF9TSEFERVIsIGdsLk1FRElVTV9GTE9BVCk7XG4gIGNvbnN0IHByZWNpc2lvbiA9IGZvcm1hdCA/IGZvcm1hdC5wcmVjaXNpb24gOiBudWxsO1xuICBpZiAocHJlY2lzaW9uICYmIHByZWNpc2lvbiA8IDIzKSB7XG4gICAgdmVydGV4U2hhZGVyU291cmNlMiA9IHZlcnRleFNoYWRlclNvdXJjZTIucmVwbGFjZSgvcHJlY2lzaW9uXFxzKyhsb3dwfG1lZGl1bXApXFxzK2Zsb2F0Oy9nLCBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcIik7XG4gICAgZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBmcmFnbWVudFNoYWRlclNvdXJjZS5yZXBsYWNlKC9wcmVjaXNpb25cXHMrKGxvd3B8bWVkaXVtcClcXHMrZmxvYXQvZywgXCJwcmVjaXNpb24gaGlnaHAgZmxvYXRcIikucmVwbGFjZSgvXFxiKHVuaWZvcm18dmFyeWluZ3xhdHRyaWJ1dGUpXFxzKyhsb3dwfG1lZGl1bXApXFxzKyhcXHcrKS9nLCBcIiQxIGhpZ2hwICQzXCIpO1xuICB9XG4gIGNvbnN0IHZlcnRleFNoYWRlciA9IGNyZWF0ZVNoYWRlcihnbCwgZ2wuVkVSVEVYX1NIQURFUiwgdmVydGV4U2hhZGVyU291cmNlMik7XG4gIGNvbnN0IGZyYWdtZW50U2hhZGVyID0gY3JlYXRlU2hhZGVyKGdsLCBnbC5GUkFHTUVOVF9TSEFERVIsIGZyYWdtZW50U2hhZGVyU291cmNlKTtcbiAgaWYgKCF2ZXJ0ZXhTaGFkZXIgfHwgIWZyYWdtZW50U2hhZGVyKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgaWYgKCFwcm9ncmFtKSByZXR1cm4gbnVsbDtcbiAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcik7XG4gIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XG4gIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuICBpZiAoIWdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKSB7XG4gICAgY29uc29sZS5lcnJvcihcIlVuYWJsZSB0byBpbml0aWFsaXplIHRoZSBzaGFkZXIgcHJvZ3JhbTogXCIgKyBnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKSk7XG4gICAgZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICBnbC5kZWxldGVTaGFkZXIodmVydGV4U2hhZGVyKTtcbiAgICBnbC5kZWxldGVTaGFkZXIoZnJhZ21lbnRTaGFkZXIpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdsLmRldGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpO1xuICBnbC5kZXRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xuICBnbC5kZWxldGVTaGFkZXIodmVydGV4U2hhZGVyKTtcbiAgZ2wuZGVsZXRlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcbiAgcmV0dXJuIHByb2dyYW07XG59XG5jb25zdCBkZWZhdWx0U3R5bGUgPSBgQGxheWVyIHBhcGVyLXNoYWRlcnMge1xuICA6d2hlcmUoW2RhdGEtcGFwZXItc2hhZGVyXSkge1xuICAgIGlzb2xhdGlvbjogaXNvbGF0ZTtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG5cbiAgICAmIGNhbnZhcyB7XG4gICAgICBjb250YWluOiBzdHJpY3Q7XG4gICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIGluc2V0OiAwO1xuICAgICAgei1pbmRleDogLTE7XG4gICAgICB3aWR0aDogMTAwJTtcbiAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgIGJvcmRlci1yYWRpdXM6IGluaGVyaXQ7XG4gICAgICBjb3JuZXItc2hhcGU6IGluaGVyaXQ7XG4gICAgfVxuICB9XG59YDtcbmZ1bmN0aW9uIGlzUGFwZXJTaGFkZXJFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuIFwicGFwZXJTaGFkZXJNb3VudFwiIGluIGVsZW1lbnQ7XG59XG5mdW5jdGlvbiBpc1NhZmFyaSgpIHtcbiAgY29uc3QgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiB1YS5pbmNsdWRlcyhcInNhZmFyaVwiKSAmJiAhdWEuaW5jbHVkZXMoXCJjaHJvbWVcIikgJiYgIXVhLmluY2x1ZGVzKFwiYW5kcm9pZFwiKTtcbn1cbmZ1bmN0aW9uIGJlc3RHdWVzc0Jyb3dzZXJab29tKCkge1xuICBjb25zdCB2aWV3cG9ydFNjYWxlID0gdmlzdWFsVmlld3BvcnQ/LnNjYWxlID8/IDE7XG4gIGNvbnN0IHZpZXdwb3J0V2lkdGggPSB2aXN1YWxWaWV3cG9ydD8ud2lkdGggPz8gd2luZG93LmlubmVyV2lkdGg7XG4gIGNvbnN0IHNjcm9sbGJhcldpZHRoID0gd2luZG93LmlubmVyV2lkdGggLSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gIGNvbnN0IGlubmVyV2lkdGggPSB2aWV3cG9ydFNjYWxlICogdmlld3BvcnRXaWR0aCArIHNjcm9sbGJhcldpZHRoO1xuICBjb25zdCByYXRpbyA9IG91dGVyV2lkdGggLyBpbm5lcldpZHRoO1xuICBjb25zdCB6b29tUGVyY2VudGFnZVJvdW5kZWQgPSBNYXRoLnJvdW5kKDEwMCAqIHJhdGlvKTtcbiAgaWYgKHpvb21QZXJjZW50YWdlUm91bmRlZCAlIDUgPT09IDApIHtcbiAgICByZXR1cm4gem9vbVBlcmNlbnRhZ2VSb3VuZGVkIC8gMTAwO1xuICB9XG4gIGlmICh6b29tUGVyY2VudGFnZVJvdW5kZWQgPT09IDMzKSB7XG4gICAgcmV0dXJuIDEgLyAzO1xuICB9XG4gIGlmICh6b29tUGVyY2VudGFnZVJvdW5kZWQgPT09IDY3KSB7XG4gICAgcmV0dXJuIDIgLyAzO1xuICB9XG4gIGlmICh6b29tUGVyY2VudGFnZVJvdW5kZWQgPT09IDEzMykge1xuICAgIHJldHVybiA0IC8gMztcbiAgfVxuICByZXR1cm4gcmF0aW87XG59XG5leHBvcnQge1xuICBTaGFkZXJNb3VudCxcbiAgaXNQYXBlclNoYWRlckVsZW1lbnRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGFkZXItbW91bnQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/shader-mount.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/shader-sizing.js":
/*!******************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/shader-sizing.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShaderFitOptions: () => (/* binding */ ShaderFitOptions),\n/* harmony export */   defaultObjectSizing: () => (/* binding */ defaultObjectSizing),\n/* harmony export */   defaultPatternSizing: () => (/* binding */ defaultPatternSizing),\n/* harmony export */   drawSizingHelpers: () => (/* binding */ drawSizingHelpers),\n/* harmony export */   sizingDebugVariablesDeclaration: () => (/* binding */ sizingDebugVariablesDeclaration),\n/* harmony export */   sizingUV: () => (/* binding */ sizingUV),\n/* harmony export */   sizingUniformsDeclaration: () => (/* binding */ sizingUniformsDeclaration),\n/* harmony export */   sizingVariablesDeclaration: () => (/* binding */ sizingVariablesDeclaration)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nconst sizingVariablesDeclaration = `\nin vec2 v_objectUV;\nin vec2 v_responsiveUV;\nin vec2 v_responsiveBoxGivenSize;\nin vec2 v_patternUV;\nin vec2 v_imageUV;`;\nconst sizingDebugVariablesDeclaration = `\nin vec2 v_objectBoxSize;\nin vec2 v_objectHelperBox;\nin vec2 v_responsiveBoxSize;\nin vec2 v_responsiveHelperBox;\nin vec2 v_patternBoxSize;\nin vec2 v_patternHelperBox;`;\nconst sizingUniformsDeclaration = `\nuniform float u_originX;\nuniform float u_originY;\nuniform float u_worldWidth;\nuniform float u_worldHeight;\nuniform float u_fit;\n\nuniform float u_scale;\nuniform float u_rotation;\nuniform float u_offsetX;\nuniform float u_offsetY;`;\nconst sizingUV = `\n\n  vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n  #ifdef USE_PIXELIZATION\n    float pxSize = u_pxSize * u_pixelRatio;\n    vec2 pxSizeUv = gl_FragCoord.xy;\n    pxSizeUv -= .5 * u_resolution;\n    pxSizeUv /= pxSize;\n    uv = floor(pxSizeUv) * pxSize / u_resolution.xy;    \n    uv += .5;\n  #endif\n  uv -= .5;\n\n  \n  // ===================================================\n  // sizing params shared between objects and patterns\n  \n  vec2 boxOrigin = vec2(.5 - u_originX, u_originY - .5);\n  vec2 givenBoxSize = vec2(u_worldWidth, u_worldHeight);\n  givenBoxSize = max(givenBoxSize, vec2(1.)) * u_pixelRatio;\n  float r = u_rotation * 3.14159265358979323846 / 180.;\n  mat2 graphicRotation = mat2(cos(r), sin(r), -sin(r), cos(r));\n  vec2 graphicOffset = vec2(-u_offsetX, u_offsetY);\n\n  \n  // ===================================================\n  // Sizing api for objects (graphics with fixed ratio)\n\n  #ifdef USE_OBJECT_SIZING\n    float fixedRatio = 1.;\n    vec2 fixedRatioBoxGivenSize = vec2(\n      (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n      (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n    );\n    vec2 objectBoxSize = vec2(0.);\n    // fit = none\n    objectBoxSize.x = fixedRatio * min(fixedRatioBoxGivenSize.x / fixedRatio, fixedRatioBoxGivenSize.y);\n    if (u_fit == 1.) { // fit = contain\n      objectBoxSize.x = fixedRatio * min(u_resolution.x / fixedRatio, u_resolution.y);\n    } else if (u_fit == 2.) {  // fit = cover\n      objectBoxSize.x = fixedRatio * max(u_resolution.x / fixedRatio, u_resolution.y);\n    }\n    objectBoxSize.y = objectBoxSize.x / fixedRatio;\n    vec2 objectWorldScale = u_resolution.xy / objectBoxSize;\n  \n    #ifdef ADD_HELPERS\n      vec2 objectHelperBox = gl_FragCoord.xy / u_resolution.xy;\n      objectHelperBox -= .5;\n      objectHelperBox *= objectWorldScale;\n      objectHelperBox += boxOrigin * (objectWorldScale - 1.);  \n    #endif\n  \n    vec2 objectUV = uv;\n    objectUV *= objectWorldScale;\n    objectUV += boxOrigin * (objectWorldScale - 1.);\n    objectUV += vec2(-u_offsetX, u_offsetY);\n    objectUV /= u_scale;\n    objectUV = graphicRotation * objectUV;\n  #endif\n  \n  // ===================================================\n \n  // ===================================================\n  // Sizing api for patterns (graphics respecting u_worldWidth / u_worldHeight ratio)\n  \n  #ifdef USE_PATTERN_SIZING\n    float patternBoxRatio = givenBoxSize.x / givenBoxSize.y;\n    vec2 patternBoxGivenSize = vec2(\n      (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n      (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n    );\n    vec2 patternBoxSize = vec2(0.);\n    // fit = none\n    patternBoxSize.x = patternBoxRatio * min(patternBoxGivenSize.x / patternBoxRatio, patternBoxGivenSize.y);\n    float patternWorldNoFitBoxWidth = patternBoxSize.x;\n    if (u_fit == 1.) {  // fit = contain\n      patternBoxSize.x = patternBoxRatio * min(u_resolution.x / patternBoxRatio, u_resolution.y);\n    } else if (u_fit == 2.) {  // fit = cover\n      patternBoxSize.x = patternBoxRatio * max(u_resolution.x / patternBoxRatio, u_resolution.y);\n    }\n    patternBoxSize.y = patternBoxSize.x / patternBoxRatio;\n    vec2 patternWorldScale = u_resolution.xy / patternBoxSize;\n  \n    #ifdef ADD_HELPERS  \n      vec2 patternHelperBox = gl_FragCoord.xy / u_resolution.xy;\n      patternHelperBox -= .5;\n      patternHelperBox *= patternWorldScale;\n      patternHelperBox += boxOrigin * (patternWorldScale - 1.);  \n    #endif\n  \n    vec2 patternUV = uv;\n    patternUV += vec2(-u_offsetX, u_offsetY) / patternWorldScale;\n    patternUV += boxOrigin;\n    patternUV -= boxOrigin / patternWorldScale;\n    patternUV *= u_resolution.xy;\n    patternUV /= u_pixelRatio;\n    if (u_fit > 0.) {\n      patternUV *= (patternWorldNoFitBoxWidth / patternBoxSize.x);\n    }\n    patternUV /= u_scale;\n    patternUV = graphicRotation * patternUV;\n    patternUV += boxOrigin / patternWorldScale;\n    patternUV -= boxOrigin;\n    patternUV += .5;\n  #endif\n    \n  // ===================================================\n \n  // ===================================================\n  // Sizing api for image filters\n  \n  #ifdef USE_IMAGE_SIZING\n\n    vec2 imageBoxSize;\n    if (u_fit == 1.) { // contain\n      imageBoxSize.x = min(u_resolution.x / u_imageAspectRatio, u_resolution.y) * u_imageAspectRatio;\n    } else if (u_fit == 2.) { // cover\n      imageBoxSize.x = max(u_resolution.x / u_imageAspectRatio, u_resolution.y) * u_imageAspectRatio;\n    } else {\n      imageBoxSize.x = min(10.0, 10.0 / u_imageAspectRatio * u_imageAspectRatio);\n    }\n    imageBoxSize.y = imageBoxSize.x / u_imageAspectRatio;\n    vec2 imageBoxScale = u_resolution.xy / imageBoxSize;\n\n    #ifdef ADD_HELPERS\n      vec2 imageHelperBox = uv;\n      imageHelperBox *= imageBoxScale;\n      imageHelperBox += boxOrigin * (imageBoxScale - 1.);\n    #endif\n\n    vec2 imageUV = uv;\n    imageUV *= imageBoxScale;\n    imageUV += boxOrigin * (imageBoxScale - 1.);\n    imageUV += graphicOffset;\n    imageUV /= u_scale;\n    imageUV.x *= u_imageAspectRatio;\n    imageUV = graphicRotation * imageUV;\n    imageUV.x /= u_imageAspectRatio;\n    \n    imageUV += .5;\n    imageUV.y = 1. - imageUV.y;\n  #endif\n`;\nconst drawSizingHelpers = `\n  vec2 worldBoxDist = abs(helperBox);\n  float boxStroke = (step(max(worldBoxDist.x, worldBoxDist.y), .5) - step(max(worldBoxDist.x, worldBoxDist.y), .495));\n  color.rgb = mix(color.rgb, vec3(1., 0., 0.), boxStroke);\n  opacity += boxStroke;\n\n  vec2 boxOriginCopy = vec2(.5 - u_originX, u_originY - .5);\n  vec2 boxOriginDist = helperBox + boxOriginCopy;\n  boxOriginDist.x *= (boxSize.x / boxSize.y);\n  float boxOriginPoint = 1. - smoothstep(0., .05, length(boxOriginDist));\n  \n  vec2 graphicOriginPointDist = helperBox + vec2(-u_offsetX, u_offsetY);\n  graphicOriginPointDist.x *= (boxSize.x / boxSize.y);\n  float graphicOriginPoint = 1. - smoothstep(0., .05, length(graphicOriginPointDist));\n  \n  color.rgb = mix(color.rgb, vec3(0., 1., 0.), boxOriginPoint);\n  opacity += boxOriginPoint;\n  color.rgb = mix(color.rgb, vec3(0., 0., 1.), graphicOriginPoint);\n  opacity += graphicOriginPoint;\n`;\nconst defaultObjectSizing = {\n  fit: \"contain\",\n  scale: 1,\n  rotation: 0,\n  offsetX: 0,\n  offsetY: 0,\n  originX: 0.5,\n  originY: 0.5,\n  worldWidth: 0,\n  worldHeight: 0\n};\nconst defaultPatternSizing = {\n  fit: \"none\",\n  scale: 1,\n  rotation: 0,\n  offsetX: 0,\n  offsetY: 0,\n  originX: 0.5,\n  originY: 0.5,\n  worldWidth: 0,\n  worldHeight: 0\n};\nconst ShaderFitOptions = {\n  none: 0,\n  contain: 1,\n  cover: 2\n};\n\n//# sourceMappingURL=shader-sizing.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVyLXNpemluZy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLE1BQU0seUJBQXlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxNQUFNLHlCQUF5QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLE1BQU0sd0JBQXdCO0FBQzlCO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFVRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9AcGFwZXItZGVzaWduL3NoYWRlcnMvZGlzdC9zaGFkZXItc2l6aW5nLmpzPzZiMWMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqICAgICAgICAgICAgICAgICAgICBQYXBlciBTaGFkZXJzICAgICAgICAgICAgICAgICAgICAqXG4gKiAgICAgICBodHRwczovL2dpdGh1Yi5jb20vcGFwZXItZGVzaWduL3NoYWRlcnMgICAgICAgKlxuICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICovXG5cbmNvbnN0IHNpemluZ1ZhcmlhYmxlc0RlY2xhcmF0aW9uID0gYFxuaW4gdmVjMiB2X29iamVjdFVWO1xuaW4gdmVjMiB2X3Jlc3BvbnNpdmVVVjtcbmluIHZlYzIgdl9yZXNwb25zaXZlQm94R2l2ZW5TaXplO1xuaW4gdmVjMiB2X3BhdHRlcm5VVjtcbmluIHZlYzIgdl9pbWFnZVVWO2A7XG5jb25zdCBzaXppbmdEZWJ1Z1ZhcmlhYmxlc0RlY2xhcmF0aW9uID0gYFxuaW4gdmVjMiB2X29iamVjdEJveFNpemU7XG5pbiB2ZWMyIHZfb2JqZWN0SGVscGVyQm94O1xuaW4gdmVjMiB2X3Jlc3BvbnNpdmVCb3hTaXplO1xuaW4gdmVjMiB2X3Jlc3BvbnNpdmVIZWxwZXJCb3g7XG5pbiB2ZWMyIHZfcGF0dGVybkJveFNpemU7XG5pbiB2ZWMyIHZfcGF0dGVybkhlbHBlckJveDtgO1xuY29uc3Qgc2l6aW5nVW5pZm9ybXNEZWNsYXJhdGlvbiA9IGBcbnVuaWZvcm0gZmxvYXQgdV9vcmlnaW5YO1xudW5pZm9ybSBmbG9hdCB1X29yaWdpblk7XG51bmlmb3JtIGZsb2F0IHVfd29ybGRXaWR0aDtcbnVuaWZvcm0gZmxvYXQgdV93b3JsZEhlaWdodDtcbnVuaWZvcm0gZmxvYXQgdV9maXQ7XG5cbnVuaWZvcm0gZmxvYXQgdV9zY2FsZTtcbnVuaWZvcm0gZmxvYXQgdV9yb3RhdGlvbjtcbnVuaWZvcm0gZmxvYXQgdV9vZmZzZXRYO1xudW5pZm9ybSBmbG9hdCB1X29mZnNldFk7YDtcbmNvbnN0IHNpemluZ1VWID0gYFxuXG4gIHZlYzIgdXYgPSBnbF9GcmFnQ29vcmQueHkgLyB1X3Jlc29sdXRpb24ueHk7XG4gICNpZmRlZiBVU0VfUElYRUxJWkFUSU9OXG4gICAgZmxvYXQgcHhTaXplID0gdV9weFNpemUgKiB1X3BpeGVsUmF0aW87XG4gICAgdmVjMiBweFNpemVVdiA9IGdsX0ZyYWdDb29yZC54eTtcbiAgICBweFNpemVVdiAtPSAuNSAqIHVfcmVzb2x1dGlvbjtcbiAgICBweFNpemVVdiAvPSBweFNpemU7XG4gICAgdXYgPSBmbG9vcihweFNpemVVdikgKiBweFNpemUgLyB1X3Jlc29sdXRpb24ueHk7ICAgIFxuICAgIHV2ICs9IC41O1xuICAjZW5kaWZcbiAgdXYgLT0gLjU7XG5cbiAgXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBzaXppbmcgcGFyYW1zIHNoYXJlZCBiZXR3ZWVuIG9iamVjdHMgYW5kIHBhdHRlcm5zXG4gIFxuICB2ZWMyIGJveE9yaWdpbiA9IHZlYzIoLjUgLSB1X29yaWdpblgsIHVfb3JpZ2luWSAtIC41KTtcbiAgdmVjMiBnaXZlbkJveFNpemUgPSB2ZWMyKHVfd29ybGRXaWR0aCwgdV93b3JsZEhlaWdodCk7XG4gIGdpdmVuQm94U2l6ZSA9IG1heChnaXZlbkJveFNpemUsIHZlYzIoMS4pKSAqIHVfcGl4ZWxSYXRpbztcbiAgZmxvYXQgciA9IHVfcm90YXRpb24gKiAzLjE0MTU5MjY1MzU4OTc5MzIzODQ2IC8gMTgwLjtcbiAgbWF0MiBncmFwaGljUm90YXRpb24gPSBtYXQyKGNvcyhyKSwgc2luKHIpLCAtc2luKHIpLCBjb3MocikpO1xuICB2ZWMyIGdyYXBoaWNPZmZzZXQgPSB2ZWMyKC11X29mZnNldFgsIHVfb2Zmc2V0WSk7XG5cbiAgXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBTaXppbmcgYXBpIGZvciBvYmplY3RzIChncmFwaGljcyB3aXRoIGZpeGVkIHJhdGlvKVxuXG4gICNpZmRlZiBVU0VfT0JKRUNUX1NJWklOR1xuICAgIGZsb2F0IGZpeGVkUmF0aW8gPSAxLjtcbiAgICB2ZWMyIGZpeGVkUmF0aW9Cb3hHaXZlblNpemUgPSB2ZWMyKFxuICAgICAgKHVfd29ybGRXaWR0aCA9PSAwLikgPyB1X3Jlc29sdXRpb24ueCA6IGdpdmVuQm94U2l6ZS54LFxuICAgICAgKHVfd29ybGRIZWlnaHQgPT0gMC4pID8gdV9yZXNvbHV0aW9uLnkgOiBnaXZlbkJveFNpemUueVxuICAgICk7XG4gICAgdmVjMiBvYmplY3RCb3hTaXplID0gdmVjMigwLik7XG4gICAgLy8gZml0ID0gbm9uZVxuICAgIG9iamVjdEJveFNpemUueCA9IGZpeGVkUmF0aW8gKiBtaW4oZml4ZWRSYXRpb0JveEdpdmVuU2l6ZS54IC8gZml4ZWRSYXRpbywgZml4ZWRSYXRpb0JveEdpdmVuU2l6ZS55KTtcbiAgICBpZiAodV9maXQgPT0gMS4pIHsgLy8gZml0ID0gY29udGFpblxuICAgICAgb2JqZWN0Qm94U2l6ZS54ID0gZml4ZWRSYXRpbyAqIG1pbih1X3Jlc29sdXRpb24ueCAvIGZpeGVkUmF0aW8sIHVfcmVzb2x1dGlvbi55KTtcbiAgICB9IGVsc2UgaWYgKHVfZml0ID09IDIuKSB7ICAvLyBmaXQgPSBjb3ZlclxuICAgICAgb2JqZWN0Qm94U2l6ZS54ID0gZml4ZWRSYXRpbyAqIG1heCh1X3Jlc29sdXRpb24ueCAvIGZpeGVkUmF0aW8sIHVfcmVzb2x1dGlvbi55KTtcbiAgICB9XG4gICAgb2JqZWN0Qm94U2l6ZS55ID0gb2JqZWN0Qm94U2l6ZS54IC8gZml4ZWRSYXRpbztcbiAgICB2ZWMyIG9iamVjdFdvcmxkU2NhbGUgPSB1X3Jlc29sdXRpb24ueHkgLyBvYmplY3RCb3hTaXplO1xuICBcbiAgICAjaWZkZWYgQUREX0hFTFBFUlNcbiAgICAgIHZlYzIgb2JqZWN0SGVscGVyQm94ID0gZ2xfRnJhZ0Nvb3JkLnh5IC8gdV9yZXNvbHV0aW9uLnh5O1xuICAgICAgb2JqZWN0SGVscGVyQm94IC09IC41O1xuICAgICAgb2JqZWN0SGVscGVyQm94ICo9IG9iamVjdFdvcmxkU2NhbGU7XG4gICAgICBvYmplY3RIZWxwZXJCb3ggKz0gYm94T3JpZ2luICogKG9iamVjdFdvcmxkU2NhbGUgLSAxLik7ICBcbiAgICAjZW5kaWZcbiAgXG4gICAgdmVjMiBvYmplY3RVViA9IHV2O1xuICAgIG9iamVjdFVWICo9IG9iamVjdFdvcmxkU2NhbGU7XG4gICAgb2JqZWN0VVYgKz0gYm94T3JpZ2luICogKG9iamVjdFdvcmxkU2NhbGUgLSAxLik7XG4gICAgb2JqZWN0VVYgKz0gdmVjMigtdV9vZmZzZXRYLCB1X29mZnNldFkpO1xuICAgIG9iamVjdFVWIC89IHVfc2NhbGU7XG4gICAgb2JqZWN0VVYgPSBncmFwaGljUm90YXRpb24gKiBvYmplY3RVVjtcbiAgI2VuZGlmXG4gIFxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiBcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFNpemluZyBhcGkgZm9yIHBhdHRlcm5zIChncmFwaGljcyByZXNwZWN0aW5nIHVfd29ybGRXaWR0aCAvIHVfd29ybGRIZWlnaHQgcmF0aW8pXG4gIFxuICAjaWZkZWYgVVNFX1BBVFRFUk5fU0laSU5HXG4gICAgZmxvYXQgcGF0dGVybkJveFJhdGlvID0gZ2l2ZW5Cb3hTaXplLnggLyBnaXZlbkJveFNpemUueTtcbiAgICB2ZWMyIHBhdHRlcm5Cb3hHaXZlblNpemUgPSB2ZWMyKFxuICAgICAgKHVfd29ybGRXaWR0aCA9PSAwLikgPyB1X3Jlc29sdXRpb24ueCA6IGdpdmVuQm94U2l6ZS54LFxuICAgICAgKHVfd29ybGRIZWlnaHQgPT0gMC4pID8gdV9yZXNvbHV0aW9uLnkgOiBnaXZlbkJveFNpemUueVxuICAgICk7XG4gICAgdmVjMiBwYXR0ZXJuQm94U2l6ZSA9IHZlYzIoMC4pO1xuICAgIC8vIGZpdCA9IG5vbmVcbiAgICBwYXR0ZXJuQm94U2l6ZS54ID0gcGF0dGVybkJveFJhdGlvICogbWluKHBhdHRlcm5Cb3hHaXZlblNpemUueCAvIHBhdHRlcm5Cb3hSYXRpbywgcGF0dGVybkJveEdpdmVuU2l6ZS55KTtcbiAgICBmbG9hdCBwYXR0ZXJuV29ybGROb0ZpdEJveFdpZHRoID0gcGF0dGVybkJveFNpemUueDtcbiAgICBpZiAodV9maXQgPT0gMS4pIHsgIC8vIGZpdCA9IGNvbnRhaW5cbiAgICAgIHBhdHRlcm5Cb3hTaXplLnggPSBwYXR0ZXJuQm94UmF0aW8gKiBtaW4odV9yZXNvbHV0aW9uLnggLyBwYXR0ZXJuQm94UmF0aW8sIHVfcmVzb2x1dGlvbi55KTtcbiAgICB9IGVsc2UgaWYgKHVfZml0ID09IDIuKSB7ICAvLyBmaXQgPSBjb3ZlclxuICAgICAgcGF0dGVybkJveFNpemUueCA9IHBhdHRlcm5Cb3hSYXRpbyAqIG1heCh1X3Jlc29sdXRpb24ueCAvIHBhdHRlcm5Cb3hSYXRpbywgdV9yZXNvbHV0aW9uLnkpO1xuICAgIH1cbiAgICBwYXR0ZXJuQm94U2l6ZS55ID0gcGF0dGVybkJveFNpemUueCAvIHBhdHRlcm5Cb3hSYXRpbztcbiAgICB2ZWMyIHBhdHRlcm5Xb3JsZFNjYWxlID0gdV9yZXNvbHV0aW9uLnh5IC8gcGF0dGVybkJveFNpemU7XG4gIFxuICAgICNpZmRlZiBBRERfSEVMUEVSUyAgXG4gICAgICB2ZWMyIHBhdHRlcm5IZWxwZXJCb3ggPSBnbF9GcmFnQ29vcmQueHkgLyB1X3Jlc29sdXRpb24ueHk7XG4gICAgICBwYXR0ZXJuSGVscGVyQm94IC09IC41O1xuICAgICAgcGF0dGVybkhlbHBlckJveCAqPSBwYXR0ZXJuV29ybGRTY2FsZTtcbiAgICAgIHBhdHRlcm5IZWxwZXJCb3ggKz0gYm94T3JpZ2luICogKHBhdHRlcm5Xb3JsZFNjYWxlIC0gMS4pOyAgXG4gICAgI2VuZGlmXG4gIFxuICAgIHZlYzIgcGF0dGVyblVWID0gdXY7XG4gICAgcGF0dGVyblVWICs9IHZlYzIoLXVfb2Zmc2V0WCwgdV9vZmZzZXRZKSAvIHBhdHRlcm5Xb3JsZFNjYWxlO1xuICAgIHBhdHRlcm5VViArPSBib3hPcmlnaW47XG4gICAgcGF0dGVyblVWIC09IGJveE9yaWdpbiAvIHBhdHRlcm5Xb3JsZFNjYWxlO1xuICAgIHBhdHRlcm5VViAqPSB1X3Jlc29sdXRpb24ueHk7XG4gICAgcGF0dGVyblVWIC89IHVfcGl4ZWxSYXRpbztcbiAgICBpZiAodV9maXQgPiAwLikge1xuICAgICAgcGF0dGVyblVWICo9IChwYXR0ZXJuV29ybGROb0ZpdEJveFdpZHRoIC8gcGF0dGVybkJveFNpemUueCk7XG4gICAgfVxuICAgIHBhdHRlcm5VViAvPSB1X3NjYWxlO1xuICAgIHBhdHRlcm5VViA9IGdyYXBoaWNSb3RhdGlvbiAqIHBhdHRlcm5VVjtcbiAgICBwYXR0ZXJuVVYgKz0gYm94T3JpZ2luIC8gcGF0dGVybldvcmxkU2NhbGU7XG4gICAgcGF0dGVyblVWIC09IGJveE9yaWdpbjtcbiAgICBwYXR0ZXJuVVYgKz0gLjU7XG4gICNlbmRpZlxuICAgIFxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiBcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFNpemluZyBhcGkgZm9yIGltYWdlIGZpbHRlcnNcbiAgXG4gICNpZmRlZiBVU0VfSU1BR0VfU0laSU5HXG5cbiAgICB2ZWMyIGltYWdlQm94U2l6ZTtcbiAgICBpZiAodV9maXQgPT0gMS4pIHsgLy8gY29udGFpblxuICAgICAgaW1hZ2VCb3hTaXplLnggPSBtaW4odV9yZXNvbHV0aW9uLnggLyB1X2ltYWdlQXNwZWN0UmF0aW8sIHVfcmVzb2x1dGlvbi55KSAqIHVfaW1hZ2VBc3BlY3RSYXRpbztcbiAgICB9IGVsc2UgaWYgKHVfZml0ID09IDIuKSB7IC8vIGNvdmVyXG4gICAgICBpbWFnZUJveFNpemUueCA9IG1heCh1X3Jlc29sdXRpb24ueCAvIHVfaW1hZ2VBc3BlY3RSYXRpbywgdV9yZXNvbHV0aW9uLnkpICogdV9pbWFnZUFzcGVjdFJhdGlvO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbWFnZUJveFNpemUueCA9IG1pbigxMC4wLCAxMC4wIC8gdV9pbWFnZUFzcGVjdFJhdGlvICogdV9pbWFnZUFzcGVjdFJhdGlvKTtcbiAgICB9XG4gICAgaW1hZ2VCb3hTaXplLnkgPSBpbWFnZUJveFNpemUueCAvIHVfaW1hZ2VBc3BlY3RSYXRpbztcbiAgICB2ZWMyIGltYWdlQm94U2NhbGUgPSB1X3Jlc29sdXRpb24ueHkgLyBpbWFnZUJveFNpemU7XG5cbiAgICAjaWZkZWYgQUREX0hFTFBFUlNcbiAgICAgIHZlYzIgaW1hZ2VIZWxwZXJCb3ggPSB1djtcbiAgICAgIGltYWdlSGVscGVyQm94ICo9IGltYWdlQm94U2NhbGU7XG4gICAgICBpbWFnZUhlbHBlckJveCArPSBib3hPcmlnaW4gKiAoaW1hZ2VCb3hTY2FsZSAtIDEuKTtcbiAgICAjZW5kaWZcblxuICAgIHZlYzIgaW1hZ2VVViA9IHV2O1xuICAgIGltYWdlVVYgKj0gaW1hZ2VCb3hTY2FsZTtcbiAgICBpbWFnZVVWICs9IGJveE9yaWdpbiAqIChpbWFnZUJveFNjYWxlIC0gMS4pO1xuICAgIGltYWdlVVYgKz0gZ3JhcGhpY09mZnNldDtcbiAgICBpbWFnZVVWIC89IHVfc2NhbGU7XG4gICAgaW1hZ2VVVi54ICo9IHVfaW1hZ2VBc3BlY3RSYXRpbztcbiAgICBpbWFnZVVWID0gZ3JhcGhpY1JvdGF0aW9uICogaW1hZ2VVVjtcbiAgICBpbWFnZVVWLnggLz0gdV9pbWFnZUFzcGVjdFJhdGlvO1xuICAgIFxuICAgIGltYWdlVVYgKz0gLjU7XG4gICAgaW1hZ2VVVi55ID0gMS4gLSBpbWFnZVVWLnk7XG4gICNlbmRpZlxuYDtcbmNvbnN0IGRyYXdTaXppbmdIZWxwZXJzID0gYFxuICB2ZWMyIHdvcmxkQm94RGlzdCA9IGFicyhoZWxwZXJCb3gpO1xuICBmbG9hdCBib3hTdHJva2UgPSAoc3RlcChtYXgod29ybGRCb3hEaXN0LngsIHdvcmxkQm94RGlzdC55KSwgLjUpIC0gc3RlcChtYXgod29ybGRCb3hEaXN0LngsIHdvcmxkQm94RGlzdC55KSwgLjQ5NSkpO1xuICBjb2xvci5yZ2IgPSBtaXgoY29sb3IucmdiLCB2ZWMzKDEuLCAwLiwgMC4pLCBib3hTdHJva2UpO1xuICBvcGFjaXR5ICs9IGJveFN0cm9rZTtcblxuICB2ZWMyIGJveE9yaWdpbkNvcHkgPSB2ZWMyKC41IC0gdV9vcmlnaW5YLCB1X29yaWdpblkgLSAuNSk7XG4gIHZlYzIgYm94T3JpZ2luRGlzdCA9IGhlbHBlckJveCArIGJveE9yaWdpbkNvcHk7XG4gIGJveE9yaWdpbkRpc3QueCAqPSAoYm94U2l6ZS54IC8gYm94U2l6ZS55KTtcbiAgZmxvYXQgYm94T3JpZ2luUG9pbnQgPSAxLiAtIHNtb290aHN0ZXAoMC4sIC4wNSwgbGVuZ3RoKGJveE9yaWdpbkRpc3QpKTtcbiAgXG4gIHZlYzIgZ3JhcGhpY09yaWdpblBvaW50RGlzdCA9IGhlbHBlckJveCArIHZlYzIoLXVfb2Zmc2V0WCwgdV9vZmZzZXRZKTtcbiAgZ3JhcGhpY09yaWdpblBvaW50RGlzdC54ICo9IChib3hTaXplLnggLyBib3hTaXplLnkpO1xuICBmbG9hdCBncmFwaGljT3JpZ2luUG9pbnQgPSAxLiAtIHNtb290aHN0ZXAoMC4sIC4wNSwgbGVuZ3RoKGdyYXBoaWNPcmlnaW5Qb2ludERpc3QpKTtcbiAgXG4gIGNvbG9yLnJnYiA9IG1peChjb2xvci5yZ2IsIHZlYzMoMC4sIDEuLCAwLiksIGJveE9yaWdpblBvaW50KTtcbiAgb3BhY2l0eSArPSBib3hPcmlnaW5Qb2ludDtcbiAgY29sb3IucmdiID0gbWl4KGNvbG9yLnJnYiwgdmVjMygwLiwgMC4sIDEuKSwgZ3JhcGhpY09yaWdpblBvaW50KTtcbiAgb3BhY2l0eSArPSBncmFwaGljT3JpZ2luUG9pbnQ7XG5gO1xuY29uc3QgZGVmYXVsdE9iamVjdFNpemluZyA9IHtcbiAgZml0OiBcImNvbnRhaW5cIixcbiAgc2NhbGU6IDEsXG4gIHJvdGF0aW9uOiAwLFxuICBvZmZzZXRYOiAwLFxuICBvZmZzZXRZOiAwLFxuICBvcmlnaW5YOiAwLjUsXG4gIG9yaWdpblk6IDAuNSxcbiAgd29ybGRXaWR0aDogMCxcbiAgd29ybGRIZWlnaHQ6IDBcbn07XG5jb25zdCBkZWZhdWx0UGF0dGVyblNpemluZyA9IHtcbiAgZml0OiBcIm5vbmVcIixcbiAgc2NhbGU6IDEsXG4gIHJvdGF0aW9uOiAwLFxuICBvZmZzZXRYOiAwLFxuICBvZmZzZXRZOiAwLFxuICBvcmlnaW5YOiAwLjUsXG4gIG9yaWdpblk6IDAuNSxcbiAgd29ybGRXaWR0aDogMCxcbiAgd29ybGRIZWlnaHQ6IDBcbn07XG5jb25zdCBTaGFkZXJGaXRPcHRpb25zID0ge1xuICBub25lOiAwLFxuICBjb250YWluOiAxLFxuICBjb3ZlcjogMlxufTtcbmV4cG9ydCB7XG4gIFNoYWRlckZpdE9wdGlvbnMsXG4gIGRlZmF1bHRPYmplY3RTaXppbmcsXG4gIGRlZmF1bHRQYXR0ZXJuU2l6aW5nLFxuICBkcmF3U2l6aW5nSGVscGVycyxcbiAgc2l6aW5nRGVidWdWYXJpYWJsZXNEZWNsYXJhdGlvbixcbiAgc2l6aW5nVVYsXG4gIHNpemluZ1VuaWZvcm1zRGVjbGFyYXRpb24sXG4gIHNpemluZ1ZhcmlhYmxlc0RlY2xhcmF0aW9uXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhZGVyLXNpemluZy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/shader-sizing.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/shader-utils.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/shader-utils.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   colorBandingFix: () => (/* binding */ colorBandingFix),\n/* harmony export */   declarePI: () => (/* binding */ declarePI),\n/* harmony export */   fiberNoise: () => (/* binding */ fiberNoise),\n/* harmony export */   proceduralHash11: () => (/* binding */ proceduralHash11),\n/* harmony export */   proceduralHash21: () => (/* binding */ proceduralHash21),\n/* harmony export */   proceduralHash22: () => (/* binding */ proceduralHash22),\n/* harmony export */   rotation2: () => (/* binding */ rotation2),\n/* harmony export */   simplexNoise: () => (/* binding */ simplexNoise),\n/* harmony export */   textureRandomizerGB: () => (/* binding */ textureRandomizerGB),\n/* harmony export */   textureRandomizerR: () => (/* binding */ textureRandomizerR)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nconst declarePI = `\n#define TWO_PI 6.28318530718\n#define PI 3.14159265358979323846\n`;\nconst rotation2 = `\nvec2 rotate(vec2 uv, float th) {\n  return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\n}\n`;\nconst proceduralHash11 = `\n  float hash11(float p) {\n    p = fract(p * 0.3183099) + 0.1;\n    p *= p + 19.19;\n    return fract(p * p);\n  }\n`;\nconst proceduralHash21 = `\n  float hash21(vec2 p) {\n    p = fract(p * vec2(0.3183099, 0.3678794)) + 0.1;\n    p += dot(p, p + 19.19);\n    return fract(p.x * p.y);\n  }\n`;\nconst proceduralHash22 = `\n  vec2 hash22(vec2 p) {\n    p = fract(p * vec2(0.3183099, 0.3678794)) + 0.1;\n    p += dot(p, p.yx + 19.19);\n    return fract(vec2(p.x * p.y, p.x + p.y));\n  }\n`;\nconst textureRandomizerR = `\n  float randomR(vec2 p) {\n    vec2 uv = floor(p) / 100. + .5;\n    return texture(u_noiseTexture, fract(uv)).r;\n  }\n`;\nconst textureRandomizerGB = `\n  vec2 randomGB(vec2 p) {\n    vec2 uv = floor(p) / 100. + .5;\n    return texture(u_noiseTexture, fract(uv)).gb;\n  }\n`;\nconst colorBandingFix = `\n  color += 1. / 256. * (fract(sin(dot(.014 * gl_FragCoord.xy, vec2(12.9898, 78.233))) * 43758.5453123) - .5);\n`;\nconst simplexNoise = `\nvec3 permute(vec3 x) { return mod(((x * 34.0) + 1.0) * x, 289.0); }\nfloat snoise(vec2 v) {\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n    -0.577350269189626, 0.024390243902439);\n  vec2 i = floor(v + dot(v, C.yy));\n  vec2 x0 = v - i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))\n    + i.x + vec3(0.0, i1.x, 1.0));\n  vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy),\n      dot(x12.zw, x12.zw)), 0.0);\n  m = m * m;\n  m = m * m;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\n  vec3 g;\n  g.x = a0.x * x0.x + h.x * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n`;\nconst fiberNoise = `\nfloat fiberRandom(vec2 p) {\n  vec2 uv = floor(p) / 100.;\n  return texture(u_noiseTexture, fract(uv)).b;\n}\n\nfloat fiberValueNoise(vec2 st) {\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n  float a = fiberRandom(i);\n  float b = fiberRandom(i + vec2(1.0, 0.0));\n  float c = fiberRandom(i + vec2(0.0, 1.0));\n  float d = fiberRandom(i + vec2(1.0, 1.0));\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  float x1 = mix(a, b, u.x);\n  float x2 = mix(c, d, u.x);\n  return mix(x1, x2, u.y);\n}\n\nfloat fiberNoiseFbm(in vec2 n, vec2 seedOffset) {\n  float total = 0.0, amplitude = 1.;\n  for (int i = 0; i < 4; i++) {\n    n = rotate(n, .7);\n    total += fiberValueNoise(n + seedOffset) * amplitude;\n    n *= 2.;\n    amplitude *= 0.6;\n  }\n  return total;\n}\n\nfloat fiberNoise(vec2 uv, vec2 seedOffset) {\n  float epsilon = 0.001;\n  float n1 = fiberNoiseFbm(uv + vec2(epsilon, 0.0), seedOffset);\n  float n2 = fiberNoiseFbm(uv - vec2(epsilon, 0.0), seedOffset);\n  float n3 = fiberNoiseFbm(uv + vec2(0.0, epsilon), seedOffset);\n  float n4 = fiberNoiseFbm(uv - vec2(0.0, epsilon), seedOffset);\n  return length(vec2(n1 - n2, n3 - n4)) / (2.0 * epsilon);\n}\n`;\n\n//# sourceMappingURL=shader-utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVyLXV0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVyLXV0aWxzLmpzPzhhOTEiXSwic291cmNlc0NvbnRlbnQiOlsiLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqICAgICAgICAgICAgICAgICAgICBQYXBlciBTaGFkZXJzICAgICAgICAgICAgICAgICAgICAqXG4gKiAgICAgICBodHRwczovL2dpdGh1Yi5jb20vcGFwZXItZGVzaWduL3NoYWRlcnMgICAgICAgKlxuICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICovXG5cbmNvbnN0IGRlY2xhcmVQSSA9IGBcbiNkZWZpbmUgVFdPX1BJIDYuMjgzMTg1MzA3MThcbiNkZWZpbmUgUEkgMy4xNDE1OTI2NTM1ODk3OTMyMzg0NlxuYDtcbmNvbnN0IHJvdGF0aW9uMiA9IGBcbnZlYzIgcm90YXRlKHZlYzIgdXYsIGZsb2F0IHRoKSB7XG4gIHJldHVybiBtYXQyKGNvcyh0aCksIHNpbih0aCksIC1zaW4odGgpLCBjb3ModGgpKSAqIHV2O1xufVxuYDtcbmNvbnN0IHByb2NlZHVyYWxIYXNoMTEgPSBgXG4gIGZsb2F0IGhhc2gxMShmbG9hdCBwKSB7XG4gICAgcCA9IGZyYWN0KHAgKiAwLjMxODMwOTkpICsgMC4xO1xuICAgIHAgKj0gcCArIDE5LjE5O1xuICAgIHJldHVybiBmcmFjdChwICogcCk7XG4gIH1cbmA7XG5jb25zdCBwcm9jZWR1cmFsSGFzaDIxID0gYFxuICBmbG9hdCBoYXNoMjEodmVjMiBwKSB7XG4gICAgcCA9IGZyYWN0KHAgKiB2ZWMyKDAuMzE4MzA5OSwgMC4zNjc4Nzk0KSkgKyAwLjE7XG4gICAgcCArPSBkb3QocCwgcCArIDE5LjE5KTtcbiAgICByZXR1cm4gZnJhY3QocC54ICogcC55KTtcbiAgfVxuYDtcbmNvbnN0IHByb2NlZHVyYWxIYXNoMjIgPSBgXG4gIHZlYzIgaGFzaDIyKHZlYzIgcCkge1xuICAgIHAgPSBmcmFjdChwICogdmVjMigwLjMxODMwOTksIDAuMzY3ODc5NCkpICsgMC4xO1xuICAgIHAgKz0gZG90KHAsIHAueXggKyAxOS4xOSk7XG4gICAgcmV0dXJuIGZyYWN0KHZlYzIocC54ICogcC55LCBwLnggKyBwLnkpKTtcbiAgfVxuYDtcbmNvbnN0IHRleHR1cmVSYW5kb21pemVyUiA9IGBcbiAgZmxvYXQgcmFuZG9tUih2ZWMyIHApIHtcbiAgICB2ZWMyIHV2ID0gZmxvb3IocCkgLyAxMDAuICsgLjU7XG4gICAgcmV0dXJuIHRleHR1cmUodV9ub2lzZVRleHR1cmUsIGZyYWN0KHV2KSkucjtcbiAgfVxuYDtcbmNvbnN0IHRleHR1cmVSYW5kb21pemVyR0IgPSBgXG4gIHZlYzIgcmFuZG9tR0IodmVjMiBwKSB7XG4gICAgdmVjMiB1diA9IGZsb29yKHApIC8gMTAwLiArIC41O1xuICAgIHJldHVybiB0ZXh0dXJlKHVfbm9pc2VUZXh0dXJlLCBmcmFjdCh1dikpLmdiO1xuICB9XG5gO1xuY29uc3QgY29sb3JCYW5kaW5nRml4ID0gYFxuICBjb2xvciArPSAxLiAvIDI1Ni4gKiAoZnJhY3Qoc2luKGRvdCguMDE0ICogZ2xfRnJhZ0Nvb3JkLnh5LCB2ZWMyKDEyLjk4OTgsIDc4LjIzMykpKSAqIDQzNzU4LjU0NTMxMjMpIC0gLjUpO1xuYDtcbmNvbnN0IHNpbXBsZXhOb2lzZSA9IGBcbnZlYzMgcGVybXV0ZSh2ZWMzIHgpIHsgcmV0dXJuIG1vZCgoKHggKiAzNC4wKSArIDEuMCkgKiB4LCAyODkuMCk7IH1cbmZsb2F0IHNub2lzZSh2ZWMyIHYpIHtcbiAgY29uc3QgdmVjNCBDID0gdmVjNCgwLjIxMTMyNDg2NTQwNTE4NywgMC4zNjYwMjU0MDM3ODQ0MzksXG4gICAgLTAuNTc3MzUwMjY5MTg5NjI2LCAwLjAyNDM5MDI0MzkwMjQzOSk7XG4gIHZlYzIgaSA9IGZsb29yKHYgKyBkb3QodiwgQy55eSkpO1xuICB2ZWMyIHgwID0gdiAtIGkgKyBkb3QoaSwgQy54eCk7XG4gIHZlYzIgaTE7XG4gIGkxID0gKHgwLnggPiB4MC55KSA/IHZlYzIoMS4wLCAwLjApIDogdmVjMigwLjAsIDEuMCk7XG4gIHZlYzQgeDEyID0geDAueHl4eSArIEMueHh6ejtcbiAgeDEyLnh5IC09IGkxO1xuICBpID0gbW9kKGksIDI4OS4wKTtcbiAgdmVjMyBwID0gcGVybXV0ZShwZXJtdXRlKGkueSArIHZlYzMoMC4wLCBpMS55LCAxLjApKVxuICAgICsgaS54ICsgdmVjMygwLjAsIGkxLngsIDEuMCkpO1xuICB2ZWMzIG0gPSBtYXgoMC41IC0gdmVjMyhkb3QoeDAsIHgwKSwgZG90KHgxMi54eSwgeDEyLnh5KSxcbiAgICAgIGRvdCh4MTIuencsIHgxMi56dykpLCAwLjApO1xuICBtID0gbSAqIG07XG4gIG0gPSBtICogbTtcbiAgdmVjMyB4ID0gMi4wICogZnJhY3QocCAqIEMud3d3KSAtIDEuMDtcbiAgdmVjMyBoID0gYWJzKHgpIC0gMC41O1xuICB2ZWMzIG94ID0gZmxvb3IoeCArIDAuNSk7XG4gIHZlYzMgYTAgPSB4IC0gb3g7XG4gIG0gKj0gMS43OTI4NDI5MTQwMDE1OSAtIDAuODUzNzM0NzIwOTUzMTQgKiAoYTAgKiBhMCArIGggKiBoKTtcbiAgdmVjMyBnO1xuICBnLnggPSBhMC54ICogeDAueCArIGgueCAqIHgwLnk7XG4gIGcueXogPSBhMC55eiAqIHgxMi54eiArIGgueXogKiB4MTIueXc7XG4gIHJldHVybiAxMzAuMCAqIGRvdChtLCBnKTtcbn1cbmA7XG5jb25zdCBmaWJlck5vaXNlID0gYFxuZmxvYXQgZmliZXJSYW5kb20odmVjMiBwKSB7XG4gIHZlYzIgdXYgPSBmbG9vcihwKSAvIDEwMC47XG4gIHJldHVybiB0ZXh0dXJlKHVfbm9pc2VUZXh0dXJlLCBmcmFjdCh1dikpLmI7XG59XG5cbmZsb2F0IGZpYmVyVmFsdWVOb2lzZSh2ZWMyIHN0KSB7XG4gIHZlYzIgaSA9IGZsb29yKHN0KTtcbiAgdmVjMiBmID0gZnJhY3Qoc3QpO1xuICBmbG9hdCBhID0gZmliZXJSYW5kb20oaSk7XG4gIGZsb2F0IGIgPSBmaWJlclJhbmRvbShpICsgdmVjMigxLjAsIDAuMCkpO1xuICBmbG9hdCBjID0gZmliZXJSYW5kb20oaSArIHZlYzIoMC4wLCAxLjApKTtcbiAgZmxvYXQgZCA9IGZpYmVyUmFuZG9tKGkgKyB2ZWMyKDEuMCwgMS4wKSk7XG4gIHZlYzIgdSA9IGYgKiBmICogKDMuMCAtIDIuMCAqIGYpO1xuICBmbG9hdCB4MSA9IG1peChhLCBiLCB1LngpO1xuICBmbG9hdCB4MiA9IG1peChjLCBkLCB1LngpO1xuICByZXR1cm4gbWl4KHgxLCB4MiwgdS55KTtcbn1cblxuZmxvYXQgZmliZXJOb2lzZUZibShpbiB2ZWMyIG4sIHZlYzIgc2VlZE9mZnNldCkge1xuICBmbG9hdCB0b3RhbCA9IDAuMCwgYW1wbGl0dWRlID0gMS47XG4gIGZvciAoaW50IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgbiA9IHJvdGF0ZShuLCAuNyk7XG4gICAgdG90YWwgKz0gZmliZXJWYWx1ZU5vaXNlKG4gKyBzZWVkT2Zmc2V0KSAqIGFtcGxpdHVkZTtcbiAgICBuICo9IDIuO1xuICAgIGFtcGxpdHVkZSAqPSAwLjY7XG4gIH1cbiAgcmV0dXJuIHRvdGFsO1xufVxuXG5mbG9hdCBmaWJlck5vaXNlKHZlYzIgdXYsIHZlYzIgc2VlZE9mZnNldCkge1xuICBmbG9hdCBlcHNpbG9uID0gMC4wMDE7XG4gIGZsb2F0IG4xID0gZmliZXJOb2lzZUZibSh1diArIHZlYzIoZXBzaWxvbiwgMC4wKSwgc2VlZE9mZnNldCk7XG4gIGZsb2F0IG4yID0gZmliZXJOb2lzZUZibSh1diAtIHZlYzIoZXBzaWxvbiwgMC4wKSwgc2VlZE9mZnNldCk7XG4gIGZsb2F0IG4zID0gZmliZXJOb2lzZUZibSh1diArIHZlYzIoMC4wLCBlcHNpbG9uKSwgc2VlZE9mZnNldCk7XG4gIGZsb2F0IG40ID0gZmliZXJOb2lzZUZibSh1diAtIHZlYzIoMC4wLCBlcHNpbG9uKSwgc2VlZE9mZnNldCk7XG4gIHJldHVybiBsZW5ndGgodmVjMihuMSAtIG4yLCBuMyAtIG40KSkgLyAoMi4wICogZXBzaWxvbik7XG59XG5gO1xuZXhwb3J0IHtcbiAgY29sb3JCYW5kaW5nRml4LFxuICBkZWNsYXJlUEksXG4gIGZpYmVyTm9pc2UsXG4gIHByb2NlZHVyYWxIYXNoMTEsXG4gIHByb2NlZHVyYWxIYXNoMjEsXG4gIHByb2NlZHVyYWxIYXNoMjIsXG4gIHJvdGF0aW9uMixcbiAgc2ltcGxleE5vaXNlLFxuICB0ZXh0dXJlUmFuZG9taXplckdCLFxuICB0ZXh0dXJlUmFuZG9taXplclJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGFkZXItdXRpbHMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/shader-utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/shaders/liquid-metal.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/shaders/liquid-metal.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LiquidMetalShapes: () => (/* binding */ LiquidMetalShapes),\n/* harmony export */   POISSON_CONFIG_OPTIMIZED: () => (/* binding */ POISSON_CONFIG_OPTIMIZED),\n/* harmony export */   liquidMetalFragmentShader: () => (/* binding */ liquidMetalFragmentShader),\n/* harmony export */   toProcessedLiquidMetal: () => (/* binding */ toProcessedLiquidMetal)\n/* harmony export */ });\n/* harmony import */ var _shader_sizing_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shader-sizing.js */ \"(ssr)/./node_modules/@paper-design/shaders/dist/shader-sizing.js\");\n/* harmony import */ var _shader_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shader-utils.js */ \"(ssr)/./node_modules/@paper-design/shaders/dist/shader-utils.js\");\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\n\nconst liquidMetalFragmentShader = `#version 300 es\nprecision mediump float;\n\nuniform sampler2D u_image;\nuniform float u_imageAspectRatio;\n\nuniform vec2 u_resolution;\nuniform float u_time;\n\nuniform vec4 u_colorBack;\nuniform vec4 u_colorTint;\n\nuniform float u_softness;\nuniform float u_repetition;\nuniform float u_shiftRed;\nuniform float u_shiftBlue;\nuniform float u_distortion;\nuniform float u_contour;\nuniform float u_angle;\n\nuniform float u_shape;\nuniform bool u_isImage;\n\n${_shader_sizing_js__WEBPACK_IMPORTED_MODULE_0__.sizingVariablesDeclaration}\n\nout vec4 fragColor;\n\n${_shader_utils_js__WEBPACK_IMPORTED_MODULE_1__.declarePI}\n${_shader_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotation2}\n${_shader_utils_js__WEBPACK_IMPORTED_MODULE_1__.simplexNoise}\n\nfloat getColorChanges(float c1, float c2, float stripe_p, vec3 w, float blur, float bump, float tint) {\n\n  float ch = mix(c2, c1, smoothstep(.0, 2. * blur, stripe_p));\n\n  float border = w[0];\n  ch = mix(ch, c2, smoothstep(border, border + 2. * blur, stripe_p));\n\n  if (u_isImage == true) {\n    bump = smoothstep(.2, .8, bump);\n  }\n  border = w[0] + .4 * (1. - bump) * w[1];\n  ch = mix(ch, c1, smoothstep(border, border + 2. * blur, stripe_p));\n\n  border = w[0] + .5 * (1. - bump) * w[1];\n  ch = mix(ch, c2, smoothstep(border, border + 2. * blur, stripe_p));\n\n  border = w[0] + w[1];\n  ch = mix(ch, c1, smoothstep(border, border + 2. * blur, stripe_p));\n\n  float gradient_t = (stripe_p - w[0] - w[1]) / w[2];\n  float gradient = mix(c1, c2, smoothstep(0., 1., gradient_t));\n  ch = mix(ch, gradient, smoothstep(border, border + .5 * blur, stripe_p));\n\n  // Tint color is applied with color burn blending\n  ch = mix(ch, 1. - min(1., (1. - ch) / max(tint, 0.0001)), u_colorTint.a);\n  return ch;\n}\n\nfloat getImgFrame(vec2 uv, float th) {\n  float frame = 1.;\n  frame *= smoothstep(0., th, uv.y);\n  frame *= 1.0 - smoothstep(1. - th, 1., uv.y);\n  frame *= smoothstep(0., th, uv.x);\n  frame *= 1.0 - smoothstep(1. - th, 1., uv.x);\n  return frame;\n}\n\nfloat blurEdge3x3(sampler2D tex, vec2 uv, vec2 dudx, vec2 dudy, float radius, float centerSample) {\n  vec2 texel = 1.0 / vec2(textureSize(tex, 0));\n  vec2 r = radius * texel;\n\n  float w1 = 1.0, w2 = 2.0, w4 = 4.0;\n  float norm = 16.0;\n  float sum = w4 * centerSample;\n\n  sum += w2 * textureGrad(tex, uv + vec2(0.0, -r.y), dudx, dudy).r;\n  sum += w2 * textureGrad(tex, uv + vec2(0.0, r.y), dudx, dudy).r;\n  sum += w2 * textureGrad(tex, uv + vec2(-r.x, 0.0), dudx, dudy).r;\n  sum += w2 * textureGrad(tex, uv + vec2(r.x, 0.0), dudx, dudy).r;\n\n  sum += w1 * textureGrad(tex, uv + vec2(-r.x, -r.y), dudx, dudy).r;\n  sum += w1 * textureGrad(tex, uv + vec2(r.x, -r.y), dudx, dudy).r;\n  sum += w1 * textureGrad(tex, uv + vec2(-r.x, r.y), dudx, dudy).r;\n  sum += w1 * textureGrad(tex, uv + vec2(r.x, r.y), dudx, dudy).r;\n\n  return sum / norm;\n}\n\nfloat lst(float edge0, float edge1, float x) {\n  return clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n}\n\nvoid main() {\n\n  const float firstFrameOffset = 2.8;\n  float t = .3 * (u_time + firstFrameOffset);\n\n  vec2 uv = v_imageUV;\n  vec2 dudx = dFdx(v_imageUV);\n  vec2 dudy = dFdy(v_imageUV);\n  vec4 img = textureGrad(u_image, uv, dudx, dudy);\n\n  if (u_isImage == false) {\n    uv = v_objectUV + .5;\n    uv.y = 1. - uv.y;\n  }\n\n  float cycleWidth = u_repetition;\n  float edge = 0.;\n  float contOffset = 1.;\n\n  vec2 rotatedUV = uv - vec2(.5);\n  float angle = (-u_angle + 70.) * PI / 180.;\n  float cosA = cos(angle);\n  float sinA = sin(angle);\n  rotatedUV = vec2(\n  rotatedUV.x * cosA - rotatedUV.y * sinA,\n  rotatedUV.x * sinA + rotatedUV.y * cosA\n  ) + vec2(.5);\n\n  if (u_isImage == true) {\n    float edgeRaw = img.r;\n    edge = blurEdge3x3(u_image, uv, dudx, dudy, 6., edgeRaw);\n    edge = pow(edge, 1.6);\n    edge *= mix(0.0, 1.0, smoothstep(0.0, 0.4, u_contour));\n  } else {\n    if (u_shape < 1.) {\n      // full-fill on canvas\n      vec2 borderUV = v_responsiveUV + .5;\n      float ratio = v_responsiveBoxGivenSize.x / v_responsiveBoxGivenSize.y;\n      vec2 mask = min(borderUV, 1. - borderUV);\n      vec2 pixel_thickness = 250. / v_responsiveBoxGivenSize;\n      float maskX = smoothstep(0.0, pixel_thickness.x, mask.x);\n      float maskY = smoothstep(0.0, pixel_thickness.y, mask.y);\n      maskX = pow(maskX, .25);\n      maskY = pow(maskY, .25);\n      edge = clamp(1. - maskX * maskY, 0., 1.);\n\n      uv = v_responsiveUV;\n      if (ratio > 1.) {\n        uv.y /= ratio;\n      } else {\n        uv.x *= ratio;\n      }\n      uv += .5;\n      uv.y = 1. - uv.y;\n\n      cycleWidth *= 2.;\n      contOffset = 1.5;\n\n    } else if (u_shape < 2.) {\n      // circle\n      vec2 shapeUV = uv - .5;\n      shapeUV *= .67;\n      edge = pow(clamp(3. * length(shapeUV), 0., 1.), 18.);\n    } else if (u_shape < 3.) {\n      // daisy\n      vec2 shapeUV = uv - .5;\n      shapeUV *= 1.68;\n\n      float r = length(shapeUV) * 2.;\n      float a = atan(shapeUV.y, shapeUV.x) + .2;\n      r *= (1. + .05 * sin(3. * a + 2. * t));\n      float f = abs(cos(a * 3.));\n      edge = smoothstep(f, f + .7, r);\n      edge *= edge;\n\n      uv *= .8;\n      cycleWidth *= 1.6;\n\n    } else if (u_shape < 4.) {\n      // diamond\n      vec2 shapeUV = uv - .5;\n      shapeUV = rotate(shapeUV, .25 * PI);\n      shapeUV *= 1.42;\n      shapeUV += .5;\n      vec2 mask = min(shapeUV, 1. - shapeUV);\n      vec2 pixel_thickness = vec2(.15);\n      float maskX = smoothstep(0.0, pixel_thickness.x, mask.x);\n      float maskY = smoothstep(0.0, pixel_thickness.y, mask.y);\n      maskX = pow(maskX, .25);\n      maskY = pow(maskY, .25);\n      edge = clamp(1. - maskX * maskY, 0., 1.);\n    } else if (u_shape < 5.) {\n      // metaballs\n      vec2 shapeUV = uv - .5;\n      shapeUV *= 1.3;\n      edge = 0.;\n      for (int i = 0; i < 5; i++) {\n        float fi = float(i);\n        float speed = 1.5 + 2./3. * sin(fi * 12.345);\n        float angle = -fi * 1.5;\n        vec2 dir1 = vec2(cos(angle), sin(angle));\n        vec2 dir2 = vec2(cos(angle + 1.57), sin(angle + 1.));\n        vec2 traj = .4 * (dir1 * sin(t * speed + fi * 1.23) + dir2 * cos(t * (speed * 0.7) + fi * 2.17));\n        float d = length(shapeUV + traj);\n        edge += pow(1.0 - clamp(d, 0.0, 1.0), 4.0);\n      }\n      edge = 1. - smoothstep(.65, .9, edge);\n      edge = pow(edge, 4.);\n    }\n\n    edge = mix(smoothstep(.9 - 2. * fwidth(edge), .9, edge), edge, smoothstep(0.0, 0.4, u_contour));\n\n  }\n\n  float opacity = 0.;\n  if (u_isImage == true) {\n    opacity = img.g;\n    float frame = getImgFrame(v_imageUV, 0.);\n    opacity *= frame;\n  } else {\n    opacity = 1. - smoothstep(.9 - 2. * fwidth(edge), .9, edge);\n    if (u_shape < 2.) {\n      edge = 1.2 * edge;\n    } else if (u_shape < 5.) {\n      edge = 1.8 * pow(edge, 1.5);\n    }\n  }\n\n  float diagBLtoTR = rotatedUV.x - rotatedUV.y;\n  float diagTLtoBR = rotatedUV.x + rotatedUV.y;\n\n  vec3 color = vec3(0.);\n  vec3 color1 = vec3(.98, 0.98, 1.);\n  vec3 color2 = vec3(.1, .1, .1 + .1 * smoothstep(.7, 1.3, diagTLtoBR));\n\n  vec2 grad_uv = uv - .5;\n\n  float dist = length(grad_uv + vec2(0., .2 * diagBLtoTR));\n  grad_uv = rotate(grad_uv, (.25 - .2 * diagBLtoTR) * PI);\n  float direction = grad_uv.x;\n\n  float bump = pow(1.8 * dist, 1.2);\n  bump = 1. - bump;\n  bump *= pow(uv.y, .3);\n\n\n  float thin_strip_1_ratio = .12 / cycleWidth * (1. - .4 * bump);\n  float thin_strip_2_ratio = .07 / cycleWidth * (1. + .4 * bump);\n  float wide_strip_ratio = (1. - thin_strip_1_ratio - thin_strip_2_ratio);\n\n  float thin_strip_1_width = cycleWidth * thin_strip_1_ratio;\n  float thin_strip_2_width = cycleWidth * thin_strip_2_ratio;\n\n  float noise = snoise(uv - t);\n\n  edge += (1. - edge) * u_distortion * noise;\n\n  direction += diagBLtoTR;\n  float contour = 0.;\n  direction -= 2. * noise * diagBLtoTR * (smoothstep(0., 1., edge) * (1.0 - smoothstep(0., 1., edge)));\n  direction *= mix(1., 1. - edge, smoothstep(.5, 1., u_contour));\n  direction -= 1.7 * edge * smoothstep(.5, 1., u_contour);\n  direction += .2 * pow(u_contour, 4.) * (1.0 - smoothstep(0., 1., edge));\n\n  bump *= clamp(pow(uv.y, .1), .3, 1.);\n  direction *= (.1 + (1.1 - edge) * bump);\n\n  direction *= (.4 + .6 * (1.0 - smoothstep(.5, 1., edge)));\n  direction += .18 * (smoothstep(.1, .2, uv.y) * (1.0 - smoothstep(.2, .4, uv.y)));\n  direction += .03 * (smoothstep(.1, .2, 1. - uv.y) * (1.0 - smoothstep(.2, .4, 1. - uv.y)));\n\n  direction *= (.5 + .5 * pow(uv.y, 2.));\n  direction *= cycleWidth;\n  direction -= t;\n\n\n  float colorDispersion = (1. - bump);\n  colorDispersion = clamp(colorDispersion, 0., 1.);\n  float dispersionRed = colorDispersion;\n  dispersionRed += .03 * bump * noise;\n  dispersionRed += 5. * (smoothstep(-.1, .2, uv.y) * (1.0 - smoothstep(.1, .5, uv.y))) * (smoothstep(.4, .6, bump) * (1.0 - smoothstep(.4, 1., bump)));\n  dispersionRed -= diagBLtoTR;\n\n  float dispersionBlue = colorDispersion;\n  dispersionBlue *= 1.3;\n  dispersionBlue += (smoothstep(0., .4, uv.y) * (1.0 - smoothstep(.1, .8, uv.y))) * (smoothstep(.4, .6, bump) * (1.0 - smoothstep(.4, .8, bump)));\n  dispersionBlue -= .2 * edge;\n\n  dispersionRed *= (u_shiftRed / 20.);\n  dispersionBlue *= (u_shiftBlue / 20.);\n\n  float blur = 0.;\n  float rExtraBlur = 0.;\n  float gExtraBlur = 0.;\n  if (u_isImage == true) {\n    float softness = 0.05 * u_softness;\n    blur = softness + .5 * smoothstep(1., 10., u_repetition) * smoothstep(.0, 1., edge);\n    float smallCanvasT = 1.0 - smoothstep(100., 500., min(u_resolution.x, u_resolution.y));\n    blur += smallCanvasT * smoothstep(.0, 1., edge);\n    rExtraBlur = softness * (0.05 + .1 * (u_shiftRed / 20.) * bump);\n    gExtraBlur = softness * 0.05 / max(0.001, abs(1. - diagBLtoTR));\n  } else {\n    blur = u_softness / 15. + .3 * contour;\n  }\n\n  vec3 w = vec3(thin_strip_1_width, thin_strip_2_width, wide_strip_ratio);\n  w[1] -= .02 * smoothstep(.0, 1., edge + bump);\n  float stripe_r = fract(direction + dispersionRed);\n  float r = getColorChanges(color1.r, color2.r, stripe_r, w, blur + fwidth(stripe_r) + rExtraBlur, bump, u_colorTint.r);\n  float stripe_g = fract(direction);\n  float g = getColorChanges(color1.g, color2.g, stripe_g, w, blur + fwidth(stripe_g) + gExtraBlur, bump, u_colorTint.g);\n  float stripe_b = fract(direction - dispersionBlue);\n  float b = getColorChanges(color1.b, color2.b, stripe_b, w, blur + fwidth(stripe_b), bump, u_colorTint.b);\n\n  color = vec3(r, g, b);\n  color *= opacity;\n\n  vec3 bgColor = u_colorBack.rgb * u_colorBack.a;\n  color = color + bgColor * (1. - opacity);\n  opacity = opacity + u_colorBack.a * (1. - opacity);\n\n  ${_shader_utils_js__WEBPACK_IMPORTED_MODULE_1__.colorBandingFix}\n\n  fragColor = vec4(color, opacity);\n}\n`;\nconst POISSON_CONFIG_OPTIMIZED = {\n  measurePerformance: false,\n  // Set to true to see performance metrics\n  workingSize: 512,\n  // Size to solve Poisson at (will upscale to original size)\n  iterations: 40\n  // SOR converges ~2-20x faster than standard Gauss-Seidel\n};\nfunction toProcessedLiquidMetal(file) {\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n  const isBlob = typeof file === \"string\" && file.startsWith(\"blob:\");\n  return new Promise((resolve, reject) => {\n    if (!file || !ctx) {\n      reject(new Error(\"Invalid file or canvas context\"));\n      return;\n    }\n    const blobContentTypePromise = isBlob && fetch(file).then((res) => res.headers.get(\"Content-Type\"));\n    const img = new Image();\n    img.crossOrigin = \"anonymous\";\n    const totalStartTime = performance.now();\n    img.onload = async () => {\n      let isSVG;\n      const blobContentType = await blobContentTypePromise;\n      if (blobContentType) {\n        isSVG = blobContentType === \"image/svg+xml\";\n      } else if (typeof file === \"string\") {\n        isSVG = file.endsWith(\".svg\") || file.startsWith(\"data:image/svg+xml\");\n      } else {\n        isSVG = file.type === \"image/svg+xml\";\n      }\n      let originalWidth = img.width || img.naturalWidth;\n      let originalHeight = img.height || img.naturalHeight;\n      if (isSVG) {\n        const svgMaxSize = 4096;\n        const aspectRatio = originalWidth / originalHeight;\n        if (originalWidth > originalHeight) {\n          originalWidth = svgMaxSize;\n          originalHeight = svgMaxSize / aspectRatio;\n        } else {\n          originalHeight = svgMaxSize;\n          originalWidth = svgMaxSize * aspectRatio;\n        }\n        img.width = originalWidth;\n        img.height = originalHeight;\n      }\n      const minDimension = Math.min(originalWidth, originalHeight);\n      const targetSize = POISSON_CONFIG_OPTIMIZED.workingSize;\n      const scaleFactor = targetSize / minDimension;\n      const width = Math.round(originalWidth * scaleFactor);\n      const height = Math.round(originalHeight * scaleFactor);\n      if (POISSON_CONFIG_OPTIMIZED.measurePerformance) {\n        console.log(`[Processing Mode]`);\n        console.log(`  Original: ${originalWidth}\\xD7${originalHeight}`);\n        console.log(`  Working: ${width}\\xD7${height} (${(scaleFactor * 100).toFixed(1)}% scale)`);\n        if (scaleFactor < 1) {\n          console.log(`  Speedup: ~${Math.round(1 / (scaleFactor * scaleFactor))}\\xD7`);\n        }\n      }\n      canvas.width = originalWidth;\n      canvas.height = originalHeight;\n      const shapeCanvas = document.createElement(\"canvas\");\n      shapeCanvas.width = width;\n      shapeCanvas.height = height;\n      const shapeCtx = shapeCanvas.getContext(\"2d\");\n      shapeCtx.drawImage(img, 0, 0, width, height);\n      const startMask = performance.now();\n      const shapeImageData = shapeCtx.getImageData(0, 0, width, height);\n      const data = shapeImageData.data;\n      const shapeMask = new Uint8Array(width * height);\n      const boundaryMask = new Uint8Array(width * height);\n      let shapePixelCount = 0;\n      for (let i = 0, idx = 0; i < data.length; i += 4, idx++) {\n        const a = data[i + 3];\n        const isShape = a === 0 ? 0 : 1;\n        shapeMask[idx] = isShape;\n        shapePixelCount += isShape;\n      }\n      const boundaryIndices = [];\n      const interiorIndices = [];\n      for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n          const idx = y * width + x;\n          if (!shapeMask[idx]) continue;\n          let isBoundary = false;\n          if (x === 0 || x === width - 1 || y === 0 || y === height - 1) {\n            isBoundary = true;\n          } else {\n            isBoundary = !shapeMask[idx - 1] || // left\n            !shapeMask[idx + 1] || // right\n            !shapeMask[idx - width] || // top\n            !shapeMask[idx + width] || // bottom\n            !shapeMask[idx - width - 1] || // top-left\n            !shapeMask[idx - width + 1] || // top-right\n            !shapeMask[idx + width - 1] || // bottom-left\n            !shapeMask[idx + width + 1];\n          }\n          if (isBoundary) {\n            boundaryMask[idx] = 1;\n            boundaryIndices.push(idx);\n          } else {\n            interiorIndices.push(idx);\n          }\n        }\n      }\n      if (POISSON_CONFIG_OPTIMIZED.measurePerformance) {\n        console.log(`[Mask Building] Time: ${(performance.now() - startMask).toFixed(2)}ms`);\n        console.log(\n          `  Shape pixels: ${shapePixelCount} / ${width * height} (${(shapePixelCount / (width * height) * 100).toFixed(1)}%)`\n        );\n        console.log(`  Interior pixels: ${interiorIndices.length}`);\n        console.log(`  Boundary pixels: ${boundaryIndices.length}`);\n      }\n      const sparseData = buildSparseData(\n        shapeMask,\n        boundaryMask,\n        new Uint32Array(interiorIndices),\n        new Uint32Array(boundaryIndices),\n        width,\n        height\n      );\n      const startSolve = performance.now();\n      const u = solvePoissonSparse(sparseData, shapeMask, boundaryMask, width, height);\n      if (POISSON_CONFIG_OPTIMIZED.measurePerformance) {\n        console.log(`[Poisson Solve] Time: ${(performance.now() - startSolve).toFixed(2)}ms`);\n      }\n      let maxVal = 0;\n      let finalImageData;\n      for (let i = 0; i < interiorIndices.length; i++) {\n        const idx = interiorIndices[i];\n        if (u[idx] > maxVal) maxVal = u[idx];\n      }\n      const tempCanvas = document.createElement(\"canvas\");\n      tempCanvas.width = width;\n      tempCanvas.height = height;\n      const tempCtx = tempCanvas.getContext(\"2d\");\n      const tempImg = tempCtx.createImageData(width, height);\n      for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n          const idx = y * width + x;\n          const px = idx * 4;\n          if (!shapeMask[idx]) {\n            tempImg.data[px] = 255;\n            tempImg.data[px + 1] = 255;\n            tempImg.data[px + 2] = 255;\n            tempImg.data[px + 3] = 0;\n          } else {\n            const poissonRatio = u[idx] / maxVal;\n            const gray = 255 * (1 - poissonRatio);\n            tempImg.data[px] = gray;\n            tempImg.data[px + 1] = gray;\n            tempImg.data[px + 2] = gray;\n            tempImg.data[px + 3] = 255;\n          }\n        }\n      }\n      tempCtx.putImageData(tempImg, 0, 0);\n      ctx.imageSmoothingEnabled = true;\n      ctx.imageSmoothingQuality = \"high\";\n      ctx.drawImage(tempCanvas, 0, 0, width, height, 0, 0, originalWidth, originalHeight);\n      const outImg = ctx.getImageData(0, 0, originalWidth, originalHeight);\n      const originalCanvas = document.createElement(\"canvas\");\n      originalCanvas.width = originalWidth;\n      originalCanvas.height = originalHeight;\n      const originalCtx = originalCanvas.getContext(\"2d\");\n      originalCtx.drawImage(img, 0, 0, originalWidth, originalHeight);\n      const originalData = originalCtx.getImageData(0, 0, originalWidth, originalHeight);\n      for (let i = 0; i < outImg.data.length; i += 4) {\n        const a = originalData.data[i + 3];\n        const upscaledAlpha = outImg.data[i + 3];\n        if (a === 0) {\n          outImg.data[i] = 255;\n          outImg.data[i + 1] = 0;\n        } else {\n          outImg.data[i] = upscaledAlpha === 0 ? 0 : outImg.data[i];\n          outImg.data[i + 1] = a;\n        }\n        outImg.data[i + 2] = 255;\n        outImg.data[i + 3] = 255;\n      }\n      ctx.putImageData(outImg, 0, 0);\n      finalImageData = outImg;\n      canvas.toBlob((blob) => {\n        if (!blob) {\n          reject(new Error(\"Failed to create PNG blob\"));\n          return;\n        }\n        if (POISSON_CONFIG_OPTIMIZED.measurePerformance) {\n          const totalTime = performance.now() - totalStartTime;\n          console.log(`[Total Processing Time] ${totalTime.toFixed(2)}ms`);\n          if (scaleFactor < 1) {\n            const estimatedFullResTime = totalTime * Math.pow(originalWidth * originalHeight / (width * height), 1.5);\n            console.log(`[Estimated time at full resolution] ~${estimatedFullResTime.toFixed(0)}ms`);\n            console.log(\n              `[Time saved] ~${(estimatedFullResTime - totalTime).toFixed(0)}ms (${Math.round(estimatedFullResTime / totalTime)}\\xD7 faster)`\n            );\n          }\n        }\n        resolve({\n          imageData: finalImageData,\n          pngBlob: blob\n        });\n      }, \"image/png\");\n    };\n    img.onerror = () => reject(new Error(\"Failed to load image\"));\n    img.src = typeof file === \"string\" ? file : URL.createObjectURL(file);\n  });\n}\nfunction buildSparseData(shapeMask, boundaryMask, interiorPixels, boundaryPixels, width, height) {\n  const pixelCount = interiorPixels.length;\n  const neighborIndices = new Int32Array(pixelCount * 4);\n  for (let i = 0; i < pixelCount; i++) {\n    const idx = interiorPixels[i];\n    const x = idx % width;\n    const y = Math.floor(idx / width);\n    neighborIndices[i * 4 + 0] = x < width - 1 && shapeMask[idx + 1] ? idx + 1 : -1;\n    neighborIndices[i * 4 + 1] = x > 0 && shapeMask[idx - 1] ? idx - 1 : -1;\n    neighborIndices[i * 4 + 2] = y > 0 && shapeMask[idx - width] ? idx - width : -1;\n    neighborIndices[i * 4 + 3] = y < height - 1 && shapeMask[idx + width] ? idx + width : -1;\n  }\n  return {\n    interiorPixels,\n    boundaryPixels,\n    pixelCount,\n    neighborIndices\n  };\n}\nfunction solvePoissonSparse(sparseData, shapeMask, boundaryMask, width, height) {\n  const ITERATIONS = POISSON_CONFIG_OPTIMIZED.iterations;\n  const C = 0.01;\n  const u = new Float32Array(width * height);\n  const { interiorPixels, neighborIndices, pixelCount } = sparseData;\n  const startTime = performance.now();\n  const omega = 1.9;\n  const redPixels = [];\n  const blackPixels = [];\n  for (let i = 0; i < pixelCount; i++) {\n    const idx = interiorPixels[i];\n    const x = idx % width;\n    const y = Math.floor(idx / width);\n    if ((x + y) % 2 === 0) {\n      redPixels.push(i);\n    } else {\n      blackPixels.push(i);\n    }\n  }\n  for (let iter = 0; iter < ITERATIONS; iter++) {\n    for (const i of redPixels) {\n      const idx = interiorPixels[i];\n      const eastIdx = neighborIndices[i * 4 + 0];\n      const westIdx = neighborIndices[i * 4 + 1];\n      const northIdx = neighborIndices[i * 4 + 2];\n      const southIdx = neighborIndices[i * 4 + 3];\n      let sumN = 0;\n      if (eastIdx >= 0) sumN += u[eastIdx];\n      if (westIdx >= 0) sumN += u[westIdx];\n      if (northIdx >= 0) sumN += u[northIdx];\n      if (southIdx >= 0) sumN += u[southIdx];\n      const newValue = (C + sumN) / 4;\n      u[idx] = omega * newValue + (1 - omega) * u[idx];\n    }\n    for (const i of blackPixels) {\n      const idx = interiorPixels[i];\n      const eastIdx = neighborIndices[i * 4 + 0];\n      const westIdx = neighborIndices[i * 4 + 1];\n      const northIdx = neighborIndices[i * 4 + 2];\n      const southIdx = neighborIndices[i * 4 + 3];\n      let sumN = 0;\n      if (eastIdx >= 0) sumN += u[eastIdx];\n      if (westIdx >= 0) sumN += u[westIdx];\n      if (northIdx >= 0) sumN += u[northIdx];\n      if (southIdx >= 0) sumN += u[southIdx];\n      const newValue = (C + sumN) / 4;\n      u[idx] = omega * newValue + (1 - omega) * u[idx];\n    }\n  }\n  if (POISSON_CONFIG_OPTIMIZED.measurePerformance) {\n    const elapsed = performance.now() - startTime;\n    console.log(`[Optimized Poisson Solver (SOR \\u03C9=${omega})]`);\n    console.log(`  Working size: ${width}\\xD7${height}`);\n    console.log(`  Iterations: ${ITERATIONS}`);\n    console.log(`  Time: ${elapsed.toFixed(2)}ms`);\n    console.log(`  Interior pixels processed: ${pixelCount}`);\n    console.log(`  Speed: ${(ITERATIONS * pixelCount / (elapsed * 1e3)).toFixed(2)} Mpixels/sec`);\n  }\n  return u;\n}\nconst LiquidMetalShapes = {\n  none: 0,\n  circle: 1,\n  daisy: 2,\n  diamond: 3,\n  metaballs: 4\n};\n\n//# sourceMappingURL=liquid-metal.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVycy9saXF1aWQtbWV0YWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRWlFO0FBQ3dCO0FBQ3pGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFLHlFQUEwQjs7QUFFNUI7O0FBRUEsRUFBRSx1REFBUztBQUNYLEVBQUUsdURBQVM7QUFDWCxFQUFFLDBEQUFZOztBQUVkOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLDZEQUFlOztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGNBQWMsTUFBTSxlQUFlO0FBQ3RFLGtDQUFrQyxNQUFNLE1BQU0sUUFBUSxHQUFHLCtCQUErQjtBQUN4RjtBQUNBLHFDQUFxQyw0Q0FBNEM7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlCQUFpQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsMkNBQTJDO0FBQ3hGO0FBQ0EsNkJBQTZCLGlCQUFpQixJQUFJLGdCQUFnQixHQUFHLHNEQUFzRDtBQUMzSDtBQUNBLDBDQUEwQyx1QkFBdUI7QUFDakUsMENBQTBDLHVCQUF1QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsNENBQTRDO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0QkFBNEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0JBQXdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHFCQUFxQjtBQUN0RTtBQUNBO0FBQ0EsZ0VBQWdFLGdDQUFnQztBQUNoRztBQUNBLCtCQUErQiw4Q0FBOEMsTUFBTSw2Q0FBNkM7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4Q0FBOEM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxNQUFNO0FBQy9ELG1DQUFtQyxNQUFNLE1BQU0sT0FBTztBQUN0RCxpQ0FBaUMsV0FBVztBQUM1QywyQkFBMkIsbUJBQW1CO0FBQzlDLGdEQUFnRCxXQUFXO0FBQzNELDRCQUE0Qix3REFBd0Q7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9AcGFwZXItZGVzaWduL3NoYWRlcnMvZGlzdC9zaGFkZXJzL2xpcXVpZC1tZXRhbC5qcz82NTkwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiAgICAgICAgICAgICAgICAgICAgUGFwZXIgU2hhZGVycyAgICAgICAgICAgICAgICAgICAgKlxuICogICAgICAgaHR0cHM6Ly9naXRodWIuY29tL3BhcGVyLWRlc2lnbi9zaGFkZXJzICAgICAgICpcbiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqL1xuXG5pbXBvcnQgeyBzaXppbmdWYXJpYWJsZXNEZWNsYXJhdGlvbiB9IGZyb20gXCIuLi9zaGFkZXItc2l6aW5nLmpzXCI7XG5pbXBvcnQgeyBkZWNsYXJlUEksIHJvdGF0aW9uMiwgc2ltcGxleE5vaXNlLCBjb2xvckJhbmRpbmdGaXggfSBmcm9tIFwiLi4vc2hhZGVyLXV0aWxzLmpzXCI7XG5jb25zdCBsaXF1aWRNZXRhbEZyYWdtZW50U2hhZGVyID0gYCN2ZXJzaW9uIDMwMCBlc1xucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG5cbnVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7XG51bmlmb3JtIGZsb2F0IHVfaW1hZ2VBc3BlY3RSYXRpbztcblxudW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjtcbnVuaWZvcm0gZmxvYXQgdV90aW1lO1xuXG51bmlmb3JtIHZlYzQgdV9jb2xvckJhY2s7XG51bmlmb3JtIHZlYzQgdV9jb2xvclRpbnQ7XG5cbnVuaWZvcm0gZmxvYXQgdV9zb2Z0bmVzcztcbnVuaWZvcm0gZmxvYXQgdV9yZXBldGl0aW9uO1xudW5pZm9ybSBmbG9hdCB1X3NoaWZ0UmVkO1xudW5pZm9ybSBmbG9hdCB1X3NoaWZ0Qmx1ZTtcbnVuaWZvcm0gZmxvYXQgdV9kaXN0b3J0aW9uO1xudW5pZm9ybSBmbG9hdCB1X2NvbnRvdXI7XG51bmlmb3JtIGZsb2F0IHVfYW5nbGU7XG5cbnVuaWZvcm0gZmxvYXQgdV9zaGFwZTtcbnVuaWZvcm0gYm9vbCB1X2lzSW1hZ2U7XG5cbiR7c2l6aW5nVmFyaWFibGVzRGVjbGFyYXRpb259XG5cbm91dCB2ZWM0IGZyYWdDb2xvcjtcblxuJHtkZWNsYXJlUEl9XG4ke3JvdGF0aW9uMn1cbiR7c2ltcGxleE5vaXNlfVxuXG5mbG9hdCBnZXRDb2xvckNoYW5nZXMoZmxvYXQgYzEsIGZsb2F0IGMyLCBmbG9hdCBzdHJpcGVfcCwgdmVjMyB3LCBmbG9hdCBibHVyLCBmbG9hdCBidW1wLCBmbG9hdCB0aW50KSB7XG5cbiAgZmxvYXQgY2ggPSBtaXgoYzIsIGMxLCBzbW9vdGhzdGVwKC4wLCAyLiAqIGJsdXIsIHN0cmlwZV9wKSk7XG5cbiAgZmxvYXQgYm9yZGVyID0gd1swXTtcbiAgY2ggPSBtaXgoY2gsIGMyLCBzbW9vdGhzdGVwKGJvcmRlciwgYm9yZGVyICsgMi4gKiBibHVyLCBzdHJpcGVfcCkpO1xuXG4gIGlmICh1X2lzSW1hZ2UgPT0gdHJ1ZSkge1xuICAgIGJ1bXAgPSBzbW9vdGhzdGVwKC4yLCAuOCwgYnVtcCk7XG4gIH1cbiAgYm9yZGVyID0gd1swXSArIC40ICogKDEuIC0gYnVtcCkgKiB3WzFdO1xuICBjaCA9IG1peChjaCwgYzEsIHNtb290aHN0ZXAoYm9yZGVyLCBib3JkZXIgKyAyLiAqIGJsdXIsIHN0cmlwZV9wKSk7XG5cbiAgYm9yZGVyID0gd1swXSArIC41ICogKDEuIC0gYnVtcCkgKiB3WzFdO1xuICBjaCA9IG1peChjaCwgYzIsIHNtb290aHN0ZXAoYm9yZGVyLCBib3JkZXIgKyAyLiAqIGJsdXIsIHN0cmlwZV9wKSk7XG5cbiAgYm9yZGVyID0gd1swXSArIHdbMV07XG4gIGNoID0gbWl4KGNoLCBjMSwgc21vb3Roc3RlcChib3JkZXIsIGJvcmRlciArIDIuICogYmx1ciwgc3RyaXBlX3ApKTtcblxuICBmbG9hdCBncmFkaWVudF90ID0gKHN0cmlwZV9wIC0gd1swXSAtIHdbMV0pIC8gd1syXTtcbiAgZmxvYXQgZ3JhZGllbnQgPSBtaXgoYzEsIGMyLCBzbW9vdGhzdGVwKDAuLCAxLiwgZ3JhZGllbnRfdCkpO1xuICBjaCA9IG1peChjaCwgZ3JhZGllbnQsIHNtb290aHN0ZXAoYm9yZGVyLCBib3JkZXIgKyAuNSAqIGJsdXIsIHN0cmlwZV9wKSk7XG5cbiAgLy8gVGludCBjb2xvciBpcyBhcHBsaWVkIHdpdGggY29sb3IgYnVybiBibGVuZGluZ1xuICBjaCA9IG1peChjaCwgMS4gLSBtaW4oMS4sICgxLiAtIGNoKSAvIG1heCh0aW50LCAwLjAwMDEpKSwgdV9jb2xvclRpbnQuYSk7XG4gIHJldHVybiBjaDtcbn1cblxuZmxvYXQgZ2V0SW1nRnJhbWUodmVjMiB1diwgZmxvYXQgdGgpIHtcbiAgZmxvYXQgZnJhbWUgPSAxLjtcbiAgZnJhbWUgKj0gc21vb3Roc3RlcCgwLiwgdGgsIHV2LnkpO1xuICBmcmFtZSAqPSAxLjAgLSBzbW9vdGhzdGVwKDEuIC0gdGgsIDEuLCB1di55KTtcbiAgZnJhbWUgKj0gc21vb3Roc3RlcCgwLiwgdGgsIHV2LngpO1xuICBmcmFtZSAqPSAxLjAgLSBzbW9vdGhzdGVwKDEuIC0gdGgsIDEuLCB1di54KTtcbiAgcmV0dXJuIGZyYW1lO1xufVxuXG5mbG9hdCBibHVyRWRnZTN4MyhzYW1wbGVyMkQgdGV4LCB2ZWMyIHV2LCB2ZWMyIGR1ZHgsIHZlYzIgZHVkeSwgZmxvYXQgcmFkaXVzLCBmbG9hdCBjZW50ZXJTYW1wbGUpIHtcbiAgdmVjMiB0ZXhlbCA9IDEuMCAvIHZlYzIodGV4dHVyZVNpemUodGV4LCAwKSk7XG4gIHZlYzIgciA9IHJhZGl1cyAqIHRleGVsO1xuXG4gIGZsb2F0IHcxID0gMS4wLCB3MiA9IDIuMCwgdzQgPSA0LjA7XG4gIGZsb2F0IG5vcm0gPSAxNi4wO1xuICBmbG9hdCBzdW0gPSB3NCAqIGNlbnRlclNhbXBsZTtcblxuICBzdW0gKz0gdzIgKiB0ZXh0dXJlR3JhZCh0ZXgsIHV2ICsgdmVjMigwLjAsIC1yLnkpLCBkdWR4LCBkdWR5KS5yO1xuICBzdW0gKz0gdzIgKiB0ZXh0dXJlR3JhZCh0ZXgsIHV2ICsgdmVjMigwLjAsIHIueSksIGR1ZHgsIGR1ZHkpLnI7XG4gIHN1bSArPSB3MiAqIHRleHR1cmVHcmFkKHRleCwgdXYgKyB2ZWMyKC1yLngsIDAuMCksIGR1ZHgsIGR1ZHkpLnI7XG4gIHN1bSArPSB3MiAqIHRleHR1cmVHcmFkKHRleCwgdXYgKyB2ZWMyKHIueCwgMC4wKSwgZHVkeCwgZHVkeSkucjtcblxuICBzdW0gKz0gdzEgKiB0ZXh0dXJlR3JhZCh0ZXgsIHV2ICsgdmVjMigtci54LCAtci55KSwgZHVkeCwgZHVkeSkucjtcbiAgc3VtICs9IHcxICogdGV4dHVyZUdyYWQodGV4LCB1diArIHZlYzIoci54LCAtci55KSwgZHVkeCwgZHVkeSkucjtcbiAgc3VtICs9IHcxICogdGV4dHVyZUdyYWQodGV4LCB1diArIHZlYzIoLXIueCwgci55KSwgZHVkeCwgZHVkeSkucjtcbiAgc3VtICs9IHcxICogdGV4dHVyZUdyYWQodGV4LCB1diArIHZlYzIoci54LCByLnkpLCBkdWR4LCBkdWR5KS5yO1xuXG4gIHJldHVybiBzdW0gLyBub3JtO1xufVxuXG5mbG9hdCBsc3QoZmxvYXQgZWRnZTAsIGZsb2F0IGVkZ2UxLCBmbG9hdCB4KSB7XG4gIHJldHVybiBjbGFtcCgoeCAtIGVkZ2UwKSAvIChlZGdlMSAtIGVkZ2UwKSwgMC4wLCAxLjApO1xufVxuXG52b2lkIG1haW4oKSB7XG5cbiAgY29uc3QgZmxvYXQgZmlyc3RGcmFtZU9mZnNldCA9IDIuODtcbiAgZmxvYXQgdCA9IC4zICogKHVfdGltZSArIGZpcnN0RnJhbWVPZmZzZXQpO1xuXG4gIHZlYzIgdXYgPSB2X2ltYWdlVVY7XG4gIHZlYzIgZHVkeCA9IGRGZHgodl9pbWFnZVVWKTtcbiAgdmVjMiBkdWR5ID0gZEZkeSh2X2ltYWdlVVYpO1xuICB2ZWM0IGltZyA9IHRleHR1cmVHcmFkKHVfaW1hZ2UsIHV2LCBkdWR4LCBkdWR5KTtcblxuICBpZiAodV9pc0ltYWdlID09IGZhbHNlKSB7XG4gICAgdXYgPSB2X29iamVjdFVWICsgLjU7XG4gICAgdXYueSA9IDEuIC0gdXYueTtcbiAgfVxuXG4gIGZsb2F0IGN5Y2xlV2lkdGggPSB1X3JlcGV0aXRpb247XG4gIGZsb2F0IGVkZ2UgPSAwLjtcbiAgZmxvYXQgY29udE9mZnNldCA9IDEuO1xuXG4gIHZlYzIgcm90YXRlZFVWID0gdXYgLSB2ZWMyKC41KTtcbiAgZmxvYXQgYW5nbGUgPSAoLXVfYW5nbGUgKyA3MC4pICogUEkgLyAxODAuO1xuICBmbG9hdCBjb3NBID0gY29zKGFuZ2xlKTtcbiAgZmxvYXQgc2luQSA9IHNpbihhbmdsZSk7XG4gIHJvdGF0ZWRVViA9IHZlYzIoXG4gIHJvdGF0ZWRVVi54ICogY29zQSAtIHJvdGF0ZWRVVi55ICogc2luQSxcbiAgcm90YXRlZFVWLnggKiBzaW5BICsgcm90YXRlZFVWLnkgKiBjb3NBXG4gICkgKyB2ZWMyKC41KTtcblxuICBpZiAodV9pc0ltYWdlID09IHRydWUpIHtcbiAgICBmbG9hdCBlZGdlUmF3ID0gaW1nLnI7XG4gICAgZWRnZSA9IGJsdXJFZGdlM3gzKHVfaW1hZ2UsIHV2LCBkdWR4LCBkdWR5LCA2LiwgZWRnZVJhdyk7XG4gICAgZWRnZSA9IHBvdyhlZGdlLCAxLjYpO1xuICAgIGVkZ2UgKj0gbWl4KDAuMCwgMS4wLCBzbW9vdGhzdGVwKDAuMCwgMC40LCB1X2NvbnRvdXIpKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodV9zaGFwZSA8IDEuKSB7XG4gICAgICAvLyBmdWxsLWZpbGwgb24gY2FudmFzXG4gICAgICB2ZWMyIGJvcmRlclVWID0gdl9yZXNwb25zaXZlVVYgKyAuNTtcbiAgICAgIGZsb2F0IHJhdGlvID0gdl9yZXNwb25zaXZlQm94R2l2ZW5TaXplLnggLyB2X3Jlc3BvbnNpdmVCb3hHaXZlblNpemUueTtcbiAgICAgIHZlYzIgbWFzayA9IG1pbihib3JkZXJVViwgMS4gLSBib3JkZXJVVik7XG4gICAgICB2ZWMyIHBpeGVsX3RoaWNrbmVzcyA9IDI1MC4gLyB2X3Jlc3BvbnNpdmVCb3hHaXZlblNpemU7XG4gICAgICBmbG9hdCBtYXNrWCA9IHNtb290aHN0ZXAoMC4wLCBwaXhlbF90aGlja25lc3MueCwgbWFzay54KTtcbiAgICAgIGZsb2F0IG1hc2tZID0gc21vb3Roc3RlcCgwLjAsIHBpeGVsX3RoaWNrbmVzcy55LCBtYXNrLnkpO1xuICAgICAgbWFza1ggPSBwb3cobWFza1gsIC4yNSk7XG4gICAgICBtYXNrWSA9IHBvdyhtYXNrWSwgLjI1KTtcbiAgICAgIGVkZ2UgPSBjbGFtcCgxLiAtIG1hc2tYICogbWFza1ksIDAuLCAxLik7XG5cbiAgICAgIHV2ID0gdl9yZXNwb25zaXZlVVY7XG4gICAgICBpZiAocmF0aW8gPiAxLikge1xuICAgICAgICB1di55IC89IHJhdGlvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXYueCAqPSByYXRpbztcbiAgICAgIH1cbiAgICAgIHV2ICs9IC41O1xuICAgICAgdXYueSA9IDEuIC0gdXYueTtcblxuICAgICAgY3ljbGVXaWR0aCAqPSAyLjtcbiAgICAgIGNvbnRPZmZzZXQgPSAxLjU7XG5cbiAgICB9IGVsc2UgaWYgKHVfc2hhcGUgPCAyLikge1xuICAgICAgLy8gY2lyY2xlXG4gICAgICB2ZWMyIHNoYXBlVVYgPSB1diAtIC41O1xuICAgICAgc2hhcGVVViAqPSAuNjc7XG4gICAgICBlZGdlID0gcG93KGNsYW1wKDMuICogbGVuZ3RoKHNoYXBlVVYpLCAwLiwgMS4pLCAxOC4pO1xuICAgIH0gZWxzZSBpZiAodV9zaGFwZSA8IDMuKSB7XG4gICAgICAvLyBkYWlzeVxuICAgICAgdmVjMiBzaGFwZVVWID0gdXYgLSAuNTtcbiAgICAgIHNoYXBlVVYgKj0gMS42ODtcblxuICAgICAgZmxvYXQgciA9IGxlbmd0aChzaGFwZVVWKSAqIDIuO1xuICAgICAgZmxvYXQgYSA9IGF0YW4oc2hhcGVVVi55LCBzaGFwZVVWLngpICsgLjI7XG4gICAgICByICo9ICgxLiArIC4wNSAqIHNpbigzLiAqIGEgKyAyLiAqIHQpKTtcbiAgICAgIGZsb2F0IGYgPSBhYnMoY29zKGEgKiAzLikpO1xuICAgICAgZWRnZSA9IHNtb290aHN0ZXAoZiwgZiArIC43LCByKTtcbiAgICAgIGVkZ2UgKj0gZWRnZTtcblxuICAgICAgdXYgKj0gLjg7XG4gICAgICBjeWNsZVdpZHRoICo9IDEuNjtcblxuICAgIH0gZWxzZSBpZiAodV9zaGFwZSA8IDQuKSB7XG4gICAgICAvLyBkaWFtb25kXG4gICAgICB2ZWMyIHNoYXBlVVYgPSB1diAtIC41O1xuICAgICAgc2hhcGVVViA9IHJvdGF0ZShzaGFwZVVWLCAuMjUgKiBQSSk7XG4gICAgICBzaGFwZVVWICo9IDEuNDI7XG4gICAgICBzaGFwZVVWICs9IC41O1xuICAgICAgdmVjMiBtYXNrID0gbWluKHNoYXBlVVYsIDEuIC0gc2hhcGVVVik7XG4gICAgICB2ZWMyIHBpeGVsX3RoaWNrbmVzcyA9IHZlYzIoLjE1KTtcbiAgICAgIGZsb2F0IG1hc2tYID0gc21vb3Roc3RlcCgwLjAsIHBpeGVsX3RoaWNrbmVzcy54LCBtYXNrLngpO1xuICAgICAgZmxvYXQgbWFza1kgPSBzbW9vdGhzdGVwKDAuMCwgcGl4ZWxfdGhpY2tuZXNzLnksIG1hc2sueSk7XG4gICAgICBtYXNrWCA9IHBvdyhtYXNrWCwgLjI1KTtcbiAgICAgIG1hc2tZID0gcG93KG1hc2tZLCAuMjUpO1xuICAgICAgZWRnZSA9IGNsYW1wKDEuIC0gbWFza1ggKiBtYXNrWSwgMC4sIDEuKTtcbiAgICB9IGVsc2UgaWYgKHVfc2hhcGUgPCA1Likge1xuICAgICAgLy8gbWV0YWJhbGxzXG4gICAgICB2ZWMyIHNoYXBlVVYgPSB1diAtIC41O1xuICAgICAgc2hhcGVVViAqPSAxLjM7XG4gICAgICBlZGdlID0gMC47XG4gICAgICBmb3IgKGludCBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICBmbG9hdCBmaSA9IGZsb2F0KGkpO1xuICAgICAgICBmbG9hdCBzcGVlZCA9IDEuNSArIDIuLzMuICogc2luKGZpICogMTIuMzQ1KTtcbiAgICAgICAgZmxvYXQgYW5nbGUgPSAtZmkgKiAxLjU7XG4gICAgICAgIHZlYzIgZGlyMSA9IHZlYzIoY29zKGFuZ2xlKSwgc2luKGFuZ2xlKSk7XG4gICAgICAgIHZlYzIgZGlyMiA9IHZlYzIoY29zKGFuZ2xlICsgMS41NyksIHNpbihhbmdsZSArIDEuKSk7XG4gICAgICAgIHZlYzIgdHJhaiA9IC40ICogKGRpcjEgKiBzaW4odCAqIHNwZWVkICsgZmkgKiAxLjIzKSArIGRpcjIgKiBjb3ModCAqIChzcGVlZCAqIDAuNykgKyBmaSAqIDIuMTcpKTtcbiAgICAgICAgZmxvYXQgZCA9IGxlbmd0aChzaGFwZVVWICsgdHJhaik7XG4gICAgICAgIGVkZ2UgKz0gcG93KDEuMCAtIGNsYW1wKGQsIDAuMCwgMS4wKSwgNC4wKTtcbiAgICAgIH1cbiAgICAgIGVkZ2UgPSAxLiAtIHNtb290aHN0ZXAoLjY1LCAuOSwgZWRnZSk7XG4gICAgICBlZGdlID0gcG93KGVkZ2UsIDQuKTtcbiAgICB9XG5cbiAgICBlZGdlID0gbWl4KHNtb290aHN0ZXAoLjkgLSAyLiAqIGZ3aWR0aChlZGdlKSwgLjksIGVkZ2UpLCBlZGdlLCBzbW9vdGhzdGVwKDAuMCwgMC40LCB1X2NvbnRvdXIpKTtcblxuICB9XG5cbiAgZmxvYXQgb3BhY2l0eSA9IDAuO1xuICBpZiAodV9pc0ltYWdlID09IHRydWUpIHtcbiAgICBvcGFjaXR5ID0gaW1nLmc7XG4gICAgZmxvYXQgZnJhbWUgPSBnZXRJbWdGcmFtZSh2X2ltYWdlVVYsIDAuKTtcbiAgICBvcGFjaXR5ICo9IGZyYW1lO1xuICB9IGVsc2Uge1xuICAgIG9wYWNpdHkgPSAxLiAtIHNtb290aHN0ZXAoLjkgLSAyLiAqIGZ3aWR0aChlZGdlKSwgLjksIGVkZ2UpO1xuICAgIGlmICh1X3NoYXBlIDwgMi4pIHtcbiAgICAgIGVkZ2UgPSAxLjIgKiBlZGdlO1xuICAgIH0gZWxzZSBpZiAodV9zaGFwZSA8IDUuKSB7XG4gICAgICBlZGdlID0gMS44ICogcG93KGVkZ2UsIDEuNSk7XG4gICAgfVxuICB9XG5cbiAgZmxvYXQgZGlhZ0JMdG9UUiA9IHJvdGF0ZWRVVi54IC0gcm90YXRlZFVWLnk7XG4gIGZsb2F0IGRpYWdUTHRvQlIgPSByb3RhdGVkVVYueCArIHJvdGF0ZWRVVi55O1xuXG4gIHZlYzMgY29sb3IgPSB2ZWMzKDAuKTtcbiAgdmVjMyBjb2xvcjEgPSB2ZWMzKC45OCwgMC45OCwgMS4pO1xuICB2ZWMzIGNvbG9yMiA9IHZlYzMoLjEsIC4xLCAuMSArIC4xICogc21vb3Roc3RlcCguNywgMS4zLCBkaWFnVEx0b0JSKSk7XG5cbiAgdmVjMiBncmFkX3V2ID0gdXYgLSAuNTtcblxuICBmbG9hdCBkaXN0ID0gbGVuZ3RoKGdyYWRfdXYgKyB2ZWMyKDAuLCAuMiAqIGRpYWdCTHRvVFIpKTtcbiAgZ3JhZF91diA9IHJvdGF0ZShncmFkX3V2LCAoLjI1IC0gLjIgKiBkaWFnQkx0b1RSKSAqIFBJKTtcbiAgZmxvYXQgZGlyZWN0aW9uID0gZ3JhZF91di54O1xuXG4gIGZsb2F0IGJ1bXAgPSBwb3coMS44ICogZGlzdCwgMS4yKTtcbiAgYnVtcCA9IDEuIC0gYnVtcDtcbiAgYnVtcCAqPSBwb3codXYueSwgLjMpO1xuXG5cbiAgZmxvYXQgdGhpbl9zdHJpcF8xX3JhdGlvID0gLjEyIC8gY3ljbGVXaWR0aCAqICgxLiAtIC40ICogYnVtcCk7XG4gIGZsb2F0IHRoaW5fc3RyaXBfMl9yYXRpbyA9IC4wNyAvIGN5Y2xlV2lkdGggKiAoMS4gKyAuNCAqIGJ1bXApO1xuICBmbG9hdCB3aWRlX3N0cmlwX3JhdGlvID0gKDEuIC0gdGhpbl9zdHJpcF8xX3JhdGlvIC0gdGhpbl9zdHJpcF8yX3JhdGlvKTtcblxuICBmbG9hdCB0aGluX3N0cmlwXzFfd2lkdGggPSBjeWNsZVdpZHRoICogdGhpbl9zdHJpcF8xX3JhdGlvO1xuICBmbG9hdCB0aGluX3N0cmlwXzJfd2lkdGggPSBjeWNsZVdpZHRoICogdGhpbl9zdHJpcF8yX3JhdGlvO1xuXG4gIGZsb2F0IG5vaXNlID0gc25vaXNlKHV2IC0gdCk7XG5cbiAgZWRnZSArPSAoMS4gLSBlZGdlKSAqIHVfZGlzdG9ydGlvbiAqIG5vaXNlO1xuXG4gIGRpcmVjdGlvbiArPSBkaWFnQkx0b1RSO1xuICBmbG9hdCBjb250b3VyID0gMC47XG4gIGRpcmVjdGlvbiAtPSAyLiAqIG5vaXNlICogZGlhZ0JMdG9UUiAqIChzbW9vdGhzdGVwKDAuLCAxLiwgZWRnZSkgKiAoMS4wIC0gc21vb3Roc3RlcCgwLiwgMS4sIGVkZ2UpKSk7XG4gIGRpcmVjdGlvbiAqPSBtaXgoMS4sIDEuIC0gZWRnZSwgc21vb3Roc3RlcCguNSwgMS4sIHVfY29udG91cikpO1xuICBkaXJlY3Rpb24gLT0gMS43ICogZWRnZSAqIHNtb290aHN0ZXAoLjUsIDEuLCB1X2NvbnRvdXIpO1xuICBkaXJlY3Rpb24gKz0gLjIgKiBwb3codV9jb250b3VyLCA0LikgKiAoMS4wIC0gc21vb3Roc3RlcCgwLiwgMS4sIGVkZ2UpKTtcblxuICBidW1wICo9IGNsYW1wKHBvdyh1di55LCAuMSksIC4zLCAxLik7XG4gIGRpcmVjdGlvbiAqPSAoLjEgKyAoMS4xIC0gZWRnZSkgKiBidW1wKTtcblxuICBkaXJlY3Rpb24gKj0gKC40ICsgLjYgKiAoMS4wIC0gc21vb3Roc3RlcCguNSwgMS4sIGVkZ2UpKSk7XG4gIGRpcmVjdGlvbiArPSAuMTggKiAoc21vb3Roc3RlcCguMSwgLjIsIHV2LnkpICogKDEuMCAtIHNtb290aHN0ZXAoLjIsIC40LCB1di55KSkpO1xuICBkaXJlY3Rpb24gKz0gLjAzICogKHNtb290aHN0ZXAoLjEsIC4yLCAxLiAtIHV2LnkpICogKDEuMCAtIHNtb290aHN0ZXAoLjIsIC40LCAxLiAtIHV2LnkpKSk7XG5cbiAgZGlyZWN0aW9uICo9ICguNSArIC41ICogcG93KHV2LnksIDIuKSk7XG4gIGRpcmVjdGlvbiAqPSBjeWNsZVdpZHRoO1xuICBkaXJlY3Rpb24gLT0gdDtcblxuXG4gIGZsb2F0IGNvbG9yRGlzcGVyc2lvbiA9ICgxLiAtIGJ1bXApO1xuICBjb2xvckRpc3BlcnNpb24gPSBjbGFtcChjb2xvckRpc3BlcnNpb24sIDAuLCAxLik7XG4gIGZsb2F0IGRpc3BlcnNpb25SZWQgPSBjb2xvckRpc3BlcnNpb247XG4gIGRpc3BlcnNpb25SZWQgKz0gLjAzICogYnVtcCAqIG5vaXNlO1xuICBkaXNwZXJzaW9uUmVkICs9IDUuICogKHNtb290aHN0ZXAoLS4xLCAuMiwgdXYueSkgKiAoMS4wIC0gc21vb3Roc3RlcCguMSwgLjUsIHV2LnkpKSkgKiAoc21vb3Roc3RlcCguNCwgLjYsIGJ1bXApICogKDEuMCAtIHNtb290aHN0ZXAoLjQsIDEuLCBidW1wKSkpO1xuICBkaXNwZXJzaW9uUmVkIC09IGRpYWdCTHRvVFI7XG5cbiAgZmxvYXQgZGlzcGVyc2lvbkJsdWUgPSBjb2xvckRpc3BlcnNpb247XG4gIGRpc3BlcnNpb25CbHVlICo9IDEuMztcbiAgZGlzcGVyc2lvbkJsdWUgKz0gKHNtb290aHN0ZXAoMC4sIC40LCB1di55KSAqICgxLjAgLSBzbW9vdGhzdGVwKC4xLCAuOCwgdXYueSkpKSAqIChzbW9vdGhzdGVwKC40LCAuNiwgYnVtcCkgKiAoMS4wIC0gc21vb3Roc3RlcCguNCwgLjgsIGJ1bXApKSk7XG4gIGRpc3BlcnNpb25CbHVlIC09IC4yICogZWRnZTtcblxuICBkaXNwZXJzaW9uUmVkICo9ICh1X3NoaWZ0UmVkIC8gMjAuKTtcbiAgZGlzcGVyc2lvbkJsdWUgKj0gKHVfc2hpZnRCbHVlIC8gMjAuKTtcblxuICBmbG9hdCBibHVyID0gMC47XG4gIGZsb2F0IHJFeHRyYUJsdXIgPSAwLjtcbiAgZmxvYXQgZ0V4dHJhQmx1ciA9IDAuO1xuICBpZiAodV9pc0ltYWdlID09IHRydWUpIHtcbiAgICBmbG9hdCBzb2Z0bmVzcyA9IDAuMDUgKiB1X3NvZnRuZXNzO1xuICAgIGJsdXIgPSBzb2Z0bmVzcyArIC41ICogc21vb3Roc3RlcCgxLiwgMTAuLCB1X3JlcGV0aXRpb24pICogc21vb3Roc3RlcCguMCwgMS4sIGVkZ2UpO1xuICAgIGZsb2F0IHNtYWxsQ2FudmFzVCA9IDEuMCAtIHNtb290aHN0ZXAoMTAwLiwgNTAwLiwgbWluKHVfcmVzb2x1dGlvbi54LCB1X3Jlc29sdXRpb24ueSkpO1xuICAgIGJsdXIgKz0gc21hbGxDYW52YXNUICogc21vb3Roc3RlcCguMCwgMS4sIGVkZ2UpO1xuICAgIHJFeHRyYUJsdXIgPSBzb2Z0bmVzcyAqICgwLjA1ICsgLjEgKiAodV9zaGlmdFJlZCAvIDIwLikgKiBidW1wKTtcbiAgICBnRXh0cmFCbHVyID0gc29mdG5lc3MgKiAwLjA1IC8gbWF4KDAuMDAxLCBhYnMoMS4gLSBkaWFnQkx0b1RSKSk7XG4gIH0gZWxzZSB7XG4gICAgYmx1ciA9IHVfc29mdG5lc3MgLyAxNS4gKyAuMyAqIGNvbnRvdXI7XG4gIH1cblxuICB2ZWMzIHcgPSB2ZWMzKHRoaW5fc3RyaXBfMV93aWR0aCwgdGhpbl9zdHJpcF8yX3dpZHRoLCB3aWRlX3N0cmlwX3JhdGlvKTtcbiAgd1sxXSAtPSAuMDIgKiBzbW9vdGhzdGVwKC4wLCAxLiwgZWRnZSArIGJ1bXApO1xuICBmbG9hdCBzdHJpcGVfciA9IGZyYWN0KGRpcmVjdGlvbiArIGRpc3BlcnNpb25SZWQpO1xuICBmbG9hdCByID0gZ2V0Q29sb3JDaGFuZ2VzKGNvbG9yMS5yLCBjb2xvcjIuciwgc3RyaXBlX3IsIHcsIGJsdXIgKyBmd2lkdGgoc3RyaXBlX3IpICsgckV4dHJhQmx1ciwgYnVtcCwgdV9jb2xvclRpbnQucik7XG4gIGZsb2F0IHN0cmlwZV9nID0gZnJhY3QoZGlyZWN0aW9uKTtcbiAgZmxvYXQgZyA9IGdldENvbG9yQ2hhbmdlcyhjb2xvcjEuZywgY29sb3IyLmcsIHN0cmlwZV9nLCB3LCBibHVyICsgZndpZHRoKHN0cmlwZV9nKSArIGdFeHRyYUJsdXIsIGJ1bXAsIHVfY29sb3JUaW50LmcpO1xuICBmbG9hdCBzdHJpcGVfYiA9IGZyYWN0KGRpcmVjdGlvbiAtIGRpc3BlcnNpb25CbHVlKTtcbiAgZmxvYXQgYiA9IGdldENvbG9yQ2hhbmdlcyhjb2xvcjEuYiwgY29sb3IyLmIsIHN0cmlwZV9iLCB3LCBibHVyICsgZndpZHRoKHN0cmlwZV9iKSwgYnVtcCwgdV9jb2xvclRpbnQuYik7XG5cbiAgY29sb3IgPSB2ZWMzKHIsIGcsIGIpO1xuICBjb2xvciAqPSBvcGFjaXR5O1xuXG4gIHZlYzMgYmdDb2xvciA9IHVfY29sb3JCYWNrLnJnYiAqIHVfY29sb3JCYWNrLmE7XG4gIGNvbG9yID0gY29sb3IgKyBiZ0NvbG9yICogKDEuIC0gb3BhY2l0eSk7XG4gIG9wYWNpdHkgPSBvcGFjaXR5ICsgdV9jb2xvckJhY2suYSAqICgxLiAtIG9wYWNpdHkpO1xuXG4gICR7Y29sb3JCYW5kaW5nRml4fVxuXG4gIGZyYWdDb2xvciA9IHZlYzQoY29sb3IsIG9wYWNpdHkpO1xufVxuYDtcbmNvbnN0IFBPSVNTT05fQ09ORklHX09QVElNSVpFRCA9IHtcbiAgbWVhc3VyZVBlcmZvcm1hbmNlOiBmYWxzZSxcbiAgLy8gU2V0IHRvIHRydWUgdG8gc2VlIHBlcmZvcm1hbmNlIG1ldHJpY3NcbiAgd29ya2luZ1NpemU6IDUxMixcbiAgLy8gU2l6ZSB0byBzb2x2ZSBQb2lzc29uIGF0ICh3aWxsIHVwc2NhbGUgdG8gb3JpZ2luYWwgc2l6ZSlcbiAgaXRlcmF0aW9uczogNDBcbiAgLy8gU09SIGNvbnZlcmdlcyB+Mi0yMHggZmFzdGVyIHRoYW4gc3RhbmRhcmQgR2F1c3MtU2VpZGVsXG59O1xuZnVuY3Rpb24gdG9Qcm9jZXNzZWRMaXF1aWRNZXRhbChmaWxlKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gIGNvbnN0IGlzQmxvYiA9IHR5cGVvZiBmaWxlID09PSBcInN0cmluZ1wiICYmIGZpbGUuc3RhcnRzV2l0aChcImJsb2I6XCIpO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGlmICghZmlsZSB8fCAhY3R4KSB7XG4gICAgICByZWplY3QobmV3IEVycm9yKFwiSW52YWxpZCBmaWxlIG9yIGNhbnZhcyBjb250ZXh0XCIpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYmxvYkNvbnRlbnRUeXBlUHJvbWlzZSA9IGlzQmxvYiAmJiBmZXRjaChmaWxlKS50aGVuKChyZXMpID0+IHJlcy5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKSk7XG4gICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgaW1nLmNyb3NzT3JpZ2luID0gXCJhbm9ueW1vdXNcIjtcbiAgICBjb25zdCB0b3RhbFN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGltZy5vbmxvYWQgPSBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgaXNTVkc7XG4gICAgICBjb25zdCBibG9iQ29udGVudFR5cGUgPSBhd2FpdCBibG9iQ29udGVudFR5cGVQcm9taXNlO1xuICAgICAgaWYgKGJsb2JDb250ZW50VHlwZSkge1xuICAgICAgICBpc1NWRyA9IGJsb2JDb250ZW50VHlwZSA9PT0gXCJpbWFnZS9zdmcreG1sXCI7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmaWxlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlzU1ZHID0gZmlsZS5lbmRzV2l0aChcIi5zdmdcIikgfHwgZmlsZS5zdGFydHNXaXRoKFwiZGF0YTppbWFnZS9zdmcreG1sXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNTVkcgPSBmaWxlLnR5cGUgPT09IFwiaW1hZ2Uvc3ZnK3htbFwiO1xuICAgICAgfVxuICAgICAgbGV0IG9yaWdpbmFsV2lkdGggPSBpbWcud2lkdGggfHwgaW1nLm5hdHVyYWxXaWR0aDtcbiAgICAgIGxldCBvcmlnaW5hbEhlaWdodCA9IGltZy5oZWlnaHQgfHwgaW1nLm5hdHVyYWxIZWlnaHQ7XG4gICAgICBpZiAoaXNTVkcpIHtcbiAgICAgICAgY29uc3Qgc3ZnTWF4U2l6ZSA9IDQwOTY7XG4gICAgICAgIGNvbnN0IGFzcGVjdFJhdGlvID0gb3JpZ2luYWxXaWR0aCAvIG9yaWdpbmFsSGVpZ2h0O1xuICAgICAgICBpZiAob3JpZ2luYWxXaWR0aCA+IG9yaWdpbmFsSGVpZ2h0KSB7XG4gICAgICAgICAgb3JpZ2luYWxXaWR0aCA9IHN2Z01heFNpemU7XG4gICAgICAgICAgb3JpZ2luYWxIZWlnaHQgPSBzdmdNYXhTaXplIC8gYXNwZWN0UmF0aW87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3JpZ2luYWxIZWlnaHQgPSBzdmdNYXhTaXplO1xuICAgICAgICAgIG9yaWdpbmFsV2lkdGggPSBzdmdNYXhTaXplICogYXNwZWN0UmF0aW87XG4gICAgICAgIH1cbiAgICAgICAgaW1nLndpZHRoID0gb3JpZ2luYWxXaWR0aDtcbiAgICAgICAgaW1nLmhlaWdodCA9IG9yaWdpbmFsSGVpZ2h0O1xuICAgICAgfVxuICAgICAgY29uc3QgbWluRGltZW5zaW9uID0gTWF0aC5taW4ob3JpZ2luYWxXaWR0aCwgb3JpZ2luYWxIZWlnaHQpO1xuICAgICAgY29uc3QgdGFyZ2V0U2l6ZSA9IFBPSVNTT05fQ09ORklHX09QVElNSVpFRC53b3JraW5nU2l6ZTtcbiAgICAgIGNvbnN0IHNjYWxlRmFjdG9yID0gdGFyZ2V0U2l6ZSAvIG1pbkRpbWVuc2lvbjtcbiAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC5yb3VuZChvcmlnaW5hbFdpZHRoICogc2NhbGVGYWN0b3IpO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5yb3VuZChvcmlnaW5hbEhlaWdodCAqIHNjYWxlRmFjdG9yKTtcbiAgICAgIGlmIChQT0lTU09OX0NPTkZJR19PUFRJTUlaRUQubWVhc3VyZVBlcmZvcm1hbmNlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbUHJvY2Vzc2luZyBNb2RlXWApO1xuICAgICAgICBjb25zb2xlLmxvZyhgICBPcmlnaW5hbDogJHtvcmlnaW5hbFdpZHRofVxceEQ3JHtvcmlnaW5hbEhlaWdodH1gKTtcbiAgICAgICAgY29uc29sZS5sb2coYCAgV29ya2luZzogJHt3aWR0aH1cXHhENyR7aGVpZ2h0fSAoJHsoc2NhbGVGYWN0b3IgKiAxMDApLnRvRml4ZWQoMSl9JSBzY2FsZSlgKTtcbiAgICAgICAgaWYgKHNjYWxlRmFjdG9yIDwgMSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGAgIFNwZWVkdXA6IH4ke01hdGgucm91bmQoMSAvIChzY2FsZUZhY3RvciAqIHNjYWxlRmFjdG9yKSl9XFx4RDdgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2FudmFzLndpZHRoID0gb3JpZ2luYWxXaWR0aDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBvcmlnaW5hbEhlaWdodDtcbiAgICAgIGNvbnN0IHNoYXBlQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgIHNoYXBlQ2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICBzaGFwZUNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICBjb25zdCBzaGFwZUN0eCA9IHNoYXBlQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIHNoYXBlQ3R4LmRyYXdJbWFnZShpbWcsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY29uc3Qgc3RhcnRNYXNrID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCBzaGFwZUltYWdlRGF0YSA9IHNoYXBlQ3R4LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBzaGFwZUltYWdlRGF0YS5kYXRhO1xuICAgICAgY29uc3Qgc2hhcGVNYXNrID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQpO1xuICAgICAgY29uc3QgYm91bmRhcnlNYXNrID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQpO1xuICAgICAgbGV0IHNoYXBlUGl4ZWxDb3VudCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWR4ID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQsIGlkeCsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBkYXRhW2kgKyAzXTtcbiAgICAgICAgY29uc3QgaXNTaGFwZSA9IGEgPT09IDAgPyAwIDogMTtcbiAgICAgICAgc2hhcGVNYXNrW2lkeF0gPSBpc1NoYXBlO1xuICAgICAgICBzaGFwZVBpeGVsQ291bnQgKz0gaXNTaGFwZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJvdW5kYXJ5SW5kaWNlcyA9IFtdO1xuICAgICAgY29uc3QgaW50ZXJpb3JJbmRpY2VzID0gW107XG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgIGNvbnN0IGlkeCA9IHkgKiB3aWR0aCArIHg7XG4gICAgICAgICAgaWYgKCFzaGFwZU1hc2tbaWR4XSkgY29udGludWU7XG4gICAgICAgICAgbGV0IGlzQm91bmRhcnkgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoeCA9PT0gMCB8fCB4ID09PSB3aWR0aCAtIDEgfHwgeSA9PT0gMCB8fCB5ID09PSBoZWlnaHQgLSAxKSB7XG4gICAgICAgICAgICBpc0JvdW5kYXJ5ID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXNCb3VuZGFyeSA9ICFzaGFwZU1hc2tbaWR4IC0gMV0gfHwgLy8gbGVmdFxuICAgICAgICAgICAgIXNoYXBlTWFza1tpZHggKyAxXSB8fCAvLyByaWdodFxuICAgICAgICAgICAgIXNoYXBlTWFza1tpZHggLSB3aWR0aF0gfHwgLy8gdG9wXG4gICAgICAgICAgICAhc2hhcGVNYXNrW2lkeCArIHdpZHRoXSB8fCAvLyBib3R0b21cbiAgICAgICAgICAgICFzaGFwZU1hc2tbaWR4IC0gd2lkdGggLSAxXSB8fCAvLyB0b3AtbGVmdFxuICAgICAgICAgICAgIXNoYXBlTWFza1tpZHggLSB3aWR0aCArIDFdIHx8IC8vIHRvcC1yaWdodFxuICAgICAgICAgICAgIXNoYXBlTWFza1tpZHggKyB3aWR0aCAtIDFdIHx8IC8vIGJvdHRvbS1sZWZ0XG4gICAgICAgICAgICAhc2hhcGVNYXNrW2lkeCArIHdpZHRoICsgMV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0JvdW5kYXJ5KSB7XG4gICAgICAgICAgICBib3VuZGFyeU1hc2tbaWR4XSA9IDE7XG4gICAgICAgICAgICBib3VuZGFyeUluZGljZXMucHVzaChpZHgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnRlcmlvckluZGljZXMucHVzaChpZHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKFBPSVNTT05fQ09ORklHX09QVElNSVpFRC5tZWFzdXJlUGVyZm9ybWFuY2UpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFtNYXNrIEJ1aWxkaW5nXSBUaW1lOiAkeyhwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0TWFzaykudG9GaXhlZCgyKX1tc2ApO1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICBgICBTaGFwZSBwaXhlbHM6ICR7c2hhcGVQaXhlbENvdW50fSAvICR7d2lkdGggKiBoZWlnaHR9ICgkeyhzaGFwZVBpeGVsQ291bnQgLyAod2lkdGggKiBoZWlnaHQpICogMTAwKS50b0ZpeGVkKDEpfSUpYFxuICAgICAgICApO1xuICAgICAgICBjb25zb2xlLmxvZyhgICBJbnRlcmlvciBwaXhlbHM6ICR7aW50ZXJpb3JJbmRpY2VzLmxlbmd0aH1gKTtcbiAgICAgICAgY29uc29sZS5sb2coYCAgQm91bmRhcnkgcGl4ZWxzOiAke2JvdW5kYXJ5SW5kaWNlcy5sZW5ndGh9YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBzcGFyc2VEYXRhID0gYnVpbGRTcGFyc2VEYXRhKFxuICAgICAgICBzaGFwZU1hc2ssXG4gICAgICAgIGJvdW5kYXJ5TWFzayxcbiAgICAgICAgbmV3IFVpbnQzMkFycmF5KGludGVyaW9ySW5kaWNlcyksXG4gICAgICAgIG5ldyBVaW50MzJBcnJheShib3VuZGFyeUluZGljZXMpLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICApO1xuICAgICAgY29uc3Qgc3RhcnRTb2x2ZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgdSA9IHNvbHZlUG9pc3NvblNwYXJzZShzcGFyc2VEYXRhLCBzaGFwZU1hc2ssIGJvdW5kYXJ5TWFzaywgd2lkdGgsIGhlaWdodCk7XG4gICAgICBpZiAoUE9JU1NPTl9DT05GSUdfT1BUSU1JWkVELm1lYXN1cmVQZXJmb3JtYW5jZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhgW1BvaXNzb24gU29sdmVdIFRpbWU6ICR7KHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRTb2x2ZSkudG9GaXhlZCgyKX1tc2ApO1xuICAgICAgfVxuICAgICAgbGV0IG1heFZhbCA9IDA7XG4gICAgICBsZXQgZmluYWxJbWFnZURhdGE7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGludGVyaW9ySW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBpZHggPSBpbnRlcmlvckluZGljZXNbaV07XG4gICAgICAgIGlmICh1W2lkeF0gPiBtYXhWYWwpIG1heFZhbCA9IHVbaWR4XTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRlbXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgdGVtcENhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgdGVtcENhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICBjb25zdCB0ZW1wQ3R4ID0gdGVtcENhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICBjb25zdCB0ZW1wSW1nID0gdGVtcEN0eC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIGhlaWdodCk7XG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgIGNvbnN0IGlkeCA9IHkgKiB3aWR0aCArIHg7XG4gICAgICAgICAgY29uc3QgcHggPSBpZHggKiA0O1xuICAgICAgICAgIGlmICghc2hhcGVNYXNrW2lkeF0pIHtcbiAgICAgICAgICAgIHRlbXBJbWcuZGF0YVtweF0gPSAyNTU7XG4gICAgICAgICAgICB0ZW1wSW1nLmRhdGFbcHggKyAxXSA9IDI1NTtcbiAgICAgICAgICAgIHRlbXBJbWcuZGF0YVtweCArIDJdID0gMjU1O1xuICAgICAgICAgICAgdGVtcEltZy5kYXRhW3B4ICsgM10gPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwb2lzc29uUmF0aW8gPSB1W2lkeF0gLyBtYXhWYWw7XG4gICAgICAgICAgICBjb25zdCBncmF5ID0gMjU1ICogKDEgLSBwb2lzc29uUmF0aW8pO1xuICAgICAgICAgICAgdGVtcEltZy5kYXRhW3B4XSA9IGdyYXk7XG4gICAgICAgICAgICB0ZW1wSW1nLmRhdGFbcHggKyAxXSA9IGdyYXk7XG4gICAgICAgICAgICB0ZW1wSW1nLmRhdGFbcHggKyAyXSA9IGdyYXk7XG4gICAgICAgICAgICB0ZW1wSW1nLmRhdGFbcHggKyAzXSA9IDI1NTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRlbXBDdHgucHV0SW1hZ2VEYXRhKHRlbXBJbWcsIDAsIDApO1xuICAgICAgY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IHRydWU7XG4gICAgICBjdHguaW1hZ2VTbW9vdGhpbmdRdWFsaXR5ID0gXCJoaWdoXCI7XG4gICAgICBjdHguZHJhd0ltYWdlKHRlbXBDYW52YXMsIDAsIDAsIHdpZHRoLCBoZWlnaHQsIDAsIDAsIG9yaWdpbmFsV2lkdGgsIG9yaWdpbmFsSGVpZ2h0KTtcbiAgICAgIGNvbnN0IG91dEltZyA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgb3JpZ2luYWxXaWR0aCwgb3JpZ2luYWxIZWlnaHQpO1xuICAgICAgY29uc3Qgb3JpZ2luYWxDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgb3JpZ2luYWxDYW52YXMud2lkdGggPSBvcmlnaW5hbFdpZHRoO1xuICAgICAgb3JpZ2luYWxDYW52YXMuaGVpZ2h0ID0gb3JpZ2luYWxIZWlnaHQ7XG4gICAgICBjb25zdCBvcmlnaW5hbEN0eCA9IG9yaWdpbmFsQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIG9yaWdpbmFsQ3R4LmRyYXdJbWFnZShpbWcsIDAsIDAsIG9yaWdpbmFsV2lkdGgsIG9yaWdpbmFsSGVpZ2h0KTtcbiAgICAgIGNvbnN0IG9yaWdpbmFsRGF0YSA9IG9yaWdpbmFsQ3R4LmdldEltYWdlRGF0YSgwLCAwLCBvcmlnaW5hbFdpZHRoLCBvcmlnaW5hbEhlaWdodCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dEltZy5kYXRhLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgIGNvbnN0IGEgPSBvcmlnaW5hbERhdGEuZGF0YVtpICsgM107XG4gICAgICAgIGNvbnN0IHVwc2NhbGVkQWxwaGEgPSBvdXRJbWcuZGF0YVtpICsgM107XG4gICAgICAgIGlmIChhID09PSAwKSB7XG4gICAgICAgICAgb3V0SW1nLmRhdGFbaV0gPSAyNTU7XG4gICAgICAgICAgb3V0SW1nLmRhdGFbaSArIDFdID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXRJbWcuZGF0YVtpXSA9IHVwc2NhbGVkQWxwaGEgPT09IDAgPyAwIDogb3V0SW1nLmRhdGFbaV07XG4gICAgICAgICAgb3V0SW1nLmRhdGFbaSArIDFdID0gYTtcbiAgICAgICAgfVxuICAgICAgICBvdXRJbWcuZGF0YVtpICsgMl0gPSAyNTU7XG4gICAgICAgIG91dEltZy5kYXRhW2kgKyAzXSA9IDI1NTtcbiAgICAgIH1cbiAgICAgIGN0eC5wdXRJbWFnZURhdGEob3V0SW1nLCAwLCAwKTtcbiAgICAgIGZpbmFsSW1hZ2VEYXRhID0gb3V0SW1nO1xuICAgICAgY2FudmFzLnRvQmxvYigoYmxvYikgPT4ge1xuICAgICAgICBpZiAoIWJsb2IpIHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiRmFpbGVkIHRvIGNyZWF0ZSBQTkcgYmxvYlwiKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChQT0lTU09OX0NPTkZJR19PUFRJTUlaRUQubWVhc3VyZVBlcmZvcm1hbmNlKSB7XG4gICAgICAgICAgY29uc3QgdG90YWxUaW1lID0gcGVyZm9ybWFuY2Uubm93KCkgLSB0b3RhbFN0YXJ0VGltZTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgW1RvdGFsIFByb2Nlc3NpbmcgVGltZV0gJHt0b3RhbFRpbWUudG9GaXhlZCgyKX1tc2ApO1xuICAgICAgICAgIGlmIChzY2FsZUZhY3RvciA8IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGVzdGltYXRlZEZ1bGxSZXNUaW1lID0gdG90YWxUaW1lICogTWF0aC5wb3cob3JpZ2luYWxXaWR0aCAqIG9yaWdpbmFsSGVpZ2h0IC8gKHdpZHRoICogaGVpZ2h0KSwgMS41KTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbRXN0aW1hdGVkIHRpbWUgYXQgZnVsbCByZXNvbHV0aW9uXSB+JHtlc3RpbWF0ZWRGdWxsUmVzVGltZS50b0ZpeGVkKDApfW1zYCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgYFtUaW1lIHNhdmVkXSB+JHsoZXN0aW1hdGVkRnVsbFJlc1RpbWUgLSB0b3RhbFRpbWUpLnRvRml4ZWQoMCl9bXMgKCR7TWF0aC5yb3VuZChlc3RpbWF0ZWRGdWxsUmVzVGltZSAvIHRvdGFsVGltZSl9XFx4RDcgZmFzdGVyKWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgIGltYWdlRGF0YTogZmluYWxJbWFnZURhdGEsXG4gICAgICAgICAgcG5nQmxvYjogYmxvYlxuICAgICAgICB9KTtcbiAgICAgIH0sIFwiaW1hZ2UvcG5nXCIpO1xuICAgIH07XG4gICAgaW1nLm9uZXJyb3IgPSAoKSA9PiByZWplY3QobmV3IEVycm9yKFwiRmFpbGVkIHRvIGxvYWQgaW1hZ2VcIikpO1xuICAgIGltZy5zcmMgPSB0eXBlb2YgZmlsZSA9PT0gXCJzdHJpbmdcIiA/IGZpbGUgOiBVUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGJ1aWxkU3BhcnNlRGF0YShzaGFwZU1hc2ssIGJvdW5kYXJ5TWFzaywgaW50ZXJpb3JQaXhlbHMsIGJvdW5kYXJ5UGl4ZWxzLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIGNvbnN0IHBpeGVsQ291bnQgPSBpbnRlcmlvclBpeGVscy5sZW5ndGg7XG4gIGNvbnN0IG5laWdoYm9ySW5kaWNlcyA9IG5ldyBJbnQzMkFycmF5KHBpeGVsQ291bnQgKiA0KTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwaXhlbENvdW50OyBpKyspIHtcbiAgICBjb25zdCBpZHggPSBpbnRlcmlvclBpeGVsc1tpXTtcbiAgICBjb25zdCB4ID0gaWR4ICUgd2lkdGg7XG4gICAgY29uc3QgeSA9IE1hdGguZmxvb3IoaWR4IC8gd2lkdGgpO1xuICAgIG5laWdoYm9ySW5kaWNlc1tpICogNCArIDBdID0geCA8IHdpZHRoIC0gMSAmJiBzaGFwZU1hc2tbaWR4ICsgMV0gPyBpZHggKyAxIDogLTE7XG4gICAgbmVpZ2hib3JJbmRpY2VzW2kgKiA0ICsgMV0gPSB4ID4gMCAmJiBzaGFwZU1hc2tbaWR4IC0gMV0gPyBpZHggLSAxIDogLTE7XG4gICAgbmVpZ2hib3JJbmRpY2VzW2kgKiA0ICsgMl0gPSB5ID4gMCAmJiBzaGFwZU1hc2tbaWR4IC0gd2lkdGhdID8gaWR4IC0gd2lkdGggOiAtMTtcbiAgICBuZWlnaGJvckluZGljZXNbaSAqIDQgKyAzXSA9IHkgPCBoZWlnaHQgLSAxICYmIHNoYXBlTWFza1tpZHggKyB3aWR0aF0gPyBpZHggKyB3aWR0aCA6IC0xO1xuICB9XG4gIHJldHVybiB7XG4gICAgaW50ZXJpb3JQaXhlbHMsXG4gICAgYm91bmRhcnlQaXhlbHMsXG4gICAgcGl4ZWxDb3VudCxcbiAgICBuZWlnaGJvckluZGljZXNcbiAgfTtcbn1cbmZ1bmN0aW9uIHNvbHZlUG9pc3NvblNwYXJzZShzcGFyc2VEYXRhLCBzaGFwZU1hc2ssIGJvdW5kYXJ5TWFzaywgd2lkdGgsIGhlaWdodCkge1xuICBjb25zdCBJVEVSQVRJT05TID0gUE9JU1NPTl9DT05GSUdfT1BUSU1JWkVELml0ZXJhdGlvbnM7XG4gIGNvbnN0IEMgPSAwLjAxO1xuICBjb25zdCB1ID0gbmV3IEZsb2F0MzJBcnJheSh3aWR0aCAqIGhlaWdodCk7XG4gIGNvbnN0IHsgaW50ZXJpb3JQaXhlbHMsIG5laWdoYm9ySW5kaWNlcywgcGl4ZWxDb3VudCB9ID0gc3BhcnNlRGF0YTtcbiAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gIGNvbnN0IG9tZWdhID0gMS45O1xuICBjb25zdCByZWRQaXhlbHMgPSBbXTtcbiAgY29uc3QgYmxhY2tQaXhlbHMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwaXhlbENvdW50OyBpKyspIHtcbiAgICBjb25zdCBpZHggPSBpbnRlcmlvclBpeGVsc1tpXTtcbiAgICBjb25zdCB4ID0gaWR4ICUgd2lkdGg7XG4gICAgY29uc3QgeSA9IE1hdGguZmxvb3IoaWR4IC8gd2lkdGgpO1xuICAgIGlmICgoeCArIHkpICUgMiA9PT0gMCkge1xuICAgICAgcmVkUGl4ZWxzLnB1c2goaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJsYWNrUGl4ZWxzLnB1c2goaSk7XG4gICAgfVxuICB9XG4gIGZvciAobGV0IGl0ZXIgPSAwOyBpdGVyIDwgSVRFUkFUSU9OUzsgaXRlcisrKSB7XG4gICAgZm9yIChjb25zdCBpIG9mIHJlZFBpeGVscykge1xuICAgICAgY29uc3QgaWR4ID0gaW50ZXJpb3JQaXhlbHNbaV07XG4gICAgICBjb25zdCBlYXN0SWR4ID0gbmVpZ2hib3JJbmRpY2VzW2kgKiA0ICsgMF07XG4gICAgICBjb25zdCB3ZXN0SWR4ID0gbmVpZ2hib3JJbmRpY2VzW2kgKiA0ICsgMV07XG4gICAgICBjb25zdCBub3J0aElkeCA9IG5laWdoYm9ySW5kaWNlc1tpICogNCArIDJdO1xuICAgICAgY29uc3Qgc291dGhJZHggPSBuZWlnaGJvckluZGljZXNbaSAqIDQgKyAzXTtcbiAgICAgIGxldCBzdW1OID0gMDtcbiAgICAgIGlmIChlYXN0SWR4ID49IDApIHN1bU4gKz0gdVtlYXN0SWR4XTtcbiAgICAgIGlmICh3ZXN0SWR4ID49IDApIHN1bU4gKz0gdVt3ZXN0SWR4XTtcbiAgICAgIGlmIChub3J0aElkeCA+PSAwKSBzdW1OICs9IHVbbm9ydGhJZHhdO1xuICAgICAgaWYgKHNvdXRoSWR4ID49IDApIHN1bU4gKz0gdVtzb3V0aElkeF07XG4gICAgICBjb25zdCBuZXdWYWx1ZSA9IChDICsgc3VtTikgLyA0O1xuICAgICAgdVtpZHhdID0gb21lZ2EgKiBuZXdWYWx1ZSArICgxIC0gb21lZ2EpICogdVtpZHhdO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGkgb2YgYmxhY2tQaXhlbHMpIHtcbiAgICAgIGNvbnN0IGlkeCA9IGludGVyaW9yUGl4ZWxzW2ldO1xuICAgICAgY29uc3QgZWFzdElkeCA9IG5laWdoYm9ySW5kaWNlc1tpICogNCArIDBdO1xuICAgICAgY29uc3Qgd2VzdElkeCA9IG5laWdoYm9ySW5kaWNlc1tpICogNCArIDFdO1xuICAgICAgY29uc3Qgbm9ydGhJZHggPSBuZWlnaGJvckluZGljZXNbaSAqIDQgKyAyXTtcbiAgICAgIGNvbnN0IHNvdXRoSWR4ID0gbmVpZ2hib3JJbmRpY2VzW2kgKiA0ICsgM107XG4gICAgICBsZXQgc3VtTiA9IDA7XG4gICAgICBpZiAoZWFzdElkeCA+PSAwKSBzdW1OICs9IHVbZWFzdElkeF07XG4gICAgICBpZiAod2VzdElkeCA+PSAwKSBzdW1OICs9IHVbd2VzdElkeF07XG4gICAgICBpZiAobm9ydGhJZHggPj0gMCkgc3VtTiArPSB1W25vcnRoSWR4XTtcbiAgICAgIGlmIChzb3V0aElkeCA+PSAwKSBzdW1OICs9IHVbc291dGhJZHhdO1xuICAgICAgY29uc3QgbmV3VmFsdWUgPSAoQyArIHN1bU4pIC8gNDtcbiAgICAgIHVbaWR4XSA9IG9tZWdhICogbmV3VmFsdWUgKyAoMSAtIG9tZWdhKSAqIHVbaWR4XTtcbiAgICB9XG4gIH1cbiAgaWYgKFBPSVNTT05fQ09ORklHX09QVElNSVpFRC5tZWFzdXJlUGVyZm9ybWFuY2UpIHtcbiAgICBjb25zdCBlbGFwc2VkID0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWU7XG4gICAgY29uc29sZS5sb2coYFtPcHRpbWl6ZWQgUG9pc3NvbiBTb2x2ZXIgKFNPUiBcXHUwM0M5PSR7b21lZ2F9KV1gKTtcbiAgICBjb25zb2xlLmxvZyhgICBXb3JraW5nIHNpemU6ICR7d2lkdGh9XFx4RDcke2hlaWdodH1gKTtcbiAgICBjb25zb2xlLmxvZyhgICBJdGVyYXRpb25zOiAke0lURVJBVElPTlN9YCk7XG4gICAgY29uc29sZS5sb2coYCAgVGltZTogJHtlbGFwc2VkLnRvRml4ZWQoMil9bXNgKTtcbiAgICBjb25zb2xlLmxvZyhgICBJbnRlcmlvciBwaXhlbHMgcHJvY2Vzc2VkOiAke3BpeGVsQ291bnR9YCk7XG4gICAgY29uc29sZS5sb2coYCAgU3BlZWQ6ICR7KElURVJBVElPTlMgKiBwaXhlbENvdW50IC8gKGVsYXBzZWQgKiAxZTMpKS50b0ZpeGVkKDIpfSBNcGl4ZWxzL3NlY2ApO1xuICB9XG4gIHJldHVybiB1O1xufVxuY29uc3QgTGlxdWlkTWV0YWxTaGFwZXMgPSB7XG4gIG5vbmU6IDAsXG4gIGNpcmNsZTogMSxcbiAgZGFpc3k6IDIsXG4gIGRpYW1vbmQ6IDMsXG4gIG1ldGFiYWxsczogNFxufTtcbmV4cG9ydCB7XG4gIExpcXVpZE1ldGFsU2hhcGVzLFxuICBQT0lTU09OX0NPTkZJR19PUFRJTUlaRUQsXG4gIGxpcXVpZE1ldGFsRnJhZ21lbnRTaGFkZXIsXG4gIHRvUHJvY2Vzc2VkTGlxdWlkTWV0YWxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saXF1aWQtbWV0YWwuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/shaders/liquid-metal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/vertex-shader.js":
/*!******************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/vertex-shader.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   vertexShaderSource: () => (/* binding */ vertexShaderSource)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nconst vertexShaderSource = `#version 300 es\nprecision mediump float;\n\nlayout(location = 0) in vec4 a_position;\n\nuniform vec2 u_resolution;\nuniform float u_pixelRatio;\nuniform float u_imageAspectRatio;\n\nuniform float u_originX;\nuniform float u_originY;\nuniform float u_worldWidth;\nuniform float u_worldHeight;\nuniform float u_fit;\n\nuniform float u_scale;\nuniform float u_rotation;\nuniform float u_offsetX;\nuniform float u_offsetY;\n\nuniform float u_pxSize;\n\nout vec2 v_objectUV;\nout vec2 v_objectBoxSize;\nout vec2 v_objectHelperBox;\n\nout vec2 v_responsiveUV;\nout vec2 v_responsiveBoxSize;\nout vec2 v_responsiveHelperBox;\nout vec2 v_responsiveBoxGivenSize;\n\nout vec2 v_patternUV;\nout vec2 v_patternBoxSize;\nout vec2 v_patternHelperBox;\n\nout vec2 v_imageUV;\n\n// #define ADD_HELPERS\n\nvec3 getBoxSize(float boxRatio, vec2 givenBoxSize) {\n  vec2 box = vec2(0.);\n  // fit = none\n  box.x = boxRatio * min(givenBoxSize.x / boxRatio, givenBoxSize.y);\n  float noFitBoxWidth = box.x;\n  if (u_fit == 1.) { // fit = contain\n    box.x = boxRatio * min(u_resolution.x / boxRatio, u_resolution.y);\n  } else if (u_fit == 2.) { // fit = cover\n    box.x = boxRatio * max(u_resolution.x / boxRatio, u_resolution.y);\n  }\n  box.y = box.x / boxRatio;\n  return vec3(box, noFitBoxWidth);\n}\n\nvoid main() {\n  gl_Position = a_position;\n\n  vec2 uv = gl_Position.xy * .5;\n  vec2 boxOrigin = vec2(.5 - u_originX, u_originY - .5);\n  vec2 givenBoxSize = vec2(u_worldWidth, u_worldHeight);\n  givenBoxSize = max(givenBoxSize, vec2(1.)) * u_pixelRatio;\n  float r = u_rotation * 3.14159265358979323846 / 180.;\n  mat2 graphicRotation = mat2(cos(r), sin(r), -sin(r), cos(r));\n  vec2 graphicOffset = vec2(-u_offsetX, u_offsetY);\n\n\n  // ===================================================\n  // Sizing api for graphic objects with fixed ratio\n  // (currently supports only ratio = 1)\n\n  float fixedRatio = 1.;\n  vec2 fixedRatioBoxGivenSize = vec2(\n  (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n  (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n  );\n\n  v_objectBoxSize = getBoxSize(fixedRatio, fixedRatioBoxGivenSize).xy;\n  vec2 objectWorldScale = u_resolution.xy / v_objectBoxSize;\n\n  #ifdef ADD_HELPERS\n  v_objectHelperBox = uv;\n  v_objectHelperBox *= objectWorldScale;\n  v_objectHelperBox += boxOrigin * (objectWorldScale - 1.);\n  #endif\n\n  v_objectUV = uv;\n  v_objectUV *= objectWorldScale;\n  v_objectUV += boxOrigin * (objectWorldScale - 1.);\n  v_objectUV += graphicOffset;\n  v_objectUV /= u_scale;\n  v_objectUV = graphicRotation * v_objectUV;\n\n\n  // ===================================================\n\n\n  // ===================================================\n  // Sizing api for graphic objects with either givenBoxSize ratio or canvas ratio.\n  // Full-screen mode available with u_worldWidth = u_worldHeight = 0\n\n  v_responsiveBoxGivenSize = vec2(\n  (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n  (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n  );\n  float responsiveRatio = v_responsiveBoxGivenSize.x / v_responsiveBoxGivenSize.y;\n  v_responsiveBoxSize = getBoxSize(responsiveRatio, v_responsiveBoxGivenSize).xy;\n  vec2 responsiveBoxScale = u_resolution.xy / v_responsiveBoxSize;\n\n  #ifdef ADD_HELPERS\n  v_responsiveHelperBox = uv;\n  v_responsiveHelperBox *= responsiveBoxScale;\n  v_responsiveHelperBox += boxOrigin * (responsiveBoxScale - 1.);\n  #endif\n\n  v_responsiveUV = uv;\n  v_responsiveUV *= responsiveBoxScale;\n  v_responsiveUV += boxOrigin * (responsiveBoxScale - 1.);\n  v_responsiveUV += graphicOffset;\n  v_responsiveUV /= u_scale;\n  v_responsiveUV.x *= responsiveRatio;\n  v_responsiveUV = graphicRotation * v_responsiveUV;\n  v_responsiveUV.x /= responsiveRatio;\n\n  // ===================================================\n\n\n  // ===================================================\n  // Sizing api for patterns\n  // (treating graphics as a image u_worldWidth x u_worldHeight size)\n\n  float patternBoxRatio = givenBoxSize.x / givenBoxSize.y;\n  vec2 patternBoxGivenSize = vec2(\n  (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n  (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n  );\n  patternBoxRatio = patternBoxGivenSize.x / patternBoxGivenSize.y;\n\n  vec3 boxSizeData = getBoxSize(patternBoxRatio, patternBoxGivenSize);\n  v_patternBoxSize = boxSizeData.xy;\n  float patternBoxNoFitBoxWidth = boxSizeData.z;\n  vec2 patternBoxScale = u_resolution.xy / v_patternBoxSize;\n\n  #ifdef ADD_HELPERS\n  v_patternHelperBox = uv;\n  v_patternHelperBox *= patternBoxScale;\n  v_patternHelperBox += boxOrigin * (patternBoxScale - 1.);\n  #endif\n\n  v_patternUV = uv;\n  v_patternUV += graphicOffset / patternBoxScale;\n  v_patternUV += boxOrigin;\n  v_patternUV -= boxOrigin / patternBoxScale;\n  v_patternUV *= u_resolution.xy;\n  v_patternUV /= u_pixelRatio;\n  if (u_fit > 0.) {\n    v_patternUV *= (patternBoxNoFitBoxWidth / v_patternBoxSize.x);\n  }\n  v_patternUV /= u_scale;\n  v_patternUV = graphicRotation * v_patternUV;\n  v_patternUV += boxOrigin / patternBoxScale;\n  v_patternUV -= boxOrigin;\n  // x100 is a default multiplier between vertex and fragmant shaders\n  // we use it to avoid UV presision issues\n  v_patternUV *= .01;\n\n  // ===================================================\n\n\n  // ===================================================\n  // Sizing api for images\n\n  vec2 imageBoxSize;\n  if (u_fit == 1.) { // contain\n    imageBoxSize.x = min(u_resolution.x / u_imageAspectRatio, u_resolution.y) * u_imageAspectRatio;\n  } else if (u_fit == 2.) { // cover\n    imageBoxSize.x = max(u_resolution.x / u_imageAspectRatio, u_resolution.y) * u_imageAspectRatio;\n  } else {\n    imageBoxSize.x = min(10.0, 10.0 / u_imageAspectRatio * u_imageAspectRatio);\n  }\n  imageBoxSize.y = imageBoxSize.x / u_imageAspectRatio;\n  vec2 imageBoxScale = u_resolution.xy / imageBoxSize;\n\n  #ifdef ADD_HELPERS\n  vec2 imageHelperBox = uv;\n  imageHelperBox *= imageBoxScale;\n  imageHelperBox += boxOrigin * (imageBoxScale - 1.);\n  #endif\n\n  v_imageUV = uv;\n  v_imageUV *= imageBoxScale;\n  v_imageUV += boxOrigin * (imageBoxScale - 1.);\n  v_imageUV += graphicOffset;\n  v_imageUV /= u_scale;\n  v_imageUV.x *= u_imageAspectRatio;\n  v_imageUV = graphicRotation * v_imageUV;\n  v_imageUV.x /= u_imageAspectRatio;\n\n  v_imageUV += .5;\n  v_imageUV.y = 1. - v_imageUV.y;\n\n  // ===================================================\n\n}`;\n\n//# sourceMappingURL=vertex-shader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3QvdmVydGV4LXNoYWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxJQUFJLHdCQUF3QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxJQUFJLHdCQUF3QjtBQUM1QjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxDQUFDO0FBR0M7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3QvdmVydGV4LXNoYWRlci5qcz8yOGEwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiAgICAgICAgICAgICAgICAgICAgUGFwZXIgU2hhZGVycyAgICAgICAgICAgICAgICAgICAgKlxuICogICAgICAgaHR0cHM6Ly9naXRodWIuY29tL3BhcGVyLWRlc2lnbi9zaGFkZXJzICAgICAgICpcbiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqL1xuXG5jb25zdCB2ZXJ0ZXhTaGFkZXJTb3VyY2UgPSBgI3ZlcnNpb24gMzAwIGVzXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcblxubGF5b3V0KGxvY2F0aW9uID0gMCkgaW4gdmVjNCBhX3Bvc2l0aW9uO1xuXG51bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uO1xudW5pZm9ybSBmbG9hdCB1X3BpeGVsUmF0aW87XG51bmlmb3JtIGZsb2F0IHVfaW1hZ2VBc3BlY3RSYXRpbztcblxudW5pZm9ybSBmbG9hdCB1X29yaWdpblg7XG51bmlmb3JtIGZsb2F0IHVfb3JpZ2luWTtcbnVuaWZvcm0gZmxvYXQgdV93b3JsZFdpZHRoO1xudW5pZm9ybSBmbG9hdCB1X3dvcmxkSGVpZ2h0O1xudW5pZm9ybSBmbG9hdCB1X2ZpdDtcblxudW5pZm9ybSBmbG9hdCB1X3NjYWxlO1xudW5pZm9ybSBmbG9hdCB1X3JvdGF0aW9uO1xudW5pZm9ybSBmbG9hdCB1X29mZnNldFg7XG51bmlmb3JtIGZsb2F0IHVfb2Zmc2V0WTtcblxudW5pZm9ybSBmbG9hdCB1X3B4U2l6ZTtcblxub3V0IHZlYzIgdl9vYmplY3RVVjtcbm91dCB2ZWMyIHZfb2JqZWN0Qm94U2l6ZTtcbm91dCB2ZWMyIHZfb2JqZWN0SGVscGVyQm94O1xuXG5vdXQgdmVjMiB2X3Jlc3BvbnNpdmVVVjtcbm91dCB2ZWMyIHZfcmVzcG9uc2l2ZUJveFNpemU7XG5vdXQgdmVjMiB2X3Jlc3BvbnNpdmVIZWxwZXJCb3g7XG5vdXQgdmVjMiB2X3Jlc3BvbnNpdmVCb3hHaXZlblNpemU7XG5cbm91dCB2ZWMyIHZfcGF0dGVyblVWO1xub3V0IHZlYzIgdl9wYXR0ZXJuQm94U2l6ZTtcbm91dCB2ZWMyIHZfcGF0dGVybkhlbHBlckJveDtcblxub3V0IHZlYzIgdl9pbWFnZVVWO1xuXG4vLyAjZGVmaW5lIEFERF9IRUxQRVJTXG5cbnZlYzMgZ2V0Qm94U2l6ZShmbG9hdCBib3hSYXRpbywgdmVjMiBnaXZlbkJveFNpemUpIHtcbiAgdmVjMiBib3ggPSB2ZWMyKDAuKTtcbiAgLy8gZml0ID0gbm9uZVxuICBib3gueCA9IGJveFJhdGlvICogbWluKGdpdmVuQm94U2l6ZS54IC8gYm94UmF0aW8sIGdpdmVuQm94U2l6ZS55KTtcbiAgZmxvYXQgbm9GaXRCb3hXaWR0aCA9IGJveC54O1xuICBpZiAodV9maXQgPT0gMS4pIHsgLy8gZml0ID0gY29udGFpblxuICAgIGJveC54ID0gYm94UmF0aW8gKiBtaW4odV9yZXNvbHV0aW9uLnggLyBib3hSYXRpbywgdV9yZXNvbHV0aW9uLnkpO1xuICB9IGVsc2UgaWYgKHVfZml0ID09IDIuKSB7IC8vIGZpdCA9IGNvdmVyXG4gICAgYm94LnggPSBib3hSYXRpbyAqIG1heCh1X3Jlc29sdXRpb24ueCAvIGJveFJhdGlvLCB1X3Jlc29sdXRpb24ueSk7XG4gIH1cbiAgYm94LnkgPSBib3gueCAvIGJveFJhdGlvO1xuICByZXR1cm4gdmVjMyhib3gsIG5vRml0Qm94V2lkdGgpO1xufVxuXG52b2lkIG1haW4oKSB7XG4gIGdsX1Bvc2l0aW9uID0gYV9wb3NpdGlvbjtcblxuICB2ZWMyIHV2ID0gZ2xfUG9zaXRpb24ueHkgKiAuNTtcbiAgdmVjMiBib3hPcmlnaW4gPSB2ZWMyKC41IC0gdV9vcmlnaW5YLCB1X29yaWdpblkgLSAuNSk7XG4gIHZlYzIgZ2l2ZW5Cb3hTaXplID0gdmVjMih1X3dvcmxkV2lkdGgsIHVfd29ybGRIZWlnaHQpO1xuICBnaXZlbkJveFNpemUgPSBtYXgoZ2l2ZW5Cb3hTaXplLCB2ZWMyKDEuKSkgKiB1X3BpeGVsUmF0aW87XG4gIGZsb2F0IHIgPSB1X3JvdGF0aW9uICogMy4xNDE1OTI2NTM1ODk3OTMyMzg0NiAvIDE4MC47XG4gIG1hdDIgZ3JhcGhpY1JvdGF0aW9uID0gbWF0Mihjb3MociksIHNpbihyKSwgLXNpbihyKSwgY29zKHIpKTtcbiAgdmVjMiBncmFwaGljT2Zmc2V0ID0gdmVjMigtdV9vZmZzZXRYLCB1X29mZnNldFkpO1xuXG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFNpemluZyBhcGkgZm9yIGdyYXBoaWMgb2JqZWN0cyB3aXRoIGZpeGVkIHJhdGlvXG4gIC8vIChjdXJyZW50bHkgc3VwcG9ydHMgb25seSByYXRpbyA9IDEpXG5cbiAgZmxvYXQgZml4ZWRSYXRpbyA9IDEuO1xuICB2ZWMyIGZpeGVkUmF0aW9Cb3hHaXZlblNpemUgPSB2ZWMyKFxuICAodV93b3JsZFdpZHRoID09IDAuKSA/IHVfcmVzb2x1dGlvbi54IDogZ2l2ZW5Cb3hTaXplLngsXG4gICh1X3dvcmxkSGVpZ2h0ID09IDAuKSA/IHVfcmVzb2x1dGlvbi55IDogZ2l2ZW5Cb3hTaXplLnlcbiAgKTtcblxuICB2X29iamVjdEJveFNpemUgPSBnZXRCb3hTaXplKGZpeGVkUmF0aW8sIGZpeGVkUmF0aW9Cb3hHaXZlblNpemUpLnh5O1xuICB2ZWMyIG9iamVjdFdvcmxkU2NhbGUgPSB1X3Jlc29sdXRpb24ueHkgLyB2X29iamVjdEJveFNpemU7XG5cbiAgI2lmZGVmIEFERF9IRUxQRVJTXG4gIHZfb2JqZWN0SGVscGVyQm94ID0gdXY7XG4gIHZfb2JqZWN0SGVscGVyQm94ICo9IG9iamVjdFdvcmxkU2NhbGU7XG4gIHZfb2JqZWN0SGVscGVyQm94ICs9IGJveE9yaWdpbiAqIChvYmplY3RXb3JsZFNjYWxlIC0gMS4pO1xuICAjZW5kaWZcblxuICB2X29iamVjdFVWID0gdXY7XG4gIHZfb2JqZWN0VVYgKj0gb2JqZWN0V29ybGRTY2FsZTtcbiAgdl9vYmplY3RVViArPSBib3hPcmlnaW4gKiAob2JqZWN0V29ybGRTY2FsZSAtIDEuKTtcbiAgdl9vYmplY3RVViArPSBncmFwaGljT2Zmc2V0O1xuICB2X29iamVjdFVWIC89IHVfc2NhbGU7XG4gIHZfb2JqZWN0VVYgPSBncmFwaGljUm90YXRpb24gKiB2X29iamVjdFVWO1xuXG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gU2l6aW5nIGFwaSBmb3IgZ3JhcGhpYyBvYmplY3RzIHdpdGggZWl0aGVyIGdpdmVuQm94U2l6ZSByYXRpbyBvciBjYW52YXMgcmF0aW8uXG4gIC8vIEZ1bGwtc2NyZWVuIG1vZGUgYXZhaWxhYmxlIHdpdGggdV93b3JsZFdpZHRoID0gdV93b3JsZEhlaWdodCA9IDBcblxuICB2X3Jlc3BvbnNpdmVCb3hHaXZlblNpemUgPSB2ZWMyKFxuICAodV93b3JsZFdpZHRoID09IDAuKSA/IHVfcmVzb2x1dGlvbi54IDogZ2l2ZW5Cb3hTaXplLngsXG4gICh1X3dvcmxkSGVpZ2h0ID09IDAuKSA/IHVfcmVzb2x1dGlvbi55IDogZ2l2ZW5Cb3hTaXplLnlcbiAgKTtcbiAgZmxvYXQgcmVzcG9uc2l2ZVJhdGlvID0gdl9yZXNwb25zaXZlQm94R2l2ZW5TaXplLnggLyB2X3Jlc3BvbnNpdmVCb3hHaXZlblNpemUueTtcbiAgdl9yZXNwb25zaXZlQm94U2l6ZSA9IGdldEJveFNpemUocmVzcG9uc2l2ZVJhdGlvLCB2X3Jlc3BvbnNpdmVCb3hHaXZlblNpemUpLnh5O1xuICB2ZWMyIHJlc3BvbnNpdmVCb3hTY2FsZSA9IHVfcmVzb2x1dGlvbi54eSAvIHZfcmVzcG9uc2l2ZUJveFNpemU7XG5cbiAgI2lmZGVmIEFERF9IRUxQRVJTXG4gIHZfcmVzcG9uc2l2ZUhlbHBlckJveCA9IHV2O1xuICB2X3Jlc3BvbnNpdmVIZWxwZXJCb3ggKj0gcmVzcG9uc2l2ZUJveFNjYWxlO1xuICB2X3Jlc3BvbnNpdmVIZWxwZXJCb3ggKz0gYm94T3JpZ2luICogKHJlc3BvbnNpdmVCb3hTY2FsZSAtIDEuKTtcbiAgI2VuZGlmXG5cbiAgdl9yZXNwb25zaXZlVVYgPSB1djtcbiAgdl9yZXNwb25zaXZlVVYgKj0gcmVzcG9uc2l2ZUJveFNjYWxlO1xuICB2X3Jlc3BvbnNpdmVVViArPSBib3hPcmlnaW4gKiAocmVzcG9uc2l2ZUJveFNjYWxlIC0gMS4pO1xuICB2X3Jlc3BvbnNpdmVVViArPSBncmFwaGljT2Zmc2V0O1xuICB2X3Jlc3BvbnNpdmVVViAvPSB1X3NjYWxlO1xuICB2X3Jlc3BvbnNpdmVVVi54ICo9IHJlc3BvbnNpdmVSYXRpbztcbiAgdl9yZXNwb25zaXZlVVYgPSBncmFwaGljUm90YXRpb24gKiB2X3Jlc3BvbnNpdmVVVjtcbiAgdl9yZXNwb25zaXZlVVYueCAvPSByZXNwb25zaXZlUmF0aW87XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gU2l6aW5nIGFwaSBmb3IgcGF0dGVybnNcbiAgLy8gKHRyZWF0aW5nIGdyYXBoaWNzIGFzIGEgaW1hZ2UgdV93b3JsZFdpZHRoIHggdV93b3JsZEhlaWdodCBzaXplKVxuXG4gIGZsb2F0IHBhdHRlcm5Cb3hSYXRpbyA9IGdpdmVuQm94U2l6ZS54IC8gZ2l2ZW5Cb3hTaXplLnk7XG4gIHZlYzIgcGF0dGVybkJveEdpdmVuU2l6ZSA9IHZlYzIoXG4gICh1X3dvcmxkV2lkdGggPT0gMC4pID8gdV9yZXNvbHV0aW9uLnggOiBnaXZlbkJveFNpemUueCxcbiAgKHVfd29ybGRIZWlnaHQgPT0gMC4pID8gdV9yZXNvbHV0aW9uLnkgOiBnaXZlbkJveFNpemUueVxuICApO1xuICBwYXR0ZXJuQm94UmF0aW8gPSBwYXR0ZXJuQm94R2l2ZW5TaXplLnggLyBwYXR0ZXJuQm94R2l2ZW5TaXplLnk7XG5cbiAgdmVjMyBib3hTaXplRGF0YSA9IGdldEJveFNpemUocGF0dGVybkJveFJhdGlvLCBwYXR0ZXJuQm94R2l2ZW5TaXplKTtcbiAgdl9wYXR0ZXJuQm94U2l6ZSA9IGJveFNpemVEYXRhLnh5O1xuICBmbG9hdCBwYXR0ZXJuQm94Tm9GaXRCb3hXaWR0aCA9IGJveFNpemVEYXRhLno7XG4gIHZlYzIgcGF0dGVybkJveFNjYWxlID0gdV9yZXNvbHV0aW9uLnh5IC8gdl9wYXR0ZXJuQm94U2l6ZTtcblxuICAjaWZkZWYgQUREX0hFTFBFUlNcbiAgdl9wYXR0ZXJuSGVscGVyQm94ID0gdXY7XG4gIHZfcGF0dGVybkhlbHBlckJveCAqPSBwYXR0ZXJuQm94U2NhbGU7XG4gIHZfcGF0dGVybkhlbHBlckJveCArPSBib3hPcmlnaW4gKiAocGF0dGVybkJveFNjYWxlIC0gMS4pO1xuICAjZW5kaWZcblxuICB2X3BhdHRlcm5VViA9IHV2O1xuICB2X3BhdHRlcm5VViArPSBncmFwaGljT2Zmc2V0IC8gcGF0dGVybkJveFNjYWxlO1xuICB2X3BhdHRlcm5VViArPSBib3hPcmlnaW47XG4gIHZfcGF0dGVyblVWIC09IGJveE9yaWdpbiAvIHBhdHRlcm5Cb3hTY2FsZTtcbiAgdl9wYXR0ZXJuVVYgKj0gdV9yZXNvbHV0aW9uLnh5O1xuICB2X3BhdHRlcm5VViAvPSB1X3BpeGVsUmF0aW87XG4gIGlmICh1X2ZpdCA+IDAuKSB7XG4gICAgdl9wYXR0ZXJuVVYgKj0gKHBhdHRlcm5Cb3hOb0ZpdEJveFdpZHRoIC8gdl9wYXR0ZXJuQm94U2l6ZS54KTtcbiAgfVxuICB2X3BhdHRlcm5VViAvPSB1X3NjYWxlO1xuICB2X3BhdHRlcm5VViA9IGdyYXBoaWNSb3RhdGlvbiAqIHZfcGF0dGVyblVWO1xuICB2X3BhdHRlcm5VViArPSBib3hPcmlnaW4gLyBwYXR0ZXJuQm94U2NhbGU7XG4gIHZfcGF0dGVyblVWIC09IGJveE9yaWdpbjtcbiAgLy8geDEwMCBpcyBhIGRlZmF1bHQgbXVsdGlwbGllciBiZXR3ZWVuIHZlcnRleCBhbmQgZnJhZ21hbnQgc2hhZGVyc1xuICAvLyB3ZSB1c2UgaXQgdG8gYXZvaWQgVVYgcHJlc2lzaW9uIGlzc3Vlc1xuICB2X3BhdHRlcm5VViAqPSAuMDE7XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gU2l6aW5nIGFwaSBmb3IgaW1hZ2VzXG5cbiAgdmVjMiBpbWFnZUJveFNpemU7XG4gIGlmICh1X2ZpdCA9PSAxLikgeyAvLyBjb250YWluXG4gICAgaW1hZ2VCb3hTaXplLnggPSBtaW4odV9yZXNvbHV0aW9uLnggLyB1X2ltYWdlQXNwZWN0UmF0aW8sIHVfcmVzb2x1dGlvbi55KSAqIHVfaW1hZ2VBc3BlY3RSYXRpbztcbiAgfSBlbHNlIGlmICh1X2ZpdCA9PSAyLikgeyAvLyBjb3ZlclxuICAgIGltYWdlQm94U2l6ZS54ID0gbWF4KHVfcmVzb2x1dGlvbi54IC8gdV9pbWFnZUFzcGVjdFJhdGlvLCB1X3Jlc29sdXRpb24ueSkgKiB1X2ltYWdlQXNwZWN0UmF0aW87XG4gIH0gZWxzZSB7XG4gICAgaW1hZ2VCb3hTaXplLnggPSBtaW4oMTAuMCwgMTAuMCAvIHVfaW1hZ2VBc3BlY3RSYXRpbyAqIHVfaW1hZ2VBc3BlY3RSYXRpbyk7XG4gIH1cbiAgaW1hZ2VCb3hTaXplLnkgPSBpbWFnZUJveFNpemUueCAvIHVfaW1hZ2VBc3BlY3RSYXRpbztcbiAgdmVjMiBpbWFnZUJveFNjYWxlID0gdV9yZXNvbHV0aW9uLnh5IC8gaW1hZ2VCb3hTaXplO1xuXG4gICNpZmRlZiBBRERfSEVMUEVSU1xuICB2ZWMyIGltYWdlSGVscGVyQm94ID0gdXY7XG4gIGltYWdlSGVscGVyQm94ICo9IGltYWdlQm94U2NhbGU7XG4gIGltYWdlSGVscGVyQm94ICs9IGJveE9yaWdpbiAqIChpbWFnZUJveFNjYWxlIC0gMS4pO1xuICAjZW5kaWZcblxuICB2X2ltYWdlVVYgPSB1djtcbiAgdl9pbWFnZVVWICo9IGltYWdlQm94U2NhbGU7XG4gIHZfaW1hZ2VVViArPSBib3hPcmlnaW4gKiAoaW1hZ2VCb3hTY2FsZSAtIDEuKTtcbiAgdl9pbWFnZVVWICs9IGdyYXBoaWNPZmZzZXQ7XG4gIHZfaW1hZ2VVViAvPSB1X3NjYWxlO1xuICB2X2ltYWdlVVYueCAqPSB1X2ltYWdlQXNwZWN0UmF0aW87XG4gIHZfaW1hZ2VVViA9IGdyYXBoaWNSb3RhdGlvbiAqIHZfaW1hZ2VVVjtcbiAgdl9pbWFnZVVWLnggLz0gdV9pbWFnZUFzcGVjdFJhdGlvO1xuXG4gIHZfaW1hZ2VVViArPSAuNTtcbiAgdl9pbWFnZVVWLnkgPSAxLiAtIHZfaW1hZ2VVVi55O1xuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG59YDtcbmV4cG9ydCB7XG4gIHZlcnRleFNoYWRlclNvdXJjZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnRleC1zaGFkZXIuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/vertex-shader.js\n");

/***/ })

};
;